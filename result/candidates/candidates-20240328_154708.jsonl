{"SampleId": 5075805, "Origin": "Save basic clusters.", "Reference": "Save cluster basic configuration.", "LLMCandidates": ["Save cluster basic configuration.", "Save cluster basic configuration.", "Save cluster basic configuration.", "Save cluster basic configuration.", "Save cluster basic configuration."]}
{"SampleId": 668963, "Origin": "Configure a sslConfig for the server using the legacy configuration", "Reference": "Configure a SSLConfig.Builder for the server using the legacy configuration", "LLMCandidates": ["Configure a sslConfig for the server using the legacy configuration with a builder.", "Configure a SSLConfig.Builder for the server using the legacy configuration", "Configure a SSLConfig.Builder for the server using the legacy configuration", "Configure a SSLConfig for the server using the legacy configuration with builder pattern.", "Configure a SSLConfig for the server using the legacy configuration with builder pattern."]}
{"SampleId": 5425047, "Origin": "If the wrapping fails,\nthen null is returned.", "Reference": "If wrapping fails, returns null.", "LLMCandidates": ["If the wrapping operation fails, then null is returned.", "If the wrapping fails or is not applicable, then null is returned.", "If the wrapping fails, then null is returned.", "If the wrapping fails, then null is returned.", "If the wrapping fails or cannot be performed properly, then null is returned."]}
{"SampleId": 2217833, "Origin": "Test of npara method, of class GeometricDistribution.", "Reference": "Test of length method, of class GeometricDistribution.", "LLMCandidates": ["Test of length method, of class GeometricDistribution.", "Test of length method, of class GeometricDistribution.", "Test of length method, of class GeometricDistribution.", "Test of length method, of class GeometricDistribution.", "Test of length method, of class GeometricDistribution."]}
{"SampleId": 4708521, "Origin": "Bui (2015) \"Cachediff: Fast Random Sampling\" URL", "Reference": "Bui (2015) \"CacheDiff: Fast Random Sampling\" URL", "LLMCandidates": ["Draws a random sample of n points from a set of N points, using the Fisher-Yates shuffle and keeping track of what has been moved with a HashMap. Based on the paper \"Cachediff: Fast Random Sampling\" by Bui (2015).", "Draws a sample of n points from N points with replacement, using the Fisher-Yates shuffle and a HashMap to track indices selected. This method was described in Bui (2015) \"CacheDiff: Fast Random Sampling\" URL.", "Bui (2015) \\\"CacheDiff: Fast Random Sampling\\\" URL", "Bui (2015) \"CacheDiff: Fast Random Sampling\" URL", "Draws n points randomly from a set of N points with repetition allowed. This is achieved by performing a partial Fisher-Yates shuffle and keeping track of the selected indices using a HashMap. The method assumes that n <= N and both n and N are non-negative integers, otherwise an IllegalArgumentException is thrown."]}
{"SampleId": 339279, "Origin": "If it's successfully completed, {@link BrowserResult#getMediaItems()} will return the search\nresult.", "Reference": "If it's successfully completed, {@link LibraryResult#getMediaItems()} will return the search\nresult.", "LLMCandidates": ["If it's successfully completed, {@link LibraryResult#getMediaItems()} will return the search result.", "If it's successfully completed, {@link LibraryResult#getMediaItems()} will return the search result.", "If it's successfully completed, {@link LibraryResult#getMediaItems()} will return the search result.", "If it's successfully completed, {@link LibraryResult#getMediaItems()} will return the search result.", "If it's successfully completed, {@link LibraryResult#getMediaItems()} will return the search result."]}
{"SampleId": 5629914, "Origin": "Sets the options.", "Reference": "Set the options.", "LLMCandidates": ["Sets the options using a builder pattern.", "Sets the options by using a builder pattern.", "Set the options using the Builder pattern.", "Set the options using the Builder pattern.", "Set the options using the Builder pattern."]}
{"SampleId": 2996629, "Origin": "Convenience method to get custom install file", "Reference": "Convenience method to get custom installation script", "LLMCandidates": ["Gets installation script properties from either an absolute path or classpath location based on System property \"installation.script", "Loads installation properties either from a system property or from the classpath, depending on their existence.", "Gets installation script properties from either absolute path or classpath based on the system property \"installation.script\".", "Gets installation script properties from either absolute path or classpath based on the system property \"installation.script\".", "Convenience method for getting installation properties from either an absolute path or classpath resource, based on System property \"installation.script\"."]}
{"SampleId": 5629994, "Origin": "Sets the confidence.", "Reference": "Set the confidence.", "LLMCandidates": ["Sets the confidence in a builder pattern.", "Sets the confidence value in a builder pattern.", "Sets the confidence value in a builder pattern.", "Sets the confidence in a builder pattern.", "Sets the confidence in a builder pattern."]}
{"SampleId": 3992375, "Origin": "Request an update of the current cluster metadata info, return the current version before the update", "Reference": "Request an update of the current cluster metadata info, return the current updateVersion before the update", "LLMCandidates": ["Request an update of the current cluster metadata info, return the updated version before the update", "Request an update of the current cluster metadata info, return the current updateVersion before the update", "Request an update of the current cluster metadata info, return the current updateVersion before the update", "Request an update of the current cluster metadata info, return the updated version after the update.", "Request an update of the current cluster metadata info, return the updated version after the update."]}
{"SampleId": 570076, "Origin": "Gets the full path from a full filename, which is the prefix + path.", "Reference": "Gets the full path from a full fileName, which is the prefix + path.", "LLMCandidates": ["Gets the full path from a full file name, which is the prefix + path.", "Gets the full path from a file name, which is the prefix + path.", "Gets the full path from a file name, which is the prefix + path.", "Gets the full path from a file name, which is the prefix + path.", "Gets the full path from a fileName, which is the prefix + path."]}
{"SampleId": 5455336, "Origin": "Unlinks interior Node p with predecessor trail.", "Reference": "Unlinks interior Node p with predecessor pred.", "LLMCandidates": ["Unlinks interior Node p with predecessor pred.", "Unlinks interior Node p with predecessor pred.", "Unlinks interior Node p with predecessor pred.", "Unlinks interior Node p with predecessor pred.", "Unlinks interior Node p with predecessor pred."]}
{"SampleId": 6165700, "Origin": "Create a new client with the given connection string.", "Reference": "Create a new client with the given client settings.", "LLMCandidates": ["Create a new MongoClient instance using the given settings, and return it.", "Create a new client with the given MongoClientSettings object.", "Create a new MongoClient with the given MongoClientSettings settings and default command listeners.", "Create a new MongoClient with the given MongoClientSettings settings and default command listeners.", "Create a new MongoClient instance with the given MongoClientSettings and optional command listeners."]}
{"SampleId": 5062276, "Origin": "The buffer resets\nafter this method is called, so this method should only be called once per BlobDescriptor.", "Reference": "The buffer\nresets after this method is called, so this method should only be called once per computation.", "LLMCandidates": ["computeDigest()} is called only once per BlobDescriptor to compute a digest and set descriptorDigest. The buffer resets after this method is called.", "This method is called once per BlobDescriptor to compute the digest and set the descriptor digest variable. After this call, the buffer resets, so it should only be called once for a given BlobDescriptor object.", "This method should only be called once per BlobDescriptor, as the buffer is reset after it's called.", "This method should only be called once per BlobDescriptor after it has been constructed, as the buffer resets after this method is called.", "This method should only be called once per BlobDescriptor, as the buffer resets after its execution."]}
{"SampleId": 336204, "Origin": "Sets the host's {@link OnBackPressedDispatcherOwner}.", "Reference": "Sets the host's {@link OnBackPressedDispatcher}.", "LLMCandidates": ["Sets the host's {@link OnBackPressedDispatcher}.", "Sets the host's {@link OnBackPressedDispatcher}.", "Sets the host's {@link OnBackPressedDispatcher}.", "Sets the host's {@link OnBackPressedDispatcher}.", "Sets the host's {@link OnBackPressedDispatcher}."]}
{"SampleId": 1922872, "Origin": "Creates a {@link NativeLinkable} using sources compiled by the D compiler.", "Reference": "Creates a {@link NativeLinkableGroup} using sources compiled by the D compiler.", "LLMCandidates": ["Creates a {@link NativeLinkable} using sources compiled by the D compiler and its dependencies.", "Creates a {@link NativeLinkable} using sources compiled by the D compiler and filtering build dependencies with the {@link NativeLinkableGroup} class.", "Creates a {@link NativeLinkable} using sources compiled by the D compiler and build dependencies using the specified build target and project filesystem.", "Creates a {@link NativeLinkable} using sources compiled by the D compiler with modified build dependencies and parameters.", "Creates a {@link NativeLinkable} using sources compiled by the D compiler and its dependencies."]}
{"SampleId": 3037028, "Origin": "Sets the CPU status (free or busy).", "Reference": "Sets the CPU status (free or busy since some ms).", "LLMCandidates": ["Sets the busy state since time.", "Sets the busy status by specifying the time elapsed since the device became busy.", "Sets the busy state since a certain time (in milliseconds).", "Sets the busy state since a certain time (in milliseconds).", "Sets the busy duration since a specified time."]}
{"SampleId": 6017988, "Origin": "Computes the maximum for each pixel across all bands in the {@link Planar} image.", "Reference": "Computes the maximum for each pixel across selected bands in the {@link Planar} image.", "LLMCandidates": ["Computes the maximum for each pixel across all bands in the {@link Planar} image and reshapes the output array to the same size as the input.", "Computes the maximum for each pixel across all bands in the Planar image and reshapes the output to match the input dimensions.", "Computes the maximum for each pixel across all bands in the Planar image and sets the output shape to be the same as the input's shape.", "Computes the maximum for each pixel across all bands in the {@link Planar} image, and reshapes the output to have the same width and height as the input.", "Computes the maximum for each pixel across all bands in the {@link Planar} image, reshaping the output to match the input dimensions before applying the maximum operation."]}
{"SampleId": 4396494, "Origin": "Returns a string representation of this object; useful for testing and debugging.", "Reference": "Returns a string representation of this object.", "LLMCandidates": ["Returns a string representation of this object; useful for testing and debugging with sensitive data redacted.", "Returns a string representation of this object; useful for testing and debugging. The AccessToken is now redacted with \"***Sensitive Data Redacted***\" to protect sensitive information.", "Returns a string representation of this object with sensitive data redacted; useful for testing and debugging.", "Returns a string representation of this object with sensitive data redacted; useful for testing and debugging.", "Returns a string representation of this object; useful for testing and debugging. If the AccessToken is not null, the sensitive data will be redacted with \"***Sensitive Data Redacted***\"."]}
{"SampleId": 4617099, "Origin": "Closes the Websocket-Connection.", "Reference": "Closes the WebSocket connection.", "LLMCandidates": ["Closes the Websocket-Connection, setting a closed status without providing a reason.", "Closes the Websocket-Connection without a specific reason.", "Closes the Websocket-Connection by calling the close method on the Session object.", "Closes the Websocket-Connection without providing a reason.", "Closes the Websocket-Connection without providing a reason."]}
{"SampleId": 3676014, "Origin": "For example, the period in hours between two times can be calculated\nusing {@code startTime.periodUntil(endTime, HOURS)}.", "Reference": "For example, the period in hours between two times can be calculated\nusing {@code startTime.until(endTime, HOURS)}.", "LLMCandidates": ["Calculate the period between two times using {@code startTime.until(endTime, unit)} for various units like nanos, micros, millis, seconds, minutes, hours, or half days.", "For example, the period in hours between two times can be calculated using {@code startTime.until(endTime, HOURS)}.", "Calculate the period between two times using {@code startTime.until(endTime, unit)} where {@code unit} is a valid temporal unit.", "For example, the period in hours between two times can be calculated using {@code startTime.until(endTime, HOURS)}.", "Calculate the period between two LocalTime instances using {@code startTime.until(endTime, ChronoUnit.<unit>)}."]}
{"SampleId": 5724303, "Origin": "Converts an array of raw binary data into an array of ascii 0 and 1 character bytes - each byte is a truncated\nchar.", "Reference": "Converts an array of raw binary data into an array of ASCII 0 and 1 character bytes - each byte is a truncated\nchar.", "LLMCandidates": ["Converts an array of raw binary data into an array of ASCII 0 and 1 character bytes - each byte is a truncated char.", "Converts an array of raw binary data into an array of ASCII 0 and 1 character bytes - each byte is a truncated char.", "Converts an array of raw binary data into an array of ASCII 0 and 1 character bytes - each byte is a truncated char.", "Converts an array of raw binary data into an array of ASCII 0 and 1 character bytes - each byte is a truncated char.", "Converts an array of raw binary data into an array of ASCII 0 and 1 character bytes - each byte is a truncated char."]}
{"SampleId": 2050129, "Origin": "Pauses all downloads.", "Reference": "Pauses downloads.", "LLMCandidates": ["Pauses all downloads if they are not already paused.", "Pauses all downloads if not already paused. Marks downloads as paused and sends a message to the handler.", "Pauses all downloads if they are not already paused.", "Pauses all downloads if they are not already paused.", "Pauses all downloads if they are not already paused."]}
{"SampleId": 6190739, "Origin": "Loads the {@link Class} using the application {@link ArtifactClassLoader}.", "Reference": "Loads the {@link Class} using the test runner {@link ArtifactClassLoader}.", "LLMCandidates": ["Loads the {@link Class} using the TestRunnerPlugin {@link ArtifactClassLoader}.", "Loads the {@link Class} using the test runner {@link ArtifactClassLoader}.", "Loads the {@link Class} using the test runner {@link ArtifactClassLoader}.", "Loads the {@link Class} using the test runner {@link ArtifactClassLoader}.", "Loads the {@link Class} using the test runner {@link ArtifactClassLoader}."]}
{"SampleId": 440280, "Origin": "Convenient way to build a {@code BeamSqlRowType}.", "Reference": "Convenient way to build a {@link Schema}.", "LLMCandidates": ["Convenient way to build a {@code BeamSqlSchema}.", "Convenient way to build a {@code BeamSqlSchema}.", "Convenient way to build a {@code BeamSqlSchema}.", "Convenient way to build a {@code BeamSqlSchema}.", "Convenient way to build a {@code BeamSqlSchema}."]}
{"SampleId": 2357146, "Origin": "Calculates intersection of the image and the render filter region in the coordinate system relative to image.", "Reference": "Calculates intersection of the image and the render filter region in the coordinate system relative to the image.", "LLMCandidates": ["Calculates intersection of the image and the render filter region in the coordinate system relative to the image after applying the given ImageRenderInfo's ImageCTM.", "Calculates intersection of the image and the render filter region in the coordinate system relative to image using ImageRenderInfo and the provided image CTM.", "Calculates intersection of the image and the render filter region in the coordinate system relative to image using an ImageRenderInfo object as input and a predefined rectangle.", "Calculates intersection of the image and the render filter region in the coordinate system relative to image, considering the transformation matrix applied to the image.", "Calculates intersection of the image and the render filter region in the coordinate system relative to image by applying the transformation matrix from the ImageRenderInfo."]}
{"SampleId": 4471751, "Origin": "If keys = \"abc1234\", settings with a key equal to \"abc1234\" are returned.", "Reference": "If {@code keyFilter = \"abc1234\"}, settings with a key equal to \"abc1234\" are returned.", "LLMCandidates": ["If keyFilter is \"abc1234\", settings with a key equal to \"abc1234\" are returned.", "If keyFilter is set to \"abc1234\", settings with a key equal to \"abc1234\" are returned.", "If keyFilter = \"abc1234\", settings with a key equal to \"abc1234\" are returned.", "If keyFilter = \"abc1234\", settings with a key equal to \"abc1234\" are returned.", "If keyFilter = \"abc1234\", settings with a key equal to \"abc1234\" are returned."]}
{"SampleId": 6100158, "Origin": "18:43:59\nCAUTION: Does NOT recognize values with a timezone information (...[+-Z]...)", "Reference": "CAUTION: Does NOT recognize values with a timezone information (...[+-Z]...)", "LLMCandidates": ["CAUTION: Does NOT recognize values with a timezone information or if it is Now/Today format", "CAUTION: Does NOT recognize values with a timezone information (...[+-Z]...) || Recognizes if the ISO date format is \"^\\\\d{2}:\\\\d{2}:\\\\d{2}$\" or follows NowAndTodayUtil's format.", "CAUTION: Does NOT recognize values with a timezone information (...[+-Z]...), but also considers \"Now\" or \"Today\" formats.", "CAUTION: Does NOT recognize values with a timezone information (...[+-Z]...) or if they are in the current format of Now And Today.", "CAUTION: Does NOT recognize values with a timezone information (...[+-Z]...) or values that match NowAndTodayUtil"]}
{"SampleId": 3403203, "Origin": "generic method for untyped messages.", "Reference": "generic method for untyped remoting.", "LLMCandidates": ["Send a message identified by messageId with optional arguments to the scheduler for execution.", "Public void tell(String messageId, Object ... args ) { getScheduler().enqueueCall(Actor.sender.get(),getActor(),messageId,args,false);", "generic method for untyped messages using a scheduler to enqueue calls.", "generic method for untyped messages using a scheduler to enqueue calls.", "CallerSideMethod} send a message with the specified messageId and arguments to the current actor using the scheduler's enqueueCall method."]}
{"SampleId": 2912053, "Origin": "Sets the additional trade information, defaulted to an empty instance.", "Reference": "Sets the additional information, defaulted to an empty instance.", "LLMCandidates": ["Sets the additional trade information using PortfolioItemInfo, defaulted to an empty instance.", "Sets the additional portfolio item information, defaulted to an empty instance.", "Sets the portfolio item information by validating its non-null value and setting it to the builder instance.", "Sets the portfolio item information by validating its non-null value and setting it to the builder instance.", "Sets the additional portfolio information using PortfolioItemInfo object, defaulted to an empty instance."]}
{"SampleId": 6045146, "Origin": "or throws a {@link com.liferay.calendar.NoSuchResourceException} if it could not be found.", "Reference": "or throws a {@link NoSuchResourceException} if it could not be found.", "LLMCandidates": ["Finds a CalendarResource by classNameId and classPK or throws a {@link com.liferay.calendar.NoSuchResourceException} if it could not be found.", "Finds a CalendarResource object with the specified classNameId and classPK parameters, or throws a {@link com.liferay.calendar.NoSuchResourceException} if it could not be found.", "Finds a CalendarResource by its classNameId and classPK parameters or throws a {@link com.liferay.calendar.NoSuchResourceException} if it could not be found.", "com.liferay.calendar.model.CalendarResource findByC_C(long classNameId, long classPK) throws com.liferay.calendar.NoSuchResourceException}}\n\nReturns a CalendarResource with the primary key matching the given values or throws a {@link com.liferay.calendar.NoSuchResourceException} if it could not be found.", "Find a resource by its classNameId and classPK. Throws a {@link com.liferay.calendar.NoSuchResourceException} if it could not be found."]}
{"SampleId": 113779, "Origin": "Initializes and returns the hashtable of all permissions known in the system.", "Reference": "Initializes and returns the linked hash map of all permissions known in the system.", "LLMCandidates": ["Initializes and returns an immutable map of all permissions known in the system.", "Initializes and returns an immutable hashtable of all permissions known in the system.", "Initializes and returns an immutable hashtable of all permissions known in the system.", "Initializes and returns the hashtable of all permissions known in the system by creating a LinkedHashMap for better performance. The map is made unmodifiable after initialization to prevent direct changes.", "Initializes and returns an immutable map of all permissions known in the system."]}
{"SampleId": 4474377, "Origin": "Grants the role read permissions on the resource.", "Reference": "Sets the read permission status.", "LLMCandidates": ["Grants role read permissions on the resource.", "Sets the read permission based on the given boolean value.", "Sets the read permission based on the given boolean value.", "Sets the read permission based on the given boolean value.", "Grants read permission for the role on the resource."]}
{"SampleId": 1843363, "Origin": "Waits during {@code timeout} until text extracted from specified {@code webElement} by {@link", "Reference": "Waits during {@code timeout} until value extracted from specified {@code element} by {@link", "LLMCandidates": ["Waits during {@code timeout} until text extracted from specified {@code element} by {@link", "Waits during {@code timeout} until text extracted from specified {@code element} by {@link waitValueEqualsTo}.", "Waits during {@code timeout} until text extracted from specified {@code element} by {@link waitVisibilityAndGetValue(WebElement, int)} and compares it with the expected value. If they are equal, the method returns immediately. Otherwise, it continues to wait until the expected condition is met. The error message format has been changed for better clarity.", "Waits during {@code timeout} until text extracted from specified {@code element} by {@link }. The updated code now checks the actual value against the expected value, displaying an error message if they don't match using a custom {@code formatted} message. This allows for better error handling and output.", "Waits during {@code timeout} for the text extracted from specified {@code element} to be equal to {@code expectedValue}. The result will be checked against {@code expectedValue} and logged with a custom message if the condition is not met."]}
{"SampleId": 1311563, "Origin": "Scenario:\n  - no CA inherited trust\n  - gateway does not explicitly trust the service, but automatically validates against self-signed\n  - service trusts gateway certificate", "Reference": "Scenario:\n  - no CA inherited trust\n  - gateway does not explicitly trust the API, but automatically validates against self-signed\n  - API trusts gateway certificate", "LLMCandidates": ["Scenario: \n- no CA inherited trust\n- gateway does not explicitly trust the service, but automatically validates against self-signed\n- service trusts gateway certificate", "The scenario involves an HTTP connection established using mutual TLS authentication. In this case, the server certificate trust is not inherited from the CA but rather automatically validates against self-signed certificates. On the other hand, the client (service) explicitly trusts the gateway's certificate.", "Scenario: \n- no CA inherited trust\n- gateway does not explicitly trust the service, but automatically validates against self-signed\n- service trusts gateway certificate", "The test demonstrates a scenario where the gateway does not implicitly trust the service certificate but validates against self-signed certificates automatically. In this case, the gateway's truststore is set to accept self-signed certificates (TLS_ALLOWSELFSIGNED) and trusts its own certificate. The service also trusts the gateway's certificate.", "Scenario: - no CA inherited trust - gateway does not explicitly trust the service, but automatically validates against self-signed - service trusts gateway certificate"]}
{"SampleId": 1878506, "Origin": "Check if there is any negative cost (= improvement).", "Reference": "Find the smallest (most negative) value.", "LLMCandidates": ["Finds the index of the minimum cost in the given array of costs.", "Finds the index of the element with the minimum cost (= improvement) in the given array.", "Finds the smallest cost (=improvement) within a list of costs.", "Determine the minimum cost (= improvement) among given values.", "Determine the minimum cost (= improvement) among given values."]}
{"SampleId": 302612, "Origin": "see\nURL\nhtml", "Reference": "see\nURL", "LLMCandidates": ["Test early evaluation of template files by rendering a template file and inspecting the result. The test ensures that a given template renders the expected output and does not throw an exception in 4.0.2 version.", "Test the early evaluation of templates by rendering the main function and asserting its result is \"-ax-*-ay-\". If an exception occurs when inspecting the output, close any open windows and wait for all to be closed.", "Test an example of early evaluation using templates, rendering a string with placeholders and asserting its output. Inspect the resulting ST object and dispose of any related window before waiting for all windows to close.", "Tests the evaluation of templates where f(p=\\\"x\\\") is called multiple times followed by f(p=\\\"y\\\"). Renders the result and inspects it to visualize the template.", "Test a simple template with early evaluation and rendering. The main() template uses f(p=\"x\") followed by f(p=\"y\"). The f() template takes parameters p and q, which have default values. Render the main() template and verify the output is \"-ax-*-ay-\". Inspect the template to visualize it using STViz, and close any windows as needed."]}
{"SampleId": 6192460, "Origin": "Create new {@link Builder} based on an existing {@link BaseEvent} instance.", "Reference": "Create new {@link Builder} based on an existing {@link CoreEvent} instance.", "LLMCandidates": ["Create new {@link Builder} based on an existing {@link CoreEvent} instance.", "Create new {@link Builder} based on an existing {@link CoreEvent} instance.", "Create new {@link Builder} based on an existing {@link CoreEvent} instance.", "Create new {@link Builder} based on an existing {@link CoreEvent} instance.", "Create new {@link Builder} based on an existing {@link CoreEvent} instance."]}
{"SampleId": 2337369, "Origin": "User / Group may update meta data of nodes: rename files and folders, change classification, etc.", "Reference": "User / Group may update metadata of nodes: rename files and folders, change classification, etc.", "LLMCandidates": ["User / Group may update metadata of nodes: rename files and folders, change classification, etc.", "User / Group may update metadata of nodes: rename files and folders, change classification, etc.", "User / Group may update metadata of nodes: rename files and folders, change classification, etc.", "User / Group may update metadata of nodes: rename files and folders, change classification, etc.", "User / Group may update metadata of nodes: rename files and folders, change classification, etc."]}
{"SampleId": 4396481, "Origin": "Returns a string representation of this object; useful for testing and debugging.", "Reference": "Returns a string representation of this object.", "LLMCandidates": ["Returns a string representation of this object; useful for testing and debugging. If sensitive data is present, it will be redacted with \"***Sensitive Data Redacted***\" instead.", "Returns a string representation of this object; useful for testing and debugging with sensitive data redacted.", "Returns a string representation of this object with sensitive data redacted; useful for testing and debugging.", "Returns a string representation of this object; useful for testing and debugging, with sensitive data redacted.", "Returns a string representation of this object; useful for testing and debugging, with sensitive data redacted."]}
{"SampleId": 1118960, "Origin": "See {@link SyslogConstants} and RFC 3164 for more information about the", "Reference": "See RFC 3164 for more information about the", "LLMCandidates": ["Sets the facility string by processing the given facility name using {@link SyslogConstants} and RFC 3164 rules.", "Set the syslog facility by passing a non-null string value from {@link SyslogConstants} and adhering to RFC 3164 for more information.", "Sets a new facility for syslog processing based on the given String parameter. This method converts the input to an integer value representing a syslog facility, and if it's unknown, defaults to LOG_USER. Then, it stores the facilityStr as the facility name obtained from the converted integer value.", "Set the syslog facility by passing a String representing the desired value and get the corresponding syslog constant or default to USER if it's not a known facility. See {@link SyslogConstants} and RFC 3164 for more information about the facilities.", "Set the facility using final String value. If it's not null, set syslogFacility with the corresponding value and default to LOG_USER if unknown. Convert the syslogFacility to a string and assign it to the facilityStr variable."]}
{"SampleId": 4388500, "Origin": "Once you've created\na DB parameter group, you need to associate it with your DB instance\nusing ModifyDBInstance .", "Reference": "Once you've created a DB parameter group,\nyou need to associate it with your DB instance using", "LLMCandidates": ["Create a DB parameter group using this method, then associate it with your DB instance using ModifyDBInstance.", "Once you've created a DB parameter group, you need to associate it with your DB instance using ModifyDBInstance.", "Once you've created a DB parameter group, you need to associate it with your DB instance using ModifyDBInstance.", "This method creates a DBParameterGroup object using the CreateDBParameterGroupRequest request.", "Once you've created a DB parameter group, you need to associate it with your DB instance using ModifyDBInstance ."]}
{"SampleId": 2231080, "Origin": "Returns the list of configured WAN publisher targets for this WAN\nreplication.", "Reference": "Returns the list of custom WAN publisher implementations for this WAN\nreplication.", "LLMCandidates": ["Returns a list of custom WAN publisher configurations for this WAN replication.", "Returns the list of configured custom WAN publisher targets for this WAN replication.", "Returns the list of configured custom WAN publisher targets for this WAN replication.", "Returns the list of configured custom WAN publisher targets for this WAN replication.", "Returns the list of configured custom WAN publisher targets for this WAN replication."]}
{"SampleId": 3143529, "Origin": "RemoveAxiom change objects are automatically generated.", "Reference": "The appropriate RemoveAxiom change objects are automatically\ngenerated.", "LLMCandidates": ["The removeAxiom change objects are automatically generated based on the input axioms and the target OWLOntology.", "Removes the specified axioms from the OWLOntology and returns a ChangeReport object.", "Removes axioms from the given OWLOntology object using a stream of axioms provided. This method automatically generates ChangeReport objects for each removed axiom.", "RemoveAxioms change objects are automatically generated using a stream of OWLAxiom instances.", "RemoveAxiom change objects are automatically generated when removing a collection of OWLAxioms from an OWLOntology."]}
{"SampleId": 2973497, "Origin": "Return a signature object containing the current signature state.", "Reference": "Return the signature.", "LLMCandidates": ["Return a signature object containing the current signature state for supported algorithms; throw UnsupportedOperationException if an unsupported algorithm is encountered.", "Return a signature byte array containing the current signature state for the specified algorithm. If an unsupported algorithm is encountered, throw an UnsupportedOperationException.", "Return a signature object containing the current signature state according to the supported key algorithms. For unsupported algorithms, an exception is thrown.", "Return a signature object containing the current signature state based on the key algorithm used.", "Return a signature object containing the current signature state for supported algorithms."]}
{"SampleId": 4471749, "Origin": "If {@code labels = \"*abc*\"}, settings with a label containing \"abc\" are returned.", "Reference": "If {@code labelFilter = \"*abc*\"}, settings with a label containing \"abc\" are returned.", "LLMCandidates": ["If {@code labelFilter = \"*abc*\"}, settings with a label containing \"abc\" are returned.", "If {@code labelFilter = \"abc\"}, settings with a label containing \"abc\" are returned.", "If {@code labelFilter = \"abc\"}, settings with a label containing \"abc\" are returned.", "If {@code labelFilter = \"abc\"}, settings with a label containing \"abc\" are returned.", "If {@code labelFilter = \"abc\"}, settings with a label containing \"abc\" are returned."]}
{"SampleId": 5724604, "Origin": "Adds a new URI to the list of redirects.", "Reference": "Adds a new URI to the collection.", "LLMCandidates": ["Adds a new URI to both the unique list of redirects and the all list of redirects.", "Adds a new URI to the list of unique and all redirects.", "Adds a new URI to the list of unique redirects and all redirects.", "Adds a new URI to the list of unique redirects and all redirects.", "Adds a new URI to the list of unique redirects, and adds it to the all list."]}
{"SampleId": 2312746, "Origin": "Returns the (biased) estimate of the sample standard deviation of the\nvalues within a {@link PointSet} region of a {@link Dataset}.", "Reference": "Returns the (unbiased) kurtosis excess of all the values within a\n{@link PointSet} region of a {@link Dataset}", "LLMCandidates": ["Returns the estimate of the sample kurtosis excess of the values within a PointSet region of a Dataset.", "Returns the (biased) estimate of the sample kurtosis excess of the values within a {@link PointSet} region of a {@link Dataset}.", "Returns the (biased) estimate of the sample kurtosis excess of the values within a {@link PointSet} region of a {@link Dataset}.", "Returns the (biased) estimate of the sample kurtosis excess of the values within a {@link PointSet} region of a {@link Dataset}.", "Returns the (biased) estimate of the sample kurtosis excess of the values within a {@link PointSet} region of a {@link Dataset}."]}
{"SampleId": 2842886, "Origin": "ArchaiusModule however is stateful in that much of its configuration\nis supplied externally to the Guice injector.", "Reference": "ArchaiusModule however is stateful in\nthat it is initially set up outside of Guice.", "LLMCandidates": ["This is a comment for the ArchaiusModule which indicates that it is stateful in that much of its configuration is supplied externally to the Guice injector. This method checks for equality based on object references.", "ArchaiusModule may be installed only once due to its stateful nature where much of its configuration is supplied externally to the Guice injector.", "ArchaiusModule may be stateful, with much of its configuration supplied externally to the Guice injector.", "ArchaiusModule however is stateful in that much of its configuration is supplied externally to the Guice injector, and this method checks for equality by comparing object references.", "The ArchaiusModule class is a stateful configuration manager that has much of its configuration supplied externally to the Guice injector."]}
{"SampleId": 3511327, "Origin": "The {@link EventContextKeys#MESSAGE_TARGET}, if any", "Reference": "The {@link EventContextKeys#MESSAGE_CHANNEL}, if any", "LLMCandidates": ["The {@link EventContextKeys#MESSAGE_CHANNEL}, if any", "Get the {@link EventContextKeys#MESSAGE_CHANNEL}, if any", "The {@link EventContextKeys#MESSAGE_CHANNEL}, if any", "The {@link EventContextKeys#MESSAGE_CHANNEL}, if any", "The {@link EventContextKeys#MESSAGE_CHANNEL}, if any"]}
{"SampleId": 3349712, "Origin": "Create a new empty {@link Sequential} with atomic guarantees on all mutative\noperations.", "Reference": "Create a new empty {@link Swap} with atomic guarantees on all mutative\noperations.", "LLMCandidates": ["Create a new empty {@link Swap} with atomic guarantees on all mutative operations.", "Create a new empty {@link Swap} with atomic guarantees on all mutative operations.", "Create a new empty {@link Swap} with atomic guarantees on all mutative operations.", "Create a new empty {@link Swap} with atomic guarantees on all mutative operations.", "Create a new empty {@link Swap} with atomic guarantees on all mutative operations."]}
{"SampleId": 2535867, "Origin": "Extract the values from the array's elements by applying an extracting function on them.", "Reference": "Extract the values from the array's elements by applying an extracting function on them, the resulting list becomes\nthe new object under test.", "LLMCandidates": ["Extract the values from the array's elements by applying an extracting function on them and return a new list assert instance containing these values.", "Extract the values from the array's elements by applying an extracting function on them.", "Extract the values from the array's elements by applying an extracting function on them.", "Extract the values from the array's elements by applying an extracting function on them using a new list assert instance.", "Extract the values from the array's elements by applying an extracting function on them."]}
{"SampleId": 4117678, "Origin": "Sets the {@code Cipher} to use for encrypting and decrypting serialized identity data to prevent easy\ninspection of Subject identity data.", "Reference": "Sets the {@code CipherService} to use for encrypting and decrypting serialized identity data to prevent easy\ninspection of Subject identity data.", "LLMCandidates": ["Sets the {@code CipherService} to use for encrypting and decrypting serialized identity data to prevent easy inspection of Subject identity data.", "Sets the {@code CipherService} to use for encrypting and decrypting serialized identity data to prevent easy inspection of Subject identity data.", "Sets the {@code CipherService} to use for encrypting and decrypting serialized identity data to prevent easy inspection of Subject identity data.", "Sets the {@code CipherService} to use for encrypting and decrypting serialized identity data to prevent easy inspection of Subject identity data.", "Sets the {@code CipherService} to use for encrypting and decrypting serialized identity data to prevent easy inspection of Subject identity data."]}
{"SampleId": 4829574, "Origin": "This method allows you to specify IterationListeners for this model.", "Reference": "This method allows you to specify trainingListeners for this model.", "LLMCandidates": ["This method allows you to specify TrainingListeners for this model.", "This method allows you to specify TrainingListeners for this model.", "This method allows you to specify TrainingListeners for this model.", "This method allows you to specify TrainingListeners for this model.", "This method allows you to specify TrainingListeners for this model."]}
{"SampleId": 2049560, "Origin": "Sets data to be parsed by libflac.", "Reference": "Sets the data to be parsed.", "LLMCandidates": ["Sets data for parsing by libflac, discarding previous input and temporary buffer.", "Sets data to be parsed by libflac. After setting the ByteBuffer, the extractorInput is cleared.", "Sets data to be parsed by libflac. After setting the ByteBuffer, the extractorInput is cleared.", "Sets data to be parsed by libflac. Removed: \"this.tempBuffer = null;", "Sets data to be parsed by libflac after removing the line about clearing extractorInput and tempBuffer."]}
{"SampleId": 3677760, "Origin": "Returns the next day-of-week adjuster, which adjusts the date to be\nthe next of the specified day-of-week after the specified date.", "Reference": "Returns the next day-of-week adjuster, which adjusts the date to the\nfirst occurrence of the specified day-of-week after the date being adjusted.", "LLMCandidates": ["Returns the next day-of-week adjuster, which adjusts the date to be the next of the specified day-of-week after the specified date.", "Returns a next day-of-week adjuster that adjusts the date to be the next of the specified day-of-week after the specified date.", "Returns a day-of-week adjuster that advances to the next of the specified day-of-week following the given one.", "Returns the next day-of-week adjuster, which adjusts the date to be the next of the specified day-of-week after the specified date.", "The next day-of-week adjuster, which adjusts the date to be the next of the specified day-of-week after the specified date is returned."]}
{"SampleId": 4476347, "Origin": "{@codesnippet com.azure.data.appconfiguration.configurationasyncclient.addSettingWithResponse#ConfigurationSetting}", "Reference": "{@codesnippet com.azure.data.appconfiguration.configurationasyncclient.addConfigurationSettingWithResponse#ConfigurationSetting}", "LLMCandidates": ["@codesnippet com.azure.data.appconfiguration.configurationasyncclient.addConfigurationSettingWithResponse#ConfigurationSetting", "@codesnippet com.azure.data.appconfiguration.configurationasyncclient.addConfigurationSettingWithResponse#ConfigurationSetting", "@codesnippet com.azure.data.appconfiguration.configurationasyncclient.addConfigurationSettingWithResponse#ConfigurationSetting", "Add a configuration setting with response.", "Add a configuration setting with response."]}
{"SampleId": 2706903, "Origin": "Set Account Element.", "Reference": "Set Kontenart.", "LLMCandidates": ["Set the value of C_ElementValue_ID for the given object.", "Overrides the setC_ElementValue_ID method to assign a new value to the C_ElementValue_ID column in the underlying table.", "Set the C_ElementValue ID.", "Set the C_ElementValue ID.", "Set the value of the C_ElementValue_ID column based on the input integer value."]}
{"SampleId": 5458940, "Origin": "Computes the hash of this module, returning it as a hex string.", "Reference": "Computes the hash of this module.", "LLMCandidates": ["Computes the hash of this module, returning it as a byte array.", "Computes the hash of this module, returning it as a byte array.", "Computes the hash of this module, returning it as a byte array.", "Computes the hash of this module, returning it as a byte array.", "Computes the hash of this module, returning it as a byte array."]}
{"SampleId": 3506207, "Origin": "The\n{@code orderType} is an enum value located under the {@link #ORDER_TYPE}\nkey.", "Reference": "The\n{@code orderType} is an enum value located under the {@link HasOrderTypeUtil#ORDER_TYPE}\nkey.", "LLMCandidates": ["The orderType is an enum value located under the {@link #HasOrderTypeUtil.ORDER_TYPE} key.", "The orderType is an enum value located under the {@link #HASORDERTYPEUTIL_ORDER_TYPE} key.", "The orderType is an enum value located under the {@link #HASORDERTYPEUTIL_ORDER_TYPE} key.", "The orderType is an enum value located under the HasOrderTypeUtil.ORDER_TYPE", "The orderType is an enum value located under the {@link #HasOrderTypeUtil.ORDER_TYPE} key."]}
{"SampleId": 105839, "Origin": "Read an optional Long value (stored as string) form a JSON Object.", "Reference": "Read an optional Date value (stored as string) form a JSON Object.", "LLMCandidates": ["Read an optional Date value (stored as string) from a JSON Object.", "Read an optional Date value (stored as string) form a JSON Object.", "Read an optional Date value (stored as string) from a JSON Object.", "Read an optional Date value (stored as string) form a JSON Object.", "Read an optional Date value (stored as string) form a JSON Object."]}
{"SampleId": 3241612, "Origin": "Gets the parent object in the object tree representing the unmarshalled xml document.", "Reference": "Gets the value of the anchorId property.", "LLMCandidates": ["Gets the anchor ID representing the unmarshalled XML document's location.", "Gets the anchor ID of the object in the object tree representing the unmarshalled xml document.", "Gets the anchor ID representing the unmarshalled xml document.", "Gets the anchor ID representing the unmarshalled xml document.", "Gets the anchor ID representing the element in the object tree of the unmarshalled XML document."]}
{"SampleId": 1352302, "Origin": "If modified and not discarded, sheet material will be stored before being disposed of.", "Reference": "If modified or upgraded, sheet material will be stored before being disposed of.", "LLMCandidates": ["If modified or upgraded, sheet material will be stored before being disposed of.", "If modified or upgraded and not discarded, sheet material will be stored before being disposed of.", "If modified or upgraded, sheet material will be stored before being disposed of.", "If modified or upgraded, sheet material will be stored before being disposed of.", "If modified or upgraded, sheet material will be stored before being disposed of."]}
{"SampleId": 5454975, "Origin": "Get the value of the {@code accessible} flag for this object.", "Reference": "Get the value of the {@code accessible} flag for this reflected object.", "LLMCandidates": ["Get the value of the {@code accessible} flag for this object. This method is deprecated since version 9.", "Get the value of the {@code accessible} flag for this object; however, note that this method is deprecated since version 9.", "Get the value of the {@code accessible} flag for this object, marked as deprecated since 9.", "Get the value of the {@code accessible} flag for this object, marked as deprecated since 9.", "Check if the override flag is set for this object's accessibility."]}
{"SampleId": 2248673, "Origin": "Get icon img and append to buf", "Reference": "Get 16x16 icon img and append to buf", "LLMCandidates": ["Generate an image tag using the specified name and append it to the buffer. If the binary key is present for the name, use that icon; otherwise, check for a predefined icon associated with the name.", "Appends an image element with the src attribute pointing to the client app icon path, and alt attribute set according to the name or default image, to the StringBuilder buf.", "Get icon img with given name and iconpath, and append to buf", "Get icon img with given name and iconpath, and append to buf", "Generates a client application image tag and appends it to buf based on the name provided"]}
{"SampleId": 1879787, "Origin": "Testing the timesTranspose(vector, vector) method of VMath class.", "Reference": "Testing the timesTranspose(vector, vector) method of {@link VMath} class.", "LLMCandidates": ["Testing the timesTranspose(vector, vector) method of VMath class by performing matrix multiplication and validating the result against the expected output. This test also serves as a validation for the transpose function if the timesTranspose method is correct.", "Testing the timesTranspose(vector, vector) method of VMath class and verifying the equivalence of transpose operation through a matrix multiplication.", "Testing the timesTranspose(vector, vector) method of VMath class and checking if it returns the correct result using the times(matrix, matrix) method.", "Testing the timesTranspose(vector, vector) method of VMath class.", "Testing the timesTranspose(vector, vector) method of VMath class. This test verifies that the transpose operation works correctly on vectors and can be applied to other operations, such as matrix multiplication. Additionally, it confirms that the output is equivalent to the expected result for both basic and more complex input sets."]}
{"SampleId": 4396558, "Origin": "Returns a string representation of this object; useful for testing and debugging.", "Reference": "Returns a string representation of this object.", "LLMCandidates": ["Returns a string representation of this object; useful for testing and debugging with sensitive data redacted.", "Returns a string representation of this object; useful for testing and debugging with sensitive data redacted.", "Returns a string representation of this object; useful for testing and debugging, sensitive data is redacted.", "Returns a string representation of this object; useful for testing and debugging, sensitive data is redacted.", "Returns a string representation of this object; useful for testing and debugging, while redacting sensitive data when necessary."]}
{"SampleId": 3734015, "Origin": "Otherwise, this qualifier must contain all the arrays in superType.", "Reference": "Otherwise, this qualifier must contain all the sequences in superType.", "LLMCandidates": ["Otherwise, this qualifier must contain all the sequences in superType.", "Otherwise, this qualifier must contain all the arrays in superType using the same keys from the map.", "This method checks whether this qualifier is a subtype of the provided superType UBQualifier. It does so by ensuring that this qualifier contains all the arrays in superType and checking if the offset equations for each array are also in subtype.", "Otherwise, this qualifier must contain all the sequences in superType.", "Otherwise, this qualifier must contain all the sequences in superType."]}
{"SampleId": 2735158, "Origin": "Returns bounds of the split button part.", "Reference": "Returns bounds of the menu button part.", "LLMCandidates": ["Returns bounds of the menu button part.", "Returns bounds of the menu button part.", "Returns bounds of the menu button part.", "Returns bounds of the menu button part.", "Returns bounds of the menu button part."]}
{"SampleId": 1309912, "Origin": "Asynchronously gets a service.", "Reference": "Asynchronously gets a api.", "LLMCandidates": ["Asynchronously gets an API.", "Asynchronously gets an API.", "Asynchronously gets an API.", "Asynchronously gets an API.", "Asynchronously gets an API."]}
{"SampleId": 2137945, "Origin": "Returns true if the constructor method is locally empty (allows calls to empty init and super\nconstructor).", "Reference": "Returns true if the constructor method is locally empty (allows calls to init and super\nconstructor).", "LLMCandidates": ["Determines if the constructor body contains any statements other than implicit super calls and initialization calls.", "Returns true if the constructor method is empty of any other operations besides super and init calls.", "Determines if the constructor method is empty, excluding implicit super calls and initialization statements.", "Determines if the constructor method contains no statements apart from implicit super calls and empty initializations.", "Checks whether a constructor method has no body statements, allowing calls to an empty initialization and super constructor."]}
{"SampleId": 6018465, "Origin": "Sets each pixel in the output image to log( 1 + input(x,y)) of the input image.", "Reference": "Sets each pixel in the output image to log( val + input(x,y)) of the input image.", "LLMCandidates": ["Sets each pixel in the output image to log(1 + input(x,y)) of the input image with an additional value 'val'.", "Sets each pixel in the output image to log(1 + input(x, y)) of the input image for a single scalar value.", "Sets each pixel in the output image to log(1 + input(x,y)) of the input image, with an additional double value val applied to the pixels.", "Sets each pixel in the output image to log(1 + input(x, y)) of the input image with an additional double val parameter that is applied to the log function.", "Sets each pixel in the output image to log(1 + input(x,y)) of the input image with an additional val parameter for scaling."]}
{"SampleId": 1401991, "Origin": "Creates a schemaless instance of a provider with the given values for fields f1 and f2.", "Reference": "Creates an instance of a provider with the given values for fields f1 and f2.", "LLMCandidates": ["Creates a schemaless instance of a provider with the given values for fields f1 and f2, without considering their types or format.", "Creates a schemaless instance of a provider with the given values for fields f1 and f2.", "Creates an instance of a provider with the given values for fields f1 and f2.", "Creates a schemaless instance of a provider with the given values for fields f1 and f2.", "Creates a schemaless instance of a provider with the given values for fields f1 and f2."]}
{"SampleId": 4866566, "Origin": "Add two URI path segments.", "Reference": "Add two Decoded URI path segments.", "LLMCandidates": ["Add two URI path segments considering their endings with '/' character.", "Combine two URI paths by considering the endings of each path segment.", "Add two URI path segments by considering the ending slashes of both segments and appending them accordingly to maintain proper structure.", "Combine two URI paths, considering possible trailing slashes.", "Combine two URI paths, considering possible trailing slashes."]}
{"SampleId": 1052994, "Origin": "In alarm, only minute dimensionality\nindicators are expected to process.", "Reference": "In alarm, only minute dimensionality\nmetrics are expected to process.", "LLMCandidates": ["In alarm, only minute dimensionality metrics are expected to process.", "In alarm, only minute dimensionality metrics are expected to process.", "In alarm, only minute dimensionality metrics are expected to process.", "In alarm, only minute dimensionality metrics are expected to process.", "In alarm, only minute dimensionality metrics are expected to process."]}
{"SampleId": 1402632, "Origin": "If {@code thread} is null, the list\nis immutable.", "Reference": "Equivalent to {@code copyOf(null, elems)}.", "LLMCandidates": ["If {@code thread} is null, the list is immutable.", "If {@code thread} is null or omitted, the list is immutable and returned directly without modification.", "If {@code thread} is null, the list is immutable.", "If thread is not provided, the list is immutable.", "If thread is not provided, the list is immutable."]}
{"SampleId": 5652502, "Origin": "Creates callable for executing {@link Entry#doubleWhoAmI(String, String, ReAuthnType, String)} as given user.", "Reference": "Creates a callable for executing {@link Entry#doubleWhoAmI(String, String, ReAuthnType, String)} as given user.", "LLMCandidates": ["Creates callable for executing {@link Entry#doubleWhoAmI(String, String, ReAuthnType, String)} as given user with null server2Url.", "Creates callable for executing {@link Entry#doubleWhoAmI(String, String, ReAuthnType, String)} as given user with optional server2Url and stateful flag.", "Creates callable for executing {@link Entry#doubleWhoAmI(String, String, ReAuthnType, String)} with null server2Url as given user.", "Creates callable for executing {@link Entry#doubleWhoAmI(String, String, ReAuthnType, String)} as given user with a null server2Url.", "Creates callable for executing {@link Entry#doubleWhoAmI(String, String, ReAuthnType, String)} as given user with the optional additional parameter."]}
{"SampleId": 3105766, "Origin": "Validate that I have a Exuberant ctags program I may use", "Reference": "Validate that there is a Universal ctags program.", "LLMCandidates": ["Validate that I have a Universal ctags program I may use", "Validate that I have a Universal ctags program I may use", "Validate that I have a Universal ctags program I may use", "Validate that I have a Universal ctags program I may use", "Validate that I have a Universal ctags program I may use"]}
{"SampleId": 236993, "Origin": "Tests for the {@link BaseFileSystem#getStatus(AlluxioURI, GetStatusOptions)} method.", "Reference": "Tests for the {@link BaseFileSystem#getStatus(AlluxioURI, GetStatusPOptions)} method.", "LLMCandidates": ["Tests for the {@link BaseFileSystem#getStatus(AlluxioURI, GetStatusPOptions)} method.", "Tests for the {@link BaseFileSystem#getStatus(AlluxioURI, GetStatusPOptions)} method.", "Tests for the {@link BaseFileSystem#getStatus(AlluxioURI, GetStatusPOptions)} method.", "Tests for the {@link BaseFileSystem#getStatus(AlluxioURI, GetStatusPOptions)} method.", "Tests for the {@link BaseFileSystem#getStatus(AlluxioURI, GetStatusPOptions)} method."]}
{"SampleId": 2336970, "Origin": "### Effects: Provided user receives email with reset token.", "Reference": "### Effects: Provided user receives email with password reset token.", "LLMCandidates": ["The provided user receives an email with a reset token after calling this method.", "Provided user receives email with reset token.", "Provided user receives email with reset token.", "Provided user receives email with reset token.", "Provided user receives email with reset token."]}
{"SampleId": 5082490, "Origin": "Performs thread dump and prints all available info to the given log.", "Reference": "Performs thread dump and prints all available info to the given log with WARN logging level.", "LLMCandidates": ["Performs thread dump and prints all available info to the given log. If deadlocked threads are detected, it will warn the user about their presence and the total number of such threads. The method is now overloaded with an additional boolean parameter that determines whether or not to print a warning in case of no deadlocks being detected.", "Performs thread dump with a given log level. If no deadlocked threads are detected, prints a message to the log. Otherwise, prints information about all threads and their lock details.", "Performs thread dump with optional deadlock detection and prints all available info to the given log.", "Performs thread dump and prints all available info to the given log. If deadlocked threads are detected, a warning is issued along with the thread dump. The method also supports setting a parameter to indicate whether the thread dumps should be printed or not.", "Performs thread dump with optional lock tracing for deadlocked threads and prints all available info to the given log."]}
{"SampleId": 1721041, "Origin": "If the columnIdent doesn't have a path the return value is null", "Reference": "If the columnName doesn't have a path the return value is null", "LLMCandidates": ["If the columnIdent's path is empty or has only one element, return null; otherwise, create a new ColumnIdent object with the first element of the path and the remaining elements in the sublist.", "If the columnIdent doesn't have a path the return value is null. Otherwise, if there's only one element in the path it returns that single element, otherwise it returns a new ColumnIdent with the first element of the path and all elements after the first element in the list.", "If the columnIdent's path is empty, the return value is null. The updated code uses a switch statement to return the appropriate ColumnIdent based on the size of the path.", "The updated comment for shiftRight() is: \"If the columnIdent doesn't have a path, the return value is null.", "If there is no column ident path available, return null. If there's only one element in the path, return a new ColumnIdent with that single element. Otherwise, return a new ColumnIdent with the first element and sublist of the remaining elements in the path."]}
{"SampleId": 1612088, "Origin": "Checks if the given {@code DetailAST} node is matching line and column number.", "Reference": "Checks if the given {@code DetailAST} node is matching line number, column number and token\ntype.", "LLMCandidates": ["Checks if the given {@code DetailAST} node is matching line and column number with a specified token type.", "Checks if the given {@code DetailAST} node is matching line and column number and token type.", "Checks if the given {@code DetailAST} node is matching line and column number and has the specified token type.", "Checks if the given {@code DetailAST} node is matching line and column number and has a specific token type.", "Checks if the given {@code DetailAST} node is matching line and column number, and if the token type is either 0 or matches the specified token type."]}
{"SampleId": 1575389, "Origin": "Persists running state to the {@link RemoteRuntimeDataset}.", "Reference": "Persists running state to the {@link RemoteRuntimeTable}.", "LLMCandidates": ["Persists running state to the {@link RemoteRuntimeTable}.", "Persists running state to the {@link RemoteRuntimeTable}.", "Persists running state to the {@link RemoteRuntimeTable}.", "Persists running state to the {@link RemoteRuntimeTable}.", "Persists running state to the {@link RemoteRuntimeTable}."]}
{"SampleId": 5631500, "Origin": "An array of objects defining the nodes in the dialog.", "Reference": "An array of objects describing the dialog nodes in the workspace.", "LLMCandidates": ["An array of objects defining the nodes in the dialog.", "An array of objects defining the nodes in the dialog.", "An array of objects defining the nodes in the dialog.", "An array of objects defining the nodes in the dialog.", "An array of objects defining the nodes in the dialog."]}
{"SampleId": 471868, "Origin": "The amount of time (in millisecond) which adds to waiting time when\nusing Linear back off strategy.", "Reference": "Maximum amount of time (in millisecond) a thread wait before retrying\nfailed request.", "LLMCandidates": ["The amount of time (in millisecond) which sets the maximum waiting time for retry when using Linear back off strategy.", "The amount of time (in millisecond) which sets the maximum waiting time when using Linear back off strategy.", "The amount of time (in millisecond) which sets the maximum waiting time when using Linear back off strategy.", "The amount of time (in millisecond) which adds to waiting time when using Linear back off strategy.", "The amount of time (in millisecond) which adds to waiting time when using Exponential back off strategy."]}
{"SampleId": 5323489, "Origin": "Specify charsets associated with the configured {@link #setLocations(List)\nlocations}.", "Reference": "An alternative to {@link #setLocations(List)} that accepts a list of", "LLMCandidates": ["Specify values associated with the configured {@link #setLocations(List) locations}.", "Set values associated with the configured {@link #setLocations(List) locations}.", "Set charsets associated with the configured {@link #setLocations(List) locations}.", "Set charsets associated with the configured {@link #setLocations(List) locations}.", "Set the charsets associated with the configured {@link #setLocations(List) locations}."]}
{"SampleId": 5244566, "Origin": "Builds maps of obj id to\nmd5 and case.", "Reference": "Builds maps of obj id to\nvalue and case.", "LLMCandidates": ["Finds single inter-case values by count for a given case and filters on specific mime types. Returns a map of obj id to CommonAttributeValueList for the target case.", "Finds maps of obj id to md5 and case.", "Finds single inter-case values by count for a given Case and correlation type. It retrieves instances of CommonAttributeValueList based on the input parameters: Case, mimeTypesToFilterOn, and CorrelationCase. The method returns the results after executing the necessary database queries, handling exceptions if any occurs.", "Finds common files between two cases based on their count by processing the EamDb CaseInstancesTable and returning a map of obj id to CommonAttributeValueList.", "Finds single inter-case values by count for a given case and correlation type, filtering on specific mime types. If the correlationType is FILES_TYPE_ID, it processes the file query with the provided mimeTypesToFilterOn. Otherwise, it processes the instance table where clause with the given case id and file known value. Finally, it returns a map of obj ids to common attribute values found in the inter-case values by count."]}
{"SampleId": 2081192, "Origin": "Moves on to next top level domain in {@code topLevelDomainsList}.", "Reference": "Moves on to next top level domain in {@code tldCycleIterator}.", "LLMCandidates": ["Moves on to next top level domain in {@code tldCycleIterator}.", "Moves on to next top level domain in {@code tldCycleIterator}.", "Moves on to next top level domain in {@code tldCycleIterator}.", "Moves on to next top level domain in {@code tldCycleIterator}.", "Moves on to next top level domain in {@code tldCycleIterator}."]}
{"SampleId": 5316049, "Origin": "Add the given {@link HandlerMethodArgumentResolver}s.", "Reference": "Add the given {@link HandlerMethodArgumentResolver HandlerMethodArgumentResolvers}.", "LLMCandidates": ["Add the given {@link HandlerMethodArgumentResolver}s by adding all of them to the argumentResolvers list.", "Adds the given {@link HandlerMethodArgumentResolver}s to the list of resolvers.", "Add the given HandlerMethodArgumentResolver objects to the existing list of resolvers.", "Add the given HandlerMethodArgumentResolver argument resolvers to the internal list.", "Add the given {@link HandlerMethodArgumentResolver}s by using addAll() instead of a loop."]}
{"SampleId": 80067, "Origin": "Gets the Chemical Dissolution Chamber of the ItemStackInput in the parameters", "Reference": "Gets the Chemical Dissolution Chamber of the ItemStack in the parameters", "LLMCandidates": ["Gets the Chemical Dissolution Chamber recipe for the ItemStack input in the parameters", "Gets the Chemical Dissolution Chamber for the ItemStack in the parameters", "Gets the Chemical Dissolution Chamber for the ItemStack in the parameters", "Gets the ItemStack2GasRecipe for the given ItemStack input by checking if it matches any recipe in the Chemical Dissolution Chamber.", "Returns an ItemStack2GasRecipe for the given Input if it is valid for the Chemical Dissolution Chamber, otherwise returns null."]}
{"SampleId": 1346635, "Origin": "Runs operations for a single client.", "Reference": "Runs operations for a single session.", "LLMCandidates": ["Runs operations for a single session using the CopycatSession interface.", "Runs operations for a single session using CopycatSession.", "Runs operations for a single session using CopycatSession.", "Runs operations for a single session.", "Runs operations for a single session."]}
{"SampleId": 2318037, "Origin": "inverse of {@link #jacksonBson(String)}", "Reference": "inverse of {@link #jacksonThenBson(String)}", "LLMCandidates": ["This method takes a JSON string, encodes it into BSON format using a BsonWriter, reads it back using Jackson's BsonParser, and checks if the result is equal to the expected value. It serves as an inverse function to {@link #jacksonBson(String)}.", "Encodes a JSON object with BSON and then reads it back using Jackson. This method is the inverse of {@link #jacksonBson(String)}.", "Converts JSON string to BSON using Jackson library, then reads BSON with a BSON parser and checks if it's equal to the original BSON document.", "inverse of {@link #jacksonBson(String)", "inverse of {@link #jacksonBson(String)"]}
{"SampleId": 5720694, "Origin": "are specifically excluded\nexcept for carriage return, linefeed, and the horizontal tab.", "Reference": "are specifically excluded\nexcept for carriage return, line-feed, and the horizontal tab.", "LLMCandidates": ["Check if text contains any characters that are not legal XML values. If a high surrogate character is found and followed by the expected low surrogate character, decode it into its true value before checking if it is an XML character. Return the appropriate error message if an illegal character or pair is detected. Otherwise, return null to indicate no issues with the input text.", "The method checks if a character is legal according to XML rules. The specific characters that are excluded, except for carriage return, linefeed, and the horizontal tab, are controlled characters or control codes, which will be displayed with their hexadecimal representation in the returned reason if found.", "The string representation of a character is only considered legal if it falls within certain defined parameters. Characters that are not valid are indicated by their hexadecimal value in the returned message.", "This method checks if a given string text is valid according to XML character validation rules. If the text contains any non-XML characters or surrogate pairs that are not legal in XML, it returns an appropriate error message describing the invalid characters or pairs. The returned value is null if everything is OK.", "Checks if all characters in a string are legal XML characters, excluding carriage return, linefeed, and horizontal tab. Handles surrogate pairs and encodes illegal characters into their hexadecimal representation."]}
{"SampleId": 5459533, "Origin": "Computes the hash of this module, returning it as a hex string.", "Reference": "Computes the hash of this module.", "LLMCandidates": ["Computes the hash of this module, returning it as a byte array.", "Computes the hash of this module, returning it as a byte array.", "Computes the hash of this module, returning it as a byte array.", "Computes the hash of this module, returning it as a byte array.", "Computes the hash of this module, returning it as a byte array."]}
{"SampleId": 6330488, "Origin": "Calls the specified converter function with the current Single instance\nduring assembly time and returns its result.", "Reference": "Calls the specified converter function during assembly time and returns its resulting value.", "LLMCandidates": ["Calls the specified converter function with the current Single instance during assembly time and returns its result.", "Calls the specified converter function with the current Single instance during assembly time and returns its result.", "Converts the current Single instance using the specified converter function and returns its result.", "Calls the specified converter function with the current Single instance during assembly time and returns its result.", "Calls the specified converter function with the current Single instance during assembly time and returns its result."]}
{"SampleId": 6047536, "Origin": "or throws a {@link com.liferay.knowledgebase.NoSuchArticleException} if it could not be found.", "Reference": "or throws a {@link NoSuchArticleException} if it could not be found.", "LLMCandidates": ["Finds an KBArticle by its resourcePrimKey and version. Throws a {@link com.liferay.knowledgebase.NoSuchArticleException} if it could not be found.", "Finds an article by its resource primary key and version. If it could not be found, throws a {@link com.liferay.knowledgebase.NoSuchArticleException}.", "Finds an article by its resource primary key and version. If not found, throws a {@link com.liferay.knowledgebase.NoSuchArticleException}.", "Finds the KBArticle with the given resource prim key and version, throwing a {@link com.liferay.knowledgebase.NoSuchArticleException} if it could not be found.", "Finds a KBArticle by R_V, throws a {@link com.liferay.knowledgebase.NoSuchArticleException} if not found."]}
{"SampleId": 2250226, "Origin": "Comments in the same 10-minute bucket and otherwise equal\n are considered equal.", "Reference": "Comments within 10 minutes (not necessarily in same bucket)\n and otherwise equal are considered equal.", "LLMCandidates": ["Comments are considered equal if they have the same text, rating, and name and are within a 10-minute bucket time difference of each other.", "Comments are considered equal if they have the same content and belong to the same 10-minute bucket.", "Comments are considered equal if they have the same content and belong to the same 10-minute bucket.", "Comments with the same time within a 10-minute window and otherwise equal are considered equal.", "Comments in the same 10-minute bucket and otherwise equal are considered equal."]}
{"SampleId": 1721041, "Origin": "creates a new columnIdent which just consists of the path of the given columnIdent\ne.g.", "Reference": "creates a new columnName which just consists of the path of the given columnName\ne.g.", "LLMCandidates": ["Shifts right by one level, creating a new ColumnIdent based on the given path. If the path is empty, returns null. If the path has 1 element, returns a ColumnIdent with that single element. Otherwise, if there are more than 2 elements, return a ColumnIdent with the first element and the rest of the elements after the first level.", "Creates a new columnIdent which is derived from the given path of the columnIdent. The new columnIdent is constructed based on the size of the original path. If there are no elements in the path, the result is null. If there's only one element in the path, it becomes the single element of the new columnIdent. Otherwise, if there are more than two elements, a new columnIdent is formed by retaining the first element and the rest of the elements from the second onwards.", "Shifts the given columnIdent one step to the right by either removing the first element of the path or retaining only the first element and creating a new columnIdent with the rest of the path. If there is no path available, it returns null.", "This method creates a new columnIdent which just consists of the path of the given columnIdent by shifting it to the right. It returns the new columnIdent based on the size of the path.", "Creates a new columnIdent which shifts all elements of the given path except for the first one to the left."]}
{"SampleId": 3833366, "Origin": "Returns the capacity specified for each node, or empty to leave this decision to provisioning", "Reference": "Returns the resources requested for each node, or empty to leave this decision to provisioning", "LLMCandidates": ["Returns the capacity specified for each node or empty to leave this decision to provisioning.", "Returns the resources specified for each node, or empty to leave this decision to provisioning", "Returns the resources specified for each node, or empty to leave this decision to provisioning", "Returns the resources specified for each node, or empty to leave this decision to provisioning", "Returns the resources specified for each node, or empty to leave this decision to provisioning"]}
{"SampleId": 2906488, "Origin": "Returns an immutable copy of the current headers.", "Reference": "Returns an immutable copy of the Headers for this request.", "LLMCandidates": ["Returns an immutable map of the current headers, containing the key and its non-empty value list.", "Returns an immutable copy of the current headers by iterating through each key-value pair and only including non-empty values in the resulting map. The final map is returned as an unmodifiable collection.", "Returns an immutable map of headers where only non-empty values are considered. The map is created by filtering out empty or null header values and storing them in a LinkedHashMap format for easy traversal while maintaining insertion order.", "Returns an immutable copy of the current headers by adding each non-empty header value to a map with unique keys.", "Returns an immutable copy of the current headers, where each entry is associated with a Collection of values and only non-empty collections are included in the map."]}
{"SampleId": 1357584, "Origin": "Purge the population of parts candidates as much as possible, since the cost\nof their later combinations is worse than exponential.", "Reference": "Purge the population of parts candidates as much as possible, since the cost\nof their later combinations is exponential.", "LLMCandidates": ["Purge parts candidates that do not meet certain criteria to improve performance and reduce the cost of later combinations.", "Purge the population of parts candidates as much as possible, since the cost of their later combinations is worse than exponential, and ensure that the resultant list has a maximum count of parts.", "Purge the population of parts candidates as much as possible, since the cost of their later combinations is worse than exponential. Additionally, if there are more parts than allowed, sort them by weight in reverse order and retain only the first \"maxPartCount\" parts.", "Purge the population of parts candidates as much as possible, since the cost of their later combinations is worse than exponential. If the resulting list of parts is larger than a specified maximum count, then sort the list by descending weight and retain only the top items from the list.", "Purge the population of parts candidates as much as possible, since the cost of their later combinations is worse than exponential. If the remaining number of parts after purging exceeds the maxPartCount, sort them by reverse weight and retain only the first params.maxPartCount glyphs."]}
{"SampleId": 6043600, "Origin": "Returns the sync d l objects before and after the current sync d l object in the ordered set where parentFolderId = ?.", "Reference": "Returns the sync d l objects before and after the current sync d l object in the ordered set where modifiedTime > ?", "LLMCandidates": ["Finds the sync DL objects before and after the current sync DL object in the ordered set where modifiedTime = ? and repositoryId = ?", "Returns the sync d l objects before and after the current sync d l object in the ordered set where modifiedTime = ? and repositoryId = ?.", "Finds sync DL objects by modified time before and after the current sync DL object in the ordered set where repositoryId = ?.", "Returns the sync d l objects before and after the current sync d l object in the ordered set where modifiedTime = ? and repositoryId = ?.", "Returns the sync d l objects before and after the current sync d l object in the ordered set where modifiedTime = ? and repositoryId = ?."]}
{"SampleId": 3646276, "Origin": "Calculates the cash flow for a single trade.", "Reference": "Calculates the cash flow for a single closed trade.", "LLMCandidates": ["Calculates the cash flow for a single trade with specified exit index.", "Calculates the cash flow for a single trade, given its exit index.", "Calculates the cash flow for a single trade, considering both buy and sell actions within its lifespan. The final index of observation should be provided when called with trade parameter. If the trade is still open, an IllegalArgumentException will be thrown.", "Calculates the cash flow for a single trade, given its entry and exit points. Throws an IllegalArgumentException if the trade is not closed or if the final index of observation needs to be provided.", "Calculates the cash flow for a single trade considering its opening and closing positions. If the trade is closed, it calculates using the final observation index; otherwise, an IllegalArgumentException is thrown."]}
{"SampleId": 3073837, "Origin": "Assigns a native mirror object to the given RBaseObject object.", "Reference": "Assigns a native mirror object ID to the given RBaseObject object.", "LLMCandidates": ["Assigns a native mirror object to the given RBaseObject and then executes ToNativeNodeGen on that native mirror.", "Converts an RBaseObject object into its native representation by using ToNativeNodeGen to execute the operation on the associated NativeMirror object. If no NativeMirror is present, it creates one first before proceeding with the conversion.", "Assigns a native mirror object to the given RBaseObject object if it is not set yet, then executes ToNativeNodeGen for that object.", "Assigns a native mirror object to the given RBaseObject object if it is not already assigned, then executes the ToNativeNodeGen on the obtained NativeMirror.", "Assigns a native mirror object to the given RBaseObject object, first checking if it has an existing native mirror. If not, one is created and then assigned to the RBaseObject. ToNativeNodeGen is then executed on the native mirror object."]}
{"SampleId": 1314727, "Origin": "Creates an exception from an service name.", "Reference": "Creates an exception from an API name.", "LLMCandidates": ["Creates an exception from an api name.", "Creates an exception from an API name.", "Creates an exception from an API name.", "Creates an exception from an api name.", "Creates an exception from an api name."]}
{"SampleId": 5440430, "Origin": "Appends a quoted string to a given buffer.", "Reference": "Appends a quoted string to the given string buffer.", "LLMCandidates": ["Appends a quoted string to a given buffer by converting it into a StringBuilder and then appending it back to the buffer. This method is deprecated.", "Appends a quoted string to a given buffer, but using StringBuilder internally for better performance and deprecation of StringBuffer.", "Appends a quoted string to a given buffer, deprecated and replaced with a method that uses StringBuilder directly for efficiency.", "Appends a quoted string to a given buffer. This method is now deprecated and recommends using StringBuilder for more efficient performance.", "Appends a quoted string to a given buffer, using a StringBuilder for temporary storage before appending the result to the specified StringBuffer."]}
{"SampleId": 296746, "Origin": "Return -1 if there are no tokens\n on channel between i and 0.", "Reference": "Return -1\nif there are no tokens on channel between {@code i} and 0.", "LLMCandidates": ["Return -1 if there are no tokens on channel between i and 0, or return the index of the first token with the specified channel type when found.", "Return -1 if there are no tokens on channel between i and 0 with the correct channel specified.", "Return -1 if there are no tokens on channel between i and 0, or return the index of the last token on channel before the loop starts.", "Return the index of the previous token on the specified channel between i and 0 or -1 if there are no tokens on that channel.", "Return -1 if there are no tokens on channel between i and 0, or if there's only a single token on that channel"]}
{"SampleId": 585425, "Origin": "Construct the default web view object.", "Reference": "Construct the CordovaWebView object.", "LLMCandidates": ["Constructs the default web view object based on the specified WebView class from the preferences.", "Construct the default web view object using the specified preference.", "Construct the default web view object using the specified web view class.", "Construct the default web view object using the specified web view class.", "Constructs the default web view object using the provided context."]}
{"SampleId": 6018468, "Origin": "Sets each pixel in the output image to log( 1 + input(x,y)) of the input image.", "Reference": "Sets each pixel in the output image to log( val + input(x,y)) of the input image.", "LLMCandidates": ["Sets each pixel in the output image to log(1 + input(x,y)) of the input image, where the logarithm value is now provided through the 'val' argument.", "Sets each pixel in the output image to log( 1 + input(x,y)) of the input image with additional parameter val.", "Sets each pixel in the output image to log(1 + input(x, y)) of the input image, considering an additional variable \"val\".", "Sets each pixel in the output image to log( 1 + input(x,y)) of the input image, with an additional float val argument.", "Sets each pixel in the output image to log( 1 + input(x,y)) of the input image with an additional float parameter val."]}
{"SampleId": 1402019, "Origin": "This returns false for unstampable rule classes and for rules in the\nhost configuration.", "Reference": "This returns false for unstampable rule classes and for rules used to build tools.", "LLMCandidates": ["This returns false for unstampable rule classes and for rules in the tool configuration.", "This returns false for unstampable rule classes and for rules in the tool configuration.", "This returns false for unstampable rule classes and for rules in the tool configuration.", "This returns false for unstampable rule classes and for rules in the tool configuration.", "This returns false for unstampable rule classes and for rules in the tool configuration."]}
{"SampleId": 6018004, "Origin": "Computes the median for each pixel across all bands in the {@link Planar} image.", "Reference": "Computes the median for each pixel across selected bands in the {@link Planar} image.", "LLMCandidates": ["Computes the median for each pixel across all bands in the {@link Planar} image, and then reshapes the output image to have the same width and height as the input image.", "Computes the median for each pixel across all bands in the {@link Planar} image, and reshapes the output {@link GrayF32} image to match the input's dimensions.", "Computes the median for each pixel across all bands in the {@link Planar} image, then reshapes the output to have the same width and height as the input.", "Computes the median for each pixel across all bands in the {@link Planar} image after reshaping its output to have the same width and height as the input.", "Computes the median for each pixel across all bands in the {@link Planar} image and reshapes the output to match the input's width and height."]}
{"SampleId": 6235497, "Origin": "In this test, we close an internal stream in the priority tree but tree should not change.", "Reference": "In this test, we close an internal stream in the priority tree.", "LLMCandidates": ["In this test, we close an internal stream in the priority tree but the distribution of bytes should remain unchanged.", "In this test, we close an internal stream in the priority tree but should not affect the distribution of bytes.", "This test confirms that closing an internal stream doesn't change the overall bytes distribution in the priority tree.", "In this test, we close an internal stream in the priority tree but the bytes distributed among other streams should not change.", "This test checks if closing an internal stream in the priority tree doesn't affect the distribution of bytes written to other streams."]}
{"SampleId": 1462784, "Origin": "Adds a (non-optional non-minus) node to a join group partition.", "Reference": "Adds a (non-optional non-minus) node to a join group partition and\nupdates the set of definitely produced variables accordingly.", "LLMCandidates": ["Adds a non-optional, non-minus node to a join group partition.", "Adds a non-optional non-minus node to a join group partition.", "Adds a non-optional non-minus node to a join group partition.", "Adds a non-optional non-minus node to a join group partition.", "Adds a (non-optional non-minus) node to a join group partition."]}
{"SampleId": 4788910, "Origin": "If they are not\nthe same an AssertionFailedError is thrown.", "Reference": "AssertionFailedError is thrown.", "LLMCandidates": ["Asserts that if they are not the same, an AssertionFailedError is thrown.", "This method compares two objects to check if they are not the same and throws an AssertionFailedError if they are not.", "If they are not the same, an AssertionFailedError is thrown.", "If they are not the same, an AssertionFailedError is thrown.", "If they are not the same, an AssertionFailedError is thrown."]}
{"SampleId": 2568441, "Origin": "Gets the value of the 'ValueType' field.", "Reference": "Gets the value of the 'valueType' field.", "LLMCandidates": ["Gets the value of the 'valueType' field.", "Gets the value of the 'valueType' field.", "Gets the value of the 'valueType' field.", "Gets the value of the 'valueType' field.", "Gets the value of the 'valueType' field."]}
{"SampleId": 3643555, "Origin": "Adds remote file attributes to this remote file class.", "Reference": "Sets remote file attributes to this remote file class.", "LLMCandidates": ["Sets remote file attributes by putting them based on their class into this remote file class.", "Set remote file attributes with specified type.", "Sets attributes by placing them under the corresponding class in a map.", "Sets attributes by placing them under the corresponding class in a map.", "Sets remote file attributes to this remote file class by adding it with a specific type."]}
{"SampleId": 1947847, "Origin": "Increment the count of triggered synchronous state updates (by one).", "Reference": "Increment the count of triggered synchronous state updates in Litho components (by one).", "LLMCandidates": ["Increment the count of component triggered synchronous state updates by one.", "Increment the count of component triggered synchronous state updates (by one).", "Increment the count of component-triggered synchronous state update counts (by one).", "Increment the count of component triggered synchronous state update counts (by one).", "Increment the count of component triggered synchronous state update counts (by one)."]}
{"SampleId": 4625642, "Origin": "Extracts options from the specified item.", "Reference": "Assigns options to the specified options.", "LLMCandidates": ["Assigns options from the specified item.", "Assigns options from the specified item.", "Extracts options from the specified item, considering the changes in method signature and variable name.", "Assigns options from the specified item.", "Assigns options from the specified item."]}
{"SampleId": 1560718, "Origin": "Check whether we are executed on an expired entry before the\ntimer event for expiry was received.", "Reference": "Check whether we are executed on an expired entry before the\ntimer event for the expiry was received.", "LLMCandidates": ["Check if an expired entry is executed before the timer event for its expiry was received.", "Check whether we are executed on an expired entry before the timer event for expiry was received and ensure the next refresh time is set to EXPIRED if needed. Also, check if the heapDataValid flag should be false in this case.", "Check whether we are executed on an expired entry before the timer event for expiry was received.", "Check whether we are executed on an expired entry before the timer event for expiry was received.", "Check if entry is expired before proceeding with mutation."]}
{"SampleId": 2913751, "Origin": "Obtains an instance from the specified unique name.", "Reference": "Obtains an instance from the specified name.", "LLMCandidates": ["Obtains an instance from the specified unique name using the NAMES map to parse the input string.", "Obtains an instance from the specified name by parsing it using NAMES.parse().", "Obtains an instance from the specified name using a map of known names.", "Obtains an instance from the specified name using a map of known names.", "Obtains an instance from the specified name."]}
{"SampleId": 5454839, "Origin": "Checks if the given name is a legal binary name.", "Reference": "Checks if the given name is a legal type name.", "LLMCandidates": ["Checks if the given name is a legal type name.", "Checks if the given name is a legal type name.", "Checks if the given name is a legal type name.", "Checks if the given name is a legal type name.", "Checks if the given name is a legal type name."]}
{"SampleId": 4003873, "Origin": "StringMap\n      is created for the configuration property file and is passed\n      into the framework.", "Reference": "A case\ninsensitive StringMap is\ncreated for the configuration property file and is passed into the\nframework.", "LLMCandidates": ["The LifecycleManager is created for launching and managing the framework. It waits for shutdown, destroys the Karaf upon completion, and checks for restart conditions. An exit code is returned based on different error scenarios.", "The method loops infinitely while checking for various conditions and performing different actions accordingly. The main purpose is to launch a framework, handle exceptions if any, shut it down and restart it if necessary.", "The main method enters an infinite loop that continuously checks if the Karaf framework needs to be restarted. If so, it launches a new instance of Main, waits for its shutdown, and determines whether or not to restart based on user input. Otherwise, it exits the VM.", "Launches the main method for an application using a given set of arguments, then creates a framework, and continually loops to determine if it needs to restart. If restarting is required, it prints a message, otherwise, it exits the VM. The method handles exceptions during shutdown and uses an exit code to indicate errors or normal completion.", "The string map is created for the configuration property file and is passed into the framework."]}
{"SampleId": 4903011, "Origin": "Checks if the deletion policy can release some index commits with the latest global checkpoint.", "Reference": "Checks if the deletion policy can delete some index commits with the latest global checkpoint.", "LLMCandidates": ["Checks if the deletion policy can release some index commits with the latest global checkpoint and returns whether there are any unreferenced commits to be cleaned up.", "Checks if the deletion policy can release some index commits with the latest global checkpoint, considering the condition where the maxSeqNoOfNextSafeCommit is less than or equal to the globalCheckpointSupplier.getAsLong().", "Checks if the deletion policy can release some index commits with the latest global checkpoint. The method returns true if the maximum sequence number of the next safe commit is less than or equal to the global checkpoint. This helps in deciding when it is safe to delete some index commits.", "Checks if the deletion policy can release some index commits with the latest global checkpoint by comparing the maximum sequence number of next safe commit to the current global checkpoint.", "Checks if any index commits can be released due to the latest global checkpoint."]}
{"SampleId": 236975, "Origin": "Tests for the {@link BaseFileSystem#rename(AlluxioURI, AlluxioURI, RenameOptions)}\nmethod.", "Reference": "Tests for the {@link BaseFileSystem#rename(AlluxioURI, AlluxioURI, RenamePOptions)}\nmethod.", "LLMCandidates": ["Tests for the {@link BaseFileSystem#rename(AlluxioURI, AlluxioURI, RenamePOptions)} method.", "Tests for the {@link BaseFileSystem#rename(AlluxioURI, AlluxioURI, RenamePOptions)} method.", "Tests for the BaseFileSystem#rename(AlluxioURI, AlluxioURI, RenamePOptions) method.", "Tests for the BaseFileSystem#rename(AlluxioURI, AlluxioURI, RenamePOptions)} method.", "Tests for the {@link BaseFileSystem#rename(AlluxioURI, AlluxioURI, RenamePOptions)} method."]}
{"SampleId": 5454963, "Origin": "Resolves a collection of root modules, with service binding, to create\nconfiguration.", "Reference": "Resolves a collection of root modules to create a configuration.", "LLMCandidates": ["Resolves a collection of root modules with service binding to create configuration.", "Resolves a collection of root modules for service binding to create configuration.", "Resolves a collection of root modules and configurations to create a configuration.", "Resolves a collection of root modules and configurations to create a configuration.", "Resolves a collection of root modules, with service binding, to create a configuration."]}
{"SampleId": 2887717, "Origin": "Returns the Java type corresponding to the given method descriptor.", "Reference": "Returns the {@link Type} corresponding to the given method descriptor.", "LLMCandidates": ["Returns a Type object corresponding to the given method descriptor, with its valueBuffer being a char array representation of the method descriptor and the starting position at 0. The length of the char array is equal to the length of the method descriptor.", "Returns the Java type corresponding to the given method descriptor by parsing the provided char array and returning a new Type object with the specified parameters.", "Returns a new Type instance with the METHOD qualifier, based on the given method descriptor's char array, starting from index 0 and of length equal to the full array.", "Returns the Java type corresponding to the given method descriptor, using a char array and initializing with a new Type object of METHOD type.", "Returns a Type object corresponding to the given method descriptor. The method creates a new Type object with the METHOD constant, using the character array representing the method descriptor and setting the start and end positions to 0 and the length of the array, respectively."]}
{"SampleId": 4386726, "Origin": "SHA256 tree hash does not match To ensure that part data is\nnot corrupted in transmission, you compute a SHA256 tree hash of the\npart and include it in your request.", "Reference": "SHA256 tree hash does not matchTo ensure that part data is not\ncorrupted in transmission, you compute a SHA256 tree hash of the part and\ninclude it in your request.", "LLMCandidates": ["To ensure that part data is not corrupted in transmission, you compute a SHA256 tree hash of the part and include it in your request.", "Ensure that part data is not corrupted in transmission by computing a SHA256 tree hash of the part and including it in your request.", "To ensure that part data is not corrupted in transmission, you compute a SHA256 tree hash of the part and include it in your request.", "Uploads part data for an object using a multipart upload request. The method computes a SHA256 tree hash of the part and includes it in the request to ensure that part data is not corrupted in transmission.", "To ensure that part data is not corrupted in transmission, you compute a SHA256 tree hash of the part and include it in your request."]}
{"SampleId": 6326658, "Origin": "Returns an instance of a GLSL data type for the given {@link DataType}.", "Reference": "Returns an instance of a GLSL data type for the given {@link ShaderVariable}.", "LLMCandidates": ["Returns an instance of a GLSL data type for the given {@link DataType} and a specific ShaderVariable.", "Returns an instance of a GLSL data type for the given {@link ShaderVariable}.", "Returns an instance of a GLSL data type for the given {@link DataType} and ShaderVariable.", "Returns an instance of a GLSL data type for the given {@link DataType} and ShaderVariable.", "Returns an instance of a GLSL data type for the given {@link ShaderVariable}."]}
{"SampleId": 4615504, "Origin": "If nodes returned are to be further used, they must be finalized via {@link ANode#finish()}.", "Reference": "Before nodes are added to the result, they must be finalized via {@link ANode#finish()}.", "LLMCandidates": ["If nodes returned are to be further used, they must be finalized via {@link ANode#finish()}.", "If nodes returned are to be further used, they must be finalized via {@link ANode#finish()}.", "If nodes returned are to be further used, they must be finalized via {@link ANode#finish()}.", "If nodes returned are to be further used, they must be finalized via {@link ANode#finish()}.", "If nodes returned are to be further used, they must be finalized via {@link ANode#finish()}."]}
{"SampleId": 711380, "Origin": "Tests if this string starts with any specified prefixes.", "Reference": "Tests if this CharSequence starts with any specified prefixes.", "LLMCandidates": ["Tests if this string starts with any specified prefixes using CharSequence.", "Tests if this CharSequence starts with any specified prefixes using toString() method for comparison.", "Tests if this string starts with any specified prefixes.", "Tests if this string starts with any specified prefixes.", "Tests if this string starts with any specified prefixes, using CharSequence type parameters."]}
{"SampleId": 6049196, "Origin": "Returns the user thread with the primary key or throws a {@link com.liferay.privatemessaging.NoSuchUserThreadException} if it could not be found.", "Reference": "Returns the user thread with the primary key or throws a {@link NoSuchUserThreadException} if it could not be found.", "LLMCandidates": ["Returns the user thread with the primary key or throws a {@link com.liferay.privatemessaging.NoSuchUserThreadException} if it could not be found.", "Returns the user thread with the primary key or throws a {@link com.liferay.privatemessaging.NoSuchUserThreadException} if it could not be found.", "Returns the user thread with the primary key or throws a {@link com.liferay.privatemessaging.NoSuchUserThreadException} if it could not be found.", "Finds the user thread with the primary key or throws a {@link com.liferay.privatemessaging.NoSuchUserThreadException} if it could not be found.", "Finds the user thread with the specified primary key or throws a NoSuchUserThreadException if it cannot be found."]}
{"SampleId": 3892009, "Origin": "Stub of {@link Plugin#willDeclareSetter(TypeSpec.Builder, PropertyGenerator, MethodSpec.Builder)} for subclasses\nto override", "Reference": "Stub of {@link Plugin#beforeDeclareSetter(TypeSpec.Builder, PropertyGenerator, MethodSpec.Builder)} for subclasses\nto override", "LLMCandidates": ["Stub of {@link Plugin#beforeDeclareSetter(TypeSpec.Builder, PropertyGenerator, MethodSpec.Builder)} for subclasses to override", "Stub of {@link Plugin#beforeDeclareSetter(TypeSpec.Builder, PropertyGenerator, MethodSpec.Builder)} for subclasses to override", "Stub of {@link Plugin#beforeDeclareSetter(TypeSpec.Builder, PropertyGenerator, MethodSpec.Builder)} for subclasses to override", "Stub of {@link Plugin#beforeDeclareSetter(TypeSpec.Builder, PropertyGenerator, MethodSpec.Builder)} for subclasses to override", "Stub of {@link Plugin#beforeDeclareSetter(TypeSpec.Builder, PropertyGenerator, MethodSpec.Builder)} for subclasses to override"]}
{"SampleId": 5640472, "Origin": "Observer methods with other transaction phase\nare scheduled for the corresponding transaction phase.", "Reference": "Transactional observer methods are scheduled to be executed in the corresponding transaction phase.", "LLMCandidates": ["Notify sync observers first followed by transaction observers using metadata if needed. The async observers are notified using a provided executor and an exception handler.", "Schedules the observer methods according to the transaction phase for each type of observer.", "Schedules the observer methods according to the transaction phase for each type of observer.", "This method schedules Observer methods for different transaction phases. It first notifies sync observers and then transaction observers. Finally, it returns a CompletionStage containing the event to be processed by async observers using the provided executor. A CollectorExceptionHandler is used while notifying transaction and sync observers.", "Notify observers in different transaction phases are scheduled according to their corresponding phase."]}
{"SampleId": 5246023, "Origin": "Use the given SleuthkitCase to update the data used to determine the\navailable filters.", "Reference": "Update the data used to determine the available filters.", "LLMCandidates": ["Use the given SleuthkitCase to update the data used to determine the available filters. This method retrieves information from the case object and adds it to relevant collections. Additionally, any potential exceptions are caught and converted into a TskCoreException for further handling.", "Use the given SleuthkitCase to update the data used to determine the available filters.", "Use the given SleuthkitCase to update the data used to determine the available filters.", "Use the given SleuthkitCase to update the data used to determine the available filters, adding datasources and tag names in use from the case.", "Use the given SleuthkitCase to populate the data for available filters by adding hash set names, and updating the datasourcesMap with existing datasource names from the SleuthkitCase. Additionally, determine all tag names in use by the case."]}
{"SampleId": 2609132, "Origin": "Extract a user rating vector from a rating cursor.", "Reference": "Extract a user rating vector from a rating stream.", "LLMCandidates": ["Extract a user rating vector from an ObjectStream of ratings.", "Extract a user rating vector from an ObjectStream of ratings.", "Extract a user rating vector from an ObjectStream of ratings.", "Extract a user rating vector from an ObjectStream of ratings.", "Extract a user rating vector from an ObjectStream of ratings."]}
{"SampleId": 1644557, "Origin": "Adds a  to a buffer, with each  being separated by a \":\".", "Reference": "Adds a  to a ,\nwith each  being separated by a \":\".", "LLMCandidates": ["Appends a  to a builder, with each  being separated by a delimiter.", "Appends a to a builder, with each item being separated by a delimiter.", "Appends a to a builder, with each item being separated by a delimiter.", "Appends a String s to a StringBuilder b, with each appended String being separated by a colon ':'.", "Adds a string s to the StringBuilder b, with each string s being separated by a ':'."]}
{"SampleId": 5433548, "Origin": "Do nothing if\n{@link BaseConfiguration#nocomment} is set to true.", "Reference": "Do nothing if\n{@link BaseOptions#noComment} is set to true.", "LLMCandidates": ["Do nothing if {@link BaseConfiguration#noComment} is set to true.", "Do nothing if {@link BaseConfiguration#noComment} is set to true.", "Do nothing if {@link BaseConfiguration#noComment} is set to true.", "Do nothing if {@link BaseConfiguration#noComment} is set to true.", "Do nothing if {@link BaseConfiguration#noComment} is set to true."]}
{"SampleId": 1806089, "Origin": "Standard setter for the leftwardLabel String for this RelationshipType", "Reference": "Standard setter for the leftwardType String for this RelationshipType", "LLMCandidates": ["Setter for the leftwardType String for this RelationshipType", "Standard setter for the leftwardType String for this RelationshipType", "Setter for the leftwardType String for this RelationshipType", "Setter for the leftwardType String for this RelationshipType", "Standard setter for the leftwardType String for this RelationshipType"]}
{"SampleId": 2444053, "Origin": "Create a {@link ServiceLocator}.", "Reference": "Create a {@link InstanceManager}.", "LLMCandidates": ["Create an {@link InstanceManager}.", "Create an {@link InstanceManager}.", "Create an {@link InstanceManager}.", "Create an {@link InstanceManager}.", "Create an {@link InstanceManager}."]}
{"SampleId": 3490831, "Origin": "It will also exclude files that cannot be analysed with {@link #canAnalyze(VirtualFile, FileType, Module)}.", "Reference": "It will also exclude files that cannot be analysed with {@link #canAnalyze(VirtualFile, Module)}.", "LLMCandidates": ["Checks if a file can be analyzed using {@link #canAnalyze(VirtualFile, Module)}. If the file is not analyzable, returns Result.excluded. Then, excludes files that match global or project exclusions settings. Finally, always returns Result.notExcluded().", "Checks if a file can be analyzed with {@link #canAnalyze(VirtualFile, Module)}, and excludes files that do not meet this condition. It also checks for other exclusions defined in SonarLint Global Settings and SonarLint Project Settings before returning the result.", "It will also exclude files that cannot be analysed with {@link #canAnalyze(VirtualFile, FileType, Module)}.", "This method checks whether a file should be excluded from analysis by first checking if it can be analysed using {@link #canAnalyze(VirtualFile, Module)}, and then considering the exclusion criteria based on power save mode, source folders, global settings, and project settings.", "It will also exclude files that cannot be analyzed with {@link #canAnalyze(VirtualFile, Module)}, and checks if the file matches exclusions defined in SonarLint Global Settings or Project Settings."]}
{"SampleId": 3270265, "Origin": "If the name is a single identifier, then this can be\n      reclassified as an {@link ASTVariableReference}", "Reference": "If the name is a single identifier, then this can be\n      reclassified as an {@link ASTVariableAccess}", "LLMCandidates": ["If the name is a single identifier, then this can be reclassified as an {@link ASTVariableAccess} and {@link ASTFieldAccess}.", "If the name is a single identifier, then this can be reclassified as an {@link ASTVariableAccess}.", "If the name is a single identifier, then this can be reclassified as an {@link ASTVariableAccess}.", "If the name is a single identifier, then this can be reclassified as an {@link ASTVariableAccess}.", "If the node is on top of the stack and has no parent, then this method can be reclassified as an {@link ASTVariableAccess} followed by an {@link ASTFieldAccess}."]}
{"SampleId": 2706941, "Origin": "Set Account Type.", "Reference": "Set Kontenart.", "LLMCandidates": ["Set the Account Type.", "Set Account Type with the provided java.lang.String value for the AccountType column.", "Set Account Type in this Java class by providing a String for the account type.", "Set the Account Type.", "Set the Account Type."]}
{"SampleId": 5051650, "Origin": "Returns the object with the settings used for calls to labelAudio.", "Reference": "Returns the object with the settings used for calls to getEvaluation.", "LLMCandidates": ["Returns the object with the settings used for calls to getEvaluation.", "Returns the object with the settings used for calls to getEvaluation.", "Returns the object with the settings used for calls to getEvaluation.", "Returns the object with the settings used for calls to getEvaluation.", "Returns the object with the settings used for calls to getEvaluation."]}
{"SampleId": 3991859, "Origin": "This is a convenience method for {@link #electPreferredLeaders(Collection, ElectPreferredLeadersOptions)}\nwith default options.", "Reference": "This is a convenience method for {@link #electLeaders(ElectionType, Set, ElectLeadersOptions)}\nwith preferred election type and default options.", "LLMCandidates": ["This is a convenience method for {@link #electPreferredLeaders(Collection, ElectPreferredLeadersOptions)} with default options. It is deprecated and no longer recommended for use in new code. Please use the non-deprecated version instead.", "This is a convenience method for {@link #electPreferredLeaders(Collection, ElectPreferredLeadersOptions)} with default options. Deprecated since version 3.0. Use {@link #electPreferredLeaders(Collection, ElectPreferredLeadersOptions)} instead.", "This is a convenience method for {@link #electPreferredLeaders(Collection, ElectPreferredLeadersOptions)} with default options. It is deprecated.", "This is a convenience method for {@link #electPreferredLeaders(Collection, ElectPreferredLeadersOptions)} with default options and has been deprecated.", "Deprecated convenience method for {@link #electPreferredLeaders(Collection, ElectPreferredLeadersOptions)} with default options."]}
{"SampleId": 615862, "Origin": "Returns the value of the specific parameter, or default value defined in the {@code info} if\nthis Params doesn't contain the param.", "Reference": "Returns the value of the specific parameter, or default value defined in the {@code info} if\nthis Params doesn't have a value set for the parameter.", "LLMCandidates": ["Returns the value of the specific parameter from a list of names and aliases associated with the {@code info} or default value defined in the info if this Params doesn't contain the param.", "Returns the value of a specific parameter or its default value from {@code info} if this Params doesn't contain the param. If the param is not set by the user and it is not optional, an exception will be thrown. If the param does not have a default value and it is optional, the default value will be returned.", "Returns the value of the specific parameter, or default value defined in the {@code info} if this Params doesn't contain the param. If the parameter is not set by the user and is non-optional, an IllegalArgumentException is thrown. If the parameter does not have a default value, an IllegalArgumentException is also thrown.", "Returns the value of the specific parameter, or default value defined in the {@code info} if this Params doesn't contain the param. Checks for duplicate parameters and throws IllegalArgumentException for missing non-optional parameters without a set value.", "Returns the value of the specific parameter, or the default value defined in the {@code info} if this Params doesn't contain the param. If the param is not set by the user and it is non-optional, an IllegalArgumentException will be thrown; otherwise, if there's no default value, a IllegalArgumentException is thrown again."]}
{"SampleId": 3241790, "Origin": "Create an instance of {@link JAXBElement }{@code <}{@link CTMarkupRange }{@code >}}", "Reference": "Create an instance of {@link JAXBElement }{@code <}{@link CTMoveFromRangeEnd }{@code >}}", "LLMCandidates": ["Create an instance of {@link JAXBElement }{@code <}{@link CTMoveFromRangeEnd}}{@code >", "Create an instance of {@link JAXBElement }{@code <}{@link CTMoveFromRangeEnd }{@code >", "Create an instance of {@link JAXBElement }{@code <}{@link CTMoveFromRangeEnd }{@code >", "Create an instance of {@link JAXBElement }{@code <}{@link CTMoveFromRangeEnd }}</code>}\n\n \"Create an instance of {@link JAXBElement }{@code <}{@link CTMarkupRange }{@code >", "Create an instance of {@link JAXBElement }{@code <}{@link CTMoveFromRangeEnd }{@code >}}\n\nNote that the variable type has been changed from CTMarkupRange to CTMoveFromRangeEnd, and the QNAME and element class have also been updated accordingly."]}
{"SampleId": 3734028, "Origin": "Is the value with this qualifier less than the length of any of the arrays?", "Reference": "Is the value with this qualifier less than the length of any of the sequences?", "LLMCandidates": ["Is the value with this qualifier less than the length of any of the sequences?", "Is the value with this qualifier less than the length of any of the sequences?", "Is the value with this qualifier less than the length of any of the sequences?", "Is the value with this qualifier less than the length of any of the sequences?", "Is the value with this qualifier less than the length of any of the sequences?"]}
{"SampleId": 241096, "Origin": "Clears the given persisted files stored in {@link #mPersistedFiles}.", "Reference": "Clears the given persisted files stored in {@link #mPersistedFilesInfo}.", "LLMCandidates": ["Clears the given persisted files identifiers stored in {@link #mPersistedFiles}. For each file id in the list, it removes its information from {@link #mPersistedFilesInfo}.", "Clears the given persisted file identifiers stored in {@link #mPersistedFilesInfo}.", "Clears the given persisted file identifiers stored in {@link #mPersistedFilesInfo}.", "Clears the given persisted file IDs stored in {@link #mPersistedFilesInfo} by removing them one by one using a loop.", "Clears the given persisted files stored in {@link #mPersistedFilesInfo}."]}
{"SampleId": 3679705, "Origin": "Compares this {@code LocalDateTime} to another date-time.", "Reference": "Compares this date-time to another date-time.", "LLMCandidates": ["Compares this {@code LocalDateTime} to another date-time by checking whether the other object is an instance of {@code LocalDateTime} and then calls the specific implementation for it. If not, uses the default super class implementation.", "Compares this {@code LocalDateTime} to another date-time using a specific strategy based on their type. If other is an instance of LocalDateTime, the compareTo0 method is used for comparison; otherwise, the superclass implementation is used.", "Compares this {@code LocalDateTime} to another date-time by checking if the other object is of type {@code LocalDateTime}. If it is, compares using a specialized method; otherwise, use the base class's implementation.", "Compares this {@code LocalDateTime} to another date-time using an overridden version of the compareTo method that can handle different implementations of ChronoLocalDateTime.", "Compares this {@code LocalDateTime} to another date-time by checking if both are from the same class and calling the specific implementation for {@code LocalDateTime}, or using the default superclass method otherwise."]}
{"SampleId": 2915631, "Origin": "This returns a trade based on the specified trade date.", "Reference": "This returns a trade based on the specified trade date and upfront fee.", "LLMCandidates": ["This method creates a CdsTrade object based on the specified input parameters, and returns it following certain conditions related to accrualStart.", "This returns a trade based on the specified trade date and considering the accrual start method. If accrualStart is IMM_DATE, the trade convention is used as before. Otherwise, if accrualStart is set to a different value, a trade with adjusted tenor and tradeDate will be returned.", "This returns a trade based on the specified trade date, considering the accrual start type. If accrualStart is IMM_DATE, it follows the conventional method to create the trade; otherwise, it creates the trade with the following trade date plus one day and the specified tenor.", "This returns a trade based on the specified trade date and accrual start.", "This returns a trade based on the specified trade date and accrual start. If accrualStart is IMM_DATE, it uses the standard convention to create the trade. Otherwise, it uses a trade date plus one day as the accrual start date along with the same convention to create the trade."]}
{"SampleId": 2247229, "Origin": "Returns a new Task that, when this task completes\nnormally, is executed using the supplied Scheduler, with this\ntask's result as the argument to the supplied function.", "Reference": "Returns a new Task that, when this task completes\nnormally, is executed using the supplied Executor, with this\ntask's result as the argument to the supplied function.", "LLMCandidates": ["Returns a new Task that, when this task completes normally, is executed using the supplied Executor, with this task's result as the argument to the supplied function.", "Returns a new Task that, when this task completes normally, is executed using the supplied Executor, with this task's result as the argument to the supplied function.", "Returns a new Task that, when this task completes normally, is executed using the supplied Executor, with this task's result as the argument to the supplied function.", "Returns a new Task that, when this task completes normally, is executed using the supplied Executor, with this task's result as the argument to the supplied function.", "Returns a new Task that, when this task completes normally, is executed using the supplied Executor, with this task's result as the argument to the supplied function."]}
{"SampleId": 2911098, "Origin": "This parses the specified byte source to determine if it appears to be FpML.", "Reference": "This checks the first part of the byte source to see if it appears to be FpML.", "LLMCandidates": ["This parses the specified byte source to determine if it appears to be FpML by checking for specific characters that indicate a valid FpML format. It checks for the presence of \"fpml\" in UTF-8 or UTF-16 encoding and returns true if found, otherwise false.", "This parses the specified byte source to check if it appears to be FpML, by iterating through a buffer and checking for specific character patterns (UTF-8 or UTF-16).", "This parses the specified byte source to determine if it contains a specific sequence of characters ('fpml' in UTF-8 or UTF-16 format).", "This parses the specified byte source to determine if it appears to be FpML by checking for specific patterns in the first 2000 bytes of the input. If any of the identified patterns match, then the input is considered as FpML format; otherwise, it returns false.", "This parses the specified byte source to identify if it appears to be FpML by checking for specific patterns within the first 2000 bytes of data. If a match is found, the method returns true; otherwise, it returns false. This method catches exceptions such as IOException and UncheckedIOException to handle errors during parsing."]}
{"SampleId": 4476807, "Origin": "The {@link KeyCreateOptions#isEnabled()} enabled} field\nis set to true by Azure Key Vault, if not specified.", "Reference": "The {@link CreateKeyOptions#isEnabled()} enabled} field\nis set to true by Azure Key Vault, if not specified.", "LLMCandidates": ["The {@link CreateKeyOptions#isEnabled()} enabled field is set to true by Azure Key Vault, if not specified.", "The {@link CreateKeyOptions#isEnabled()} enabled} field is set to true by Azure Key Vault, if not specified.", "The {@link CreateKeyOptions#isEnabled()} enabled} field is set to true by Azure Key Vault, if not specified.", "The {@link CreateKeyOptions#isEnabled()} enabled field is set to true by Azure Key Vault, if not specified.", "The {@link CreateKeyOptions#isEnabled()} enabled} field is set to true by Azure Key Vault, if not specified."]}
{"SampleId": 3629279, "Origin": "See Immutable List Static Factory Methods for details.", "Reference": "See Unmodifiable Lists for details.", "LLMCandidates": ["See Unmodifiable List Static Factory Methods for details.", "See Unmodifiable List Static Factory Methods for details.", "See Immutable Collections Static Factory Methods for details.", "See Immutable Collections Static Factory Methods for details.", "See Immutable Collections Static Factory Methods for details."]}
{"SampleId": 3428160, "Origin": "Helper to parse the imported file into an {@link ImportedGradeWrapper} depending on its type", "Reference": "Helper to parse the imported file into an {@link ImportedSpreadsheetWrapper} depending on its type", "LLMCandidates": ["Helper to parse the imported file into an {@link ImportedSpreadsheetWrapper} depending on its type", "Helper to parse the imported file into an {@link ImportedSpreadsheetWrapper} depending on its type", "Helper to parse the imported file into an {@link ImportedSpreadsheetWrapper} depending on its type", "Helper to parse the imported file into an {@link ImportedSpreadsheetWrapper} depending on its type", "Helper to parse the imported file into an {@link ImportedSpreadsheetWrapper} depending on its type"]}
{"SampleId": 4715193, "Origin": "Fixes a bug with the Swing JFileChooser: if you entered a new\nfilename in the save dialog and press Enter the \nmethod returns  instead of the filename.", "Reference": "Swing JFileChooser: if you entered a new filename in the save dialog and\npress Enter the  method returns\n instead of the filename.", "LLMCandidates": ["The saveComponent() method displays a save dialog and saves the file after receiving user approval.", "Fixes a bug with the Swing JFileChooser: if you entered a new filename in the save dialog and press Enter the method returns instead of the file name.", "Fixes a bug with the Swing JFileChooser: if you entered a new filename in the save dialog and press Enter the method returns instead of the filename.", "Fixes a bug with the Swing JFileChooser: if you entered a new filename in the save dialog and press Enter, the method now returns the filename instead of returning.", "Fixes a bug with the Swing JFileChooser: if you entered a new filename in the save dialog and press Enter the method returns the file instead of the filename."]}
{"SampleId": 1326993, "Origin": "Returns the operation enum value.", "Reference": "Returns the operation constant name.", "LLMCandidates": ["Returns the operation constant.", "Returns the operation constant.", "Returns the operation constant based on the MethodDescriptorProto method descriptor.", "Returns the operation constant based on the MethodDescriptorProto method descriptor.", "Returns the operation constant."]}
{"SampleId": 3937267, "Origin": "Saves all dictionary entries that appeared > threshold times Note: feature\nindices are changed to contiguous values starting at 0.", "Reference": "Saves all dictionary entries that appeared {@literal >} threshold times Note: feature\nindices are changed to contiguous values starting at 0.", "LLMCandidates": ["Saves all dictionary entries that appeared > threshold times. Note: feature indices are changed to contiguous values starting at 0.", "Saves all dictionary entries that appeared more than threshold times. Note: feature indices are changed to contiguous values starting at 0.", "Saves all dictionary entries that appeared > threshold times. Note: feature", "Saves all dictionary entries that appeared > threshold times. Note: feature indices are changed to contiguous values starting at 0.", "Saves all dictionary entries that appeared > threshold times Note: feature"]}
{"SampleId": 3036919, "Origin": "Currently, SONA supports Flat, VXLAN and VLAN modes.", "Reference": "Currently, SONA supports Flat, VXLAN, GRE and VLAN modes.", "LLMCandidates": ["SONA now supports Flat, VXLAN, GRE, and VLAN modes.", "Currently, SONA supports Flat, VXLAN, and GRE modes.", "Currently, SONA supports Flat, VXLAN, and GRE modes.", "SONA now supports Flat, VXLAN, GRE and VLAN modes.", "SONA supports Flat, VXLAN, GRE, and VLAN modes."]}
{"SampleId": 2443799, "Origin": "Create new instance of {@link InstanceManagerStore}.", "Reference": "Create new instance of {@link InjectionManagerStore}.", "LLMCandidates": ["Create new instance of {@link InjectionManagerStore}.", "Create new instance of {@link InjectionManagerStore}.", "Create new instance of {@link InjectionManagerStore}.", "Create new instance of {@link InjectionManagerStore}.", "Create new instance of {@link InjectionManagerStore}."]}
{"SampleId": 2018806, "Origin": "Sets dependency options.", "Reference": "Sets the dependency management options.", "LLMCandidates": ["Sets dependency options using the provided DependencyOptions object.", "Sets dependency options using the specified DependencyOptions object.", "Sets dependency options using dependencyOptions.", "Sets dependency options using dependencyOptions.", "Sets dependency options using dependencyOptions."]}
{"SampleId": 1611711, "Origin": "Setter for comment format.", "Reference": "Setter for comment pattern.", "LLMCandidates": ["Setter for comment pattern.", "Setter for comment pattern.", "Setter for comment pattern.", "Setter for comment pattern.", "Setter for comment pattern."]}
{"SampleId": 2484705, "Origin": "Sets the entity attribute of this User to\nentity", "Reference": "Sets the entity attribute of this User's element\nto entity", "LLMCandidates": ["Sets the entity attribute of this UserElement to entity", "Sets the entity attribute of this UserElement to entity", "Sets the entity attribute of this UserElement to entity", "Sets the entity attribute of this UserElement to entity", "Sets the entity attribute of this UserElement to entity"]}
{"SampleId": 5456635, "Origin": "More specifically, the root modules are resolved as if by calling\n{@code resolveRequires}.", "Reference": "More specifically, the root modules are resolved as if by calling\n{@code resolve}.", "LLMCandidates": ["More specifically, the root modules are resolved as if by calling {@code resolveAndBind}.", "The root modules are resolved and bound as if by calling resolveAndBind.", "This method is used to resolve and bind modules using a given root collection. The resolver will first resolve the roots as if by calling {@code resolve}, then bind all required modules and configurations.", "More specifically, the root modules are resolved and bound as if by calling {@code resolveAndBind}.", "More specifically, the root modules are resolved as if by calling resolveAndBind."]}
{"SampleId": 2443742, "Origin": "Get the set of all custom providers registered for the given service provider contract\nin the underlying {@link InstanceManager instance manager} container.", "Reference": "Get the set of all custom providers registered for the given service provider contract\nin the underlying {@link InjectionManager injection manager} container.", "LLMCandidates": ["Get the set of all custom providers registered for the given service provider contract in the underlying {@link InjectionManager injection manager} container.", "Get the set of all custom providers registered for the given service provider contract\nin the underlying {@link InjectionManager injection manager} container.", "Get the set of all custom providers registered for the given service provider contract in the underlying {@link InjectionManager injection manager} container.", "Get the set of all custom providers registered for the given service provider contract in the underlying {@link InjectionManager injection manager} container.", "Get the set of all custom providers registered for the given service provider contract in the underlying {@link InjectionManager injection manager} container."]}
{"SampleId": 132533, "Origin": "Generates the form to post to the dialog frame.", "Reference": "Generates the dialog parameters.", "LLMCandidates": ["Generates a map of parameters for use in creating a form to post to the dialog frame.", "Generates a map of form parameters for the dialog frame from the given structure ID and context menu entry bean's params.", "Generates a map containing dialog parameters based on the provided structure ID and menu entry bean params.", "Generates a map containing parameters for submitting a post request to the dialog frame.", "Generates a map of form parameters to be used by the dialog frame."]}
{"SampleId": 1042147, "Origin": "Returns  If the\n is greater than the .", "Reference": "Returns  If the\n is greater than the  and \n is not used.", "LLMCandidates": ["shouldCreateWorkunit(long createTime, long updateTime, LongWatermark lowWatermark) }\nIf the is greater than the .\nReturns If the is before this.maxLookBackTime, return false; otherwise, return if the is after the .", "Returns if the is greater than the .", "Determine if a workunit should be created based on the difference between the update time and the low watermark value. Additionally, the method checks if the update time is not older than the max lookback time to ensure that only recent updates are considered.", "If the DateTime of the updateTime is before this.maxLookBackTime, return false; otherwise, return true if the newDateTime of the updateTime is after the lowWatermark.getValue().", "Returns true if the updateTime is greater than the maxLookBackTime and greater than or equal to the lowWatermark value."]}
{"SampleId": 2048399, "Origin": "After calling this method, call\n{@link #configure(int, int, int)} to start using the new sample rate.", "Reference": "After calling this method, call {@link\n#configure(AudioFormat)} to start using the new sample rate.", "LLMCandidates": ["After calling this method, call {@link #configure(int, int)} to start using the new sample rate.", "After calling this method, call {@link #configure(int, int)} to start using the new sample rate.", "After calling this method, call {@link #configure(int, int, int)} to start using the new sample rate.", "After calling this method, call {@link #configure(int, int, int)} to start using the new sample rate.", "After calling this method, call {@link #configure(int, int, int)} to start using the new sample rate."]}
{"SampleId": 3846374, "Origin": "Move this TouchDisplay to a new x-y position and bounds.", "Reference": "Move this TouchDisplay to a new x-y position.", "LLMCandidates": ["Move this TouchDisplay to a new x-y position without specifying bounds.", "Move this TouchDisplay to a new x-y position using labelText and circle.", "Move this TouchDisplay to a new x-y position while retaining the Bounds and labelText settings.", "Move this TouchDisplay to a new x-y position without specifying bounds.", "Move this TouchDisplay to a new x-y position without specifying bounds."]}
{"SampleId": 6019207, "Origin": "Triangulate two view using the Discrete Linear Transform (DLT)", "Reference": "Triangulate two view using the Discrete Linear Transform (DLT) with an uncalibrated camera.", "LLMCandidates": ["Triangulate two views using the Discrete Linear Transform (DLT).", "Triangulate two views using the Discrete Linear Transform (DLT), but it is now uncalibrated.", "Triangulate two views using the Discrete Linear Transform (DLT), uncalibrated version", "Triangulate two views using the Discrete Linear Transform (DLT), but the resulting point cloud is uncalibrated.", "Triangulate two views using the Discrete Linear Transform (DLT), uncalibrated."]}
{"SampleId": 3942113, "Origin": "Split the given tree based on a split point such that the\nterminals leading up to the split point are in the left returned\ntree and those following the are in the right returned tree.", "Reference": "Split the given tree based on a split point such that the\nterminals leading up to the split point are in the left returned\ntree and those following the are in the left returned tree.", "LLMCandidates": ["Split the given tree based on a split point such that the terminals leading up to the split point are in the left returned tree and those following the are in the right returned tree.", "Split the given tree based on a split point such that the terminals leading up to the split point are in the right returned tree and those following are in the left returned tree.", "Split the given tree based on a split point such that the terminals leading up to the split point are in the left returned tree and those following are in the right returned tree.", "Split the given tree based on a split point such that terminals leading up to the split point are in the left returned tree and those following are in the right returned tree.", "Split the given tree based on a split point such that the terminals leading up to the split point are in the left returned tree and those following are in the right returned tree."]}
{"SampleId": 570069, "Origin": "Gets the full path from a full filename, which is the prefix + path,\nand also excluding the final directory separator.", "Reference": "Gets the full path from a full fileName, which is the prefix + path,\nand also excluding the final directory separator.", "LLMCandidates": ["Gets the full path from a full filename, including the prefix and path, but excluding the final directory separator.", "Gets the full path from a full filename, which is the prefix + path, excluding the final directory separator.", "Gets the full path from a full file name, which is the prefix + path, and also excluding the final directory separator.", "Get full path from a filename, which is the prefix + path, and also excluding the final directory separator.", "Get full path from a filename, which is the prefix + path, and also excluding the final directory separator."]}
{"SampleId": 3322433, "Origin": "As the name\nimplies,  indicates whether the train or cart is in the process\nof leaving the track.", "Reference": "As the name\nimplies, {@code trainLeaving} indicates whether the train or cart is in the process\nof leaving the track.", "LLMCandidates": ["The calculateLocked() method determines if the train or cart is locked or not, based on the current state of the track and user input. If redstone is true and waited has reached delay, the method sets locked to false and returns. If trainLeaving and isSameCart are both true, locked is set to false. Otherwise, locked is set to true and trainLeaving is set to false. If a cart is present and locked, waited is incremented and sendUpdateToClient() is called if waited becomes 1.", "Indicates whether the train or cart is locked on track.", "Indicates whether the train or cart is locked on track.", "Indicates whether the train or cart is currently locked or not.", "Indicates whether the train or cart is currently locked or not."]}
{"SampleId": 4396607, "Origin": "Returns a string representation of this object; useful for testing and debugging.", "Reference": "Returns a string representation of this object.", "LLMCandidates": ["Returns a string representation of this object; useful for testing and debugging, with sensitive data being redacted by replacing it with \"***Sensitive Data Redacted***\".", "Returns a string representation of this object; useful for testing and debugging, with sensitive data redacted by placing \"***Sensitive Data Redacted***\" in place of secret binary and secret string values.", "Returns a string representation of this object; useful for testing and debugging. If there is sensitive data such as SecretBinary or SecretString, it will be replaced with \"***Sensitive Data Redacted***\".", "Returns a string representation of this object; useful for testing and debugging, with sensitive data redacted when necessary.", "This method generates a string representation of the object for testing and debugging purposes."]}
{"SampleId": 234560, "Origin": "When the context is being reinitialized, this call blocks until the reinitialization succeeds\nor fails.", "Reference": "When the context is being reinitialized, this call returns an empty optional.", "LLMCandidates": ["When the context is being reinitialized, this call blocks until the reinitialization completes or fails by checking if the resource count is greater than zero before returning. If it's not, an empty Optional is returned; otherwise, a CountResource object is returned with the current count and locked state.", "When the context is reinitialized, this call blocks until the reinitialization succeeds or fails.", "When the context is reinitialized, this call blocks until the reinitialization succeeds or fails.", "When the context is being reinitialized, this call blocks until the reinitialization succeeds or fails.", "Acquire an optional CountResource, if successful or fails due to reinitialization error"]}
{"SampleId": 5437406, "Origin": "If the property has not been set, or if its\nvalue is negative, set the timeout length to the default.", "Reference": "If the property has not been set, or if its\nvalue is negative, set the timeout length to the specified default.", "LLMCandidates": ["If the property has not been set, or if its value is negative, set the timeout length to the default.", "If the property has not been set or if its value is negative, set the timeout length to the default.", "If the property has not been set or if its value is negative, set the timeout length to the default.", "If the property has not been set, or if its value is negative, set the timeout length to the default value specified by the second parameter of the method.", "If the property has not been set, or if its value is negative, set the timeout length to the default value specified by the 'def' parameter."]}
{"SampleId": 4386732, "Origin": "Access Control Using AWS Identity and Access Management (IAM) \n.", "Reference": "For more information, see Access Control Using AWS Identity and Access Management (IAM).", "LLMCandidates": ["Deletes notifications for a vault. This operation removes all notifications associated with the specified vault, including both event and system notifications. This operation can be invoked using the \"DeleteVaultNotifications\" action. The request includes the parameters required to uniquely identify the vault and its notifications.", "Deletes vault notifications based on given request, using AWS Identity and Access Management (IAM).", "Deletes vault notifications based on given request, using AWS Identity and Access Management (IAM).", "Delete vault notifications using AWS Identity and Access Management (IAM).", "Deletes vault notifications based on a DeleteVaultNotificationsRequest. Access Control Using AWS Identity and Access Management (IAM)."]}
{"SampleId": 1459126, "Origin": "Verify that a named subquery exists for each INCLUDE.", "Reference": "Verify that a named subquery of solution set exists for each INCLUDE.", "LLMCandidates": ["Verify that a named subquery exists for each INCLUDE, considering exceptions and additional information from the given context.", "Verify that a named subquery exists for each INCLUDE using the given AST2BOpContext and NamedSubqueriesNode.", "Verify that a named subquery exists for each INCLUDE, considering the AST2BOpContext context.", "Verify that a named subquery exists for each INCLUDE, considering additional information from the AST2BOpContext and checking the presence of the solution set using the context.getSolutionSetStats(namedSet);", "Verify that a named subquery exists for each INCLUDE within the given context."]}
{"SampleId": 1435989, "Origin": "Make a copy of a range of bytes from the passed in data array.", "Reference": "Make a copy of a range of bytes from the passed in array.", "LLMCandidates": ["Make a copy of a range of bytes from the passed in data array using System.arraycopy.", "Make a copy of a range of bytes from the passed in data array, using System.arraycopy() to prevent unnecessary allocation and copying if the range is too large.", "Copy a range of bytes from an array into a new one.", "Make a copy of a range of bytes from the passed in data array, starting at index 'from' and ending at index 'to'.", "Make a copy of a range of bytes from the passed in data array."]}
{"SampleId": 5440918, "Origin": "Returns {@code true} if there is a value in the current thread's copy of\nthis thread-local variable, even if that values is {@code null}.", "Reference": "Returns {@code true} if there is a value in the current strand's copy of\nthis thread-local variable, even if that values is {@code null}.", "LLMCandidates": ["Returns {@code true} if there is a value in the current thread's copy of this thread-local variable, even if that values is {@code null}.", "Returns {@code true} if there is a value in the current Strand's copy of this thread-local variable, even if that values is {@code null}.", "Returns {@code true} if there is a value in the current Strand's copy of this thread-local variable, even if that values is {@code null}.", "Returns {@code true} if there is a value in the current thread's copy of this thread-local variable, even if that values is {@code null}.", "Returns {@code true} if there is a value in the current Strand's copy of this thread-local variable, even if that values is {@code null}."]}
{"SampleId": 3678109, "Origin": "Applications should use the {@code with(WithAdjuster)} method on the\ndate-time object to make the adjustment passing this as the argument.", "Reference": "Applications should use the {@code with(TemporalAdjuster)} method on the\ndate-time object to make the adjustment passing this as the argument.", "LLMCandidates": ["Applications should use the {@code adjustInto(WithAdjuster)} method on the date-time object to make the adjustment passing this as the argument.", "Applications should use the {@code adjustInto(Adjuster)} method on the date-time object to make the adjustment passing this as the argument.", "Applications should use the {@code adjustInto(WithAdjuster)} method on the date-time object to make the adjustment passing this as the argument.", "Applications should use the {@code adjustInto(WithAdjuster)} method on the date-time object to make the adjustment passing this as the argument.", "Applications should use the {@code adjustInto(WithAdjuster)} method on the date-time object to make the adjustment passing this as the argument."]}
{"SampleId": 4386719, "Origin": "Glacier provides you a unique archive ID, an opaque string of\ncharacters.", "Reference": "Amazon Glacier\nprovides you a unique archive ID, an opaque string of characters.", "LLMCandidates": ["Initiates a job using the provided request object, creating an ExecutionContext and setting AWSRequestMetrics before marshalling the request, invoking the operation, and returning the result.", "This initiates a job using an InitiateJobRequest object, and returns an InitiateJobResult as the AWS response. It uses ExecutionContext and AWSRequestMetrics to track client execution time and request metrics.", "This method initializes a job using an InitiateJobRequest object and returns the result of the job initialization. It creates an ExecutionContext with AWSRequestMetrics for tracking metrics and marshals the request before invoking it. Afterwards, it unmarshalls the response and returns the AWSResponse.", "Initiates a job using the provided InitiateJobRequest. The method uses an ExecutionContext to handle request metrics and invokes a service to initiate the job. It returns the AWS response in the form of an InitiateJobResult.", "This method initiates a job using an InitiateJobRequest and returns an InitiateJobResult. The request is marshalled with AWSRequestMetrics bound to it. Then, the request is sent with a JSON response handler and AWS execution context for processing. After processing, the result is returned as an AmazonWebServiceResponse<InitiateJobResult>."]}
{"SampleId": 2701561, "Origin": "Set Zu ber.", "Reference": "Set Zu berechn.", "LLMCandidates": ["Sets the value for QtyToInvoiceInPriceUOM attribute.", "Set the QtyToInvoiceInPriceUOM in the record.", "Set the QtyToInvoiceInPriceUOM in the record.", "@Override public void setQtyToInvoiceInPriceUOM (java.math.BigDecimal QtyToInvoiceInPriceUOM)} Set the quantity to invoice in price UOM.", "Set the value of Quantity to Invoice in Price Unit of Measure."]}
{"SampleId": 5440227, "Origin": "This method must only be used for type references\nwhose sort is {@link #EXCEPTION_PARAMETER EXCEPTION_PARAMETER} .", "Reference": "This method must\nonly be used for type references whose sort is {@link #EXCEPTION_PARAMETER} .", "LLMCandidates": ["This method must only be used for type references whose sort is {@link #EXCEPTION_PARAMETER EXCEPTION_PARAMETER} .", "This method must only be used for type references whose sort is {@link #EXCEPTION_PARAMETER EXCEPTION_PARAMETER} .", "This method must only be used for type references whose sort is {@link #EXCEPTION_PARAMETER EXCEPTION_PARAMETER} .", "This method must only be used for type references whose sort is {@link #EXCEPTION_PARAMETER EXCEPTION_PARAMETER} .", "This method must only be used for type references whose sort is {@link #EXCEPTION_PARAMETER EXCEPTION_PARAMETER} ."]}
{"SampleId": 2393774, "Origin": "See {@link ClientsClassDefinition#getWhitelistedProperties()}", "Reference": "See {@link ClientsClassDefinition#getIncludedProperties()}", "LLMCandidates": ["See {@link ClientsClassDefinition#getIncludedProperties()", "See {@link ClientsClassDefinition#getIncludedProperties()", "See {@link ClientsClassDefinition#getIncludedProperties()", "See {@link ClientsClassDefinition#getIncludedProperties()", "See {@link ClientsClassDefinition#getIncludedProperties()"]}
{"SampleId": 2230496, "Origin": "Ensures that the quorum is present if the quorum is configured and the operation service is quorum aware.", "Reference": "Ensures that there is no split brain if the split brain protection is configured and the operation\nservice is split brain protection aware.", "LLMCandidates": ["Ensures that there is no split brain if the split brain protection is configured and the operation service is aware of it.", "Ensures that no split brain is detected if split brain protection is configured and the operation service is quorum aware.", "Ensures that no split brain is detected if split brain protection is configured and the operation service is quorum aware.", "Ensures that there is no split brain scenario if the Split Brain Protection is configured and the operation service is aware of it.", "Ensures that the quorum is present if the quorum is configured and the operation service is aware of split brain."]}
{"SampleId": 4477703, "Origin": "Sets the {@link RetryPolicy} that is used when each request is sent.", "Reference": "Sets the {@link HttpPipelinePolicy} that is used when each request is sent.", "LLMCandidates": ["Sets the {@link HttpPipelinePolicy} that is used when each request is sent.", "Sets the {@link HttpPipelinePolicy} that is used when each request is sent.", "Sets the {@link HttpPipelinePolicy} that is used when each request is sent.", "Sets the {@link HttpPipelinePolicy} that is used when each request is sent.", "Sets the {@link HttpPipelinePolicy} that is used when each request is sent."]}
{"SampleId": 1842058, "Origin": "Provides the location to dockerfile", "Reference": "Provides the location to devfile yaml file", "LLMCandidates": ["Provides the location to devfile", "Provides the location to devfile", "Provides the location to devfile", "Provides the location to devfile", "Provides the location to devfile"]}
{"SampleId": 2113430, "Origin": "For a split parent package this will include enriching with siblings, if checkForSplitSiblings is true\nin which case the enriched (split) binding will be returned.", "Reference": "For a split parent package this will include potentially enriching with siblings,\nin which case the enriched (split) binding will be returned.", "LLMCandidates": ["For a split parent package this will include enriching with siblings if checkForSplitSiblings is true in which case the enriched (split) binding will be returned.", "For a split parent package this will include enriching with siblings if checkForSplitSiblings is true in which case the enriched (split) binding will be returned.", "For a split parent package this will include enriching with siblings. In case checkForSplitSiblings is true, the method returns the enriched (split) binding.", "For a split parent package this will include enriching with siblings, if checkForSplitSiblings is true in which case the enriched (split) binding will be returned.", "For a split parent package this will include enriching with siblings if checkForSplitSiblings is true in which case the enriched (split) binding will be returned."]}
{"SampleId": 402718, "Origin": "Gets all of the {@link AlertDefinition}s that exist on the path for\n{@link Components#AMBARI_SERVER}.", "Reference": "Gets all of the {@link AlertDefinition}s that exist on the path for\n{@link RootComponent#AMBARI_SERVER}.", "LLMCandidates": ["Gets all of the {@link AlertDefinition}s that exist on the path for \n{@link RootComponent#AMBARI_SERVER}.", "Gets all of the {@link AlertDefinition}s that exist on the path for {@link RootComponent#AMBARI_SERVER}.", "Gets all of the {@link AlertDefinition}s that exist on the path for\n{@link RootComponent#AMBARI_SERVER}.", "Gets all of the {@link AlertDefinition}s that exist on the path for {@link RootComponent#AMBARI_SERVER}.", "Gets all of the {@link AlertDefinition}s that exist on the path for {@link RootComponent#AMBARI_SERVER}."]}
{"SampleId": 4386724, "Origin": "Glacier, you first initiate a job, and after the job completes, you\ndownload the data.", "Reference": "To retrieve an archive or retrieve a vault inventory from Amazon Glacier,\nyou first initiate a job, and after the job completes, you download the\ndata.", "LLMCandidates": ["This method is used for listing jobs with a given input request, creating an execution context and AWS request metrics, marshalling the request, invoking the API, and returning the response.", "List jobs, downloading data after job completion.", "List jobs, downloading data after job completion.", "List jobs and manage their execution.", "List jobs and manage their execution."]}
{"SampleId": 2223749, "Origin": "derive secret key by PBKDF2 algorithm (1000 iterations of SHA256)", "Reference": "Derive secret key by PBKDF2 algorithm (1000 iterations of SHA256)", "LLMCandidates": ["derive secret key by PBKDF2 algorithm (1000 iterations of SHA256) using given password and fileKey", "derive secret key by PBKDF2 algorithm (1000 iterations of SHA256), using fileKey instead of password.", "derive secret key by PBKDF2 algorithm (1000 iterations of SHA256 using a file key instead of a password)", "derive secret key by PBKDF2 algorithm (1000 iterations of SHA256), using fileKey instead of password", "derive secret key by PBKDF2 algorithm (1000 iterations of SHA256) using a different password or fileKey"]}
{"SampleId": 3105252, "Origin": "Convert statistics object into JSONObject.", "Reference": "Convert statistics object into JSON.", "LLMCandidates": ["Convert statistics object into JSONString.", "Convert statistics object into JSON format using ObjectMapper.", "Convert statistics object into JSON format using ObjectMapper.", "Converts statistics object into a JSON string using an ObjectMapper.", "Converts statistics object into a JSON string using an ObjectMapper."]}
{"SampleId": 4404105, "Origin": "NOTE:This operation is eventually consistent.", "Reference": "This operation is eventually consistent.", "LLMCandidates": ["Deprecate the selected workflow type in an eventually consistent manner.", "This operation is eventually consistent.", "This operation is eventually consistent.", "This operation is eventually consistent.", "This operation is eventually consistent."]}
{"SampleId": 4776216, "Origin": "Gets a Vector pointing in the direction that this Location is facing", "Reference": "Gets a unit-vector pointing in the direction that this Location is\nfacing.", "LLMCandidates": ["Gets a Vector pointing in the direction that this Location is facing using updated trigonometric calculations.", "Gets a Vector pointing in the direction that this Location is facing, using Yaw and Pitch angles to compute the X and Z components of the Vector.", "Gets a Vector pointing in the direction that this Location is facing using the rotation values of Yaw and Pitch.", "Gets a Vector pointing in the direction that this Location is facing. Calculates the components of the direction vector from the pitch and yaw rotations.", "Calculates a Vector representing the direction this Location is facing based on its Yaw and Pitch angles."]}
{"SampleId": 6049496, "Origin": "or throws a {@link com.liferay.so.NoSuchMemberRequestException} if it could not be found.", "Reference": "or throws a {@link NoSuchMemberRequestException} if it could not be found.", "LLMCandidates": ["Finds the MemberRequest by its key or throws a {@link com.liferay.so.NoSuchMemberRequestException} if it could not be found.", "Finds the MemberRequest by its key or throws a {@link com.liferay.so.NoSuchMemberRequestException} if it could not be found.", "Finds a MemberRequest object by its key. If it could not be found, throws a {@link com.liferay.so.NoSuchMemberRequestException}.", "Find a MemberRequest by key, or throws a {@link com.liferay.so.NoSuchMemberRequestException} if it could not be found.", "Find a MemberRequest with the specified key or throws a {@link com.liferay.so.NoSuchMemberRequestException} if it could not be found."]}
{"SampleId": 2647087, "Origin": "Given a bunch of NodeRefs, create SimpleFeatures from the results.", "Reference": "Given a bunch of NodeRefs, create Features from the results.", "LLMCandidates": ["Given a bunch of NodeRefs, create features from the results using the given schema and geometry factory.", "Given a bunch of NodeRefs, create Features from the results.", "Create SimpleFeatures from NodeRefs provided by refs. The function used to build features is modified to use the FeatureBuilder with a new constructor and the Function interface. The resulting feature is created using the nativeType and typeNameOverride parameters, along with the object information extracted from the given NodeRef.", "Given a bunch of NodeRefs, create Features from the results.", "Given a bunch of NodeRefs, create Features from the results with a specific schema and name override."]}
{"SampleId": 2706905, "Origin": "Get Import Account.", "Reference": "Get Import - Kontendefinition.", "LLMCandidates": ["Get I_ElementValue_ID", "Retrieves the value of I_ElementValue_ID column from the record and returns its integer representation. This method can be overridden to provide a specific implementation for this attribute.", "Get Import Account ID", "Get Import Account ID", "Get Import Account ID"]}
{"SampleId": 3082050, "Origin": "For adding classpath elements that are not normally on the classpath in the Java version: svm\njars, truffle jars etc.", "Reference": "For adding classpath elements that are only on the classpath in the context of native-image\nbuilding.", "LLMCandidates": ["For adding classpath elements that are not normally on the classpath in the Java version: svm jars, truffle jars etc., this method is used to add specific paths to the image provided classpath.", "For adding classpath elements that are not normally on the Java version's classpath, such as SVM jars and Truffle jars.", "For adding classpath elements that are not normally on the classpath in the Java version: svm jars, truffle jars etc., where imageClasspath and customImageClasspath are empty.", "For adding classpath elements that are not normally on the classpath in the Java version: svm jars, truffle jars etc., it is important to ensure no other imageClasspath or customImageClasspath elements are present before proceeding.", "For adding classpath elements that are not normally on the classpath in the Java version: svm jars, truffle jars etc., using a method to process manifest main attributes and another one for the native image meta-inf."]}
{"SampleId": 1142556, "Origin": "Create a GeoCircle of the right kind given the specified bounds.", "Reference": "Create a GeoCircle from a center and a cutoff angle.", "LLMCandidates": ["Create a GeoCircle of the right kind given the specified bounds using cutoffAngle.", "Create a GeoCircle of the right kind given the specified cutoff angle.", "Create a GeoCircle of the right kind given the specified bounds with the new parameter cutoffAngle.", "Create a GeoCircle with given bounds and cutoffAngle. If the cutoff angle is below the minimum angular resolution, return a GeoDegeneratePoint, otherwise return a GeoStandardCircle.", "Create a GeoCircle of the right kind given the specified bounds using the cutoffAngle argument instead of radius."]}
{"SampleId": 5630009, "Origin": "Set the nodeType.", "Reference": "Set the newType.", "LLMCandidates": ["Set the newType.", "Set the newType.", "Set the newType.", "Set the newType.", "Set the newType."]}
{"SampleId": 1134393, "Origin": "Sets a new value by changing the offset and docID.", "Reference": "Sets a new value by changing the offset.", "LLMCandidates": ["Sets a new value by changing the offset only.", "Sets a new offset by changing its value for packedValue and packedValueDocID.", "Sets a new offset by changing its value for packedValue and packedValueDocID.", "Sets a new value by changing the offset and packedValueDocID.offset.", "Sets a new value by changing the offset and packedValueDocID.offset."]}
{"SampleId": 2241419, "Origin": "The MD5 hash of the file.", "Reference": "The hash of the file.", "LLMCandidates": ["The ContentHash of the file.", "The hash of the content.", "The content hash of the file.", "The content hash of the file.", "The content hash of the file."]}
{"SampleId": 5632363, "Origin": "Creates a list of default files to check for credentials.", "Reference": "Creates a list of files to check for credentials.", "LLMCandidates": ["Gets a list of files to check for credentials by adding user-specified path, default paths on different operating systems, and the project directory.", "Retrieves a list of default files to check for credentials by considering user-specified paths and default locations based on environment variables.", "Creates a list of default files to check for credentials, considering the user-specified path if provided.", "Creates a list of files to check for credentials based on user input or default locations.", "Finds a list of files to check for credentials based on default locations and user-specified path."]}
{"SampleId": 6018464, "Origin": "Sets each pixel in the output image to sgn*log( 1 + sgn*input(x,y)) of the input image.", "Reference": "Sets each pixel in the output image to sgn*log( val + sgn*input(x,y)) of the input image.", "LLMCandidates": ["Sets each pixel in the output image to sgn*log( 1 + sgn*input(x,y)) of the input image, with an additional argument for a scaling value val.", "Sets each pixel in the output image to sgn*log( 1 + sgn*input(x,y)) of the input image with an additional double value for scaling purposes.", "Sets each pixel in the output image to sgn*log( 1 + sgn*input(x,y)) of the input image with an additional parameter val for scaling the log operation.", "Sets each pixel in the output image to sgn*log( 1 + sgn*input(x,y)) of the input image with an additional argument for scaling the log result.", "Sets each pixel in the output image to sgn*log( 1 + sgn*input(x,y)) of the input image, where val is a double value."]}
{"SampleId": 4396523, "Origin": "Returns a string representation of this object; useful for testing and debugging.", "Reference": "Returns a string representation of this object.", "LLMCandidates": ["Returns a string representation of this object; useful for testing and debugging with password redacted as ***Sensitive Data Redacted*** for security reasons.", "Returns a string representation of this object; useful for testing and debugging, with sensitive data such as password being redacted.", "Returns a string representation of this object; useful for testing and debugging with sensitive data redacted when necessary.", "Returns a string representation of this object; useful for testing and debugging. Redacts sensitive data such as passwords with \"***Sensitive Data Redacted***\".", "Returns a string representation of this object; useful for testing and debugging with sensitive data redacted."]}
{"SampleId": 5454801, "Origin": "The entries in the file are assumed to be the\n    fully-qualified binary names of provider classes.", "Reference": "The entries in the file are assumed to be the fully-qualified\n    class names of provider classes.", "LLMCandidates": ["The entries in the file are assumed to be the fully-qualified binary names of provider classes, which are used to find modules by their names or all available modules.", "The entries in the file are assumed to be the fully-qualified binary names of provider classes and used to create a ModuleFinder object.", "The entries in the file are assumed to be the fully-qualified binary names of provider classes. If there are no entries, an empty ModuleFinder is returned.", "The entries in the file are assumed to be the fully-qualified binary names of provider classes.", "The entries in the file are assumed to be the fully-qualified binary names of provider classes."]}
{"SampleId": 3296178, "Origin": "The key for a max value, or null if everything is NaN (no max).", "Reference": "The key for a max value; null if empty or everything is NaN (no max).", "LLMCandidates": ["The key for a max value or null if everything is NaN (no max).", "The key for a max value, or null if everything is NaN (no max).", "The key for a max value or null if everything is NaN (no max).", "The key for a max value or null if everything is NaN (no max).", "The key for a max value, or null if everything is ASCII (no max)."]}
{"SampleId": 3773833, "Origin": "Gets the editor component generator for this Column.", "Reference": "Gets the grid that this column belongs to.", "LLMCandidates": ["Gets the grid for this Column.", "Retrieves the grid parent for this object.", "Gets the parent grid for this Column.", "Gets the parent grid for this Column.", "Gets the parent grid for this Column."]}
{"SampleId": 3156674, "Origin": "Whenever a minion with Deathrattle is summoned, gain +1/+1", "Reference": "Whenever a minion with Deathrattle is summoned, gain +1 Attack", "LLMCandidates": ["Whenever a minion with Deathrattle is summoned, gain +1 Attack.", "Whenever a minion with Deathrattle is summoned, gain +1 Attack.", "Whenever a minion with Deathrattle is summoned, gain +1 Attack.", "Whenever a minion with Deathrattle is summoned, gain +1 attack.", "Whenever a minion with Deathrattle is summoned, gain +1 attack."]}
{"SampleId": 2916283, "Origin": "Gets the Ibor index.", "Reference": "Gets the name of the volatilities.", "LLMCandidates": ["Gets the IborCapletFloorletVolatilitiesName.", "Gets the Ibor Caplet Floorlet Volatilities Name.", "Gets the Ibor Caplet Floorlet Volatilities Name.", "Gets the Ibor Caplet Floorlet Volatilities Name.", "Gets the IborCapletFloorletVolatilitiesName volatilities name."]}
{"SampleId": 2913740, "Origin": "Obtains an instance from the specified unique name.", "Reference": "Obtains an instance from the specified name.", "LLMCandidates": ["Creates an instance of EtdOptionType from the specified string name using the static NAMES.parse method.", "Obtains an instance from the specified name using a given mapping.", "Obtains an instance from the specified name using a given mapping.", "Obtains an instance from the specified name by parsing it using NAMES.", "Obtains an instance from the specified name."]}
{"SampleId": 6219026, "Origin": "Returns a {@link Date} representing the date of the last checkpoint before the given block height, for example, normally\nyou would want to know the checkpoint before the last block the wallet had seen.", "Reference": "Returns a {@link StoredBlock} representing the last checkpoint before the given block height, for example, normally\nyou would want to know the checkpoint before the last block the wallet had seen.", "LLMCandidates": ["Returns a {@link StoredBlock} representing the checkpoint before or at the given height, for example, you would normally want to know the checkpoint before the last block the wallet had seen.", "Returns a {@link StoredBlock} representing the last checkpoint before the given block height, for example, normally you would want to know the checkpoint before the last block the wallet had seen.", "Returns a {@link StoredBlock} representing the last checkpoint before the given block height, for example, normally you would want to know the checkpoint before the last block the wallet had seen.", "Returns a {@link StoredBlock} representing the checkpoint before or at the given block height, allowing to find the last checkpoint before the specified height in the list of checkpoints.", "This method returns a {@link StoredBlock} representing the last checkpoint before or at the given block height."]}
{"SampleId": 2783374, "Origin": "Deletes the specified variable from the configuration.", "Reference": "Deletes the specified variable from the CONFIGURATION.", "LLMCandidates": ["Deletes the specified variable from the CONFIGURATION object.", "Removes the specified variable from the configuration.", "Removes the specified variable from the configuration.", "Deletes the specified variable from the CONFIGURATION.", "Deletes the specified variable from the CONFIGURATION."]}
{"SampleId": 2624222, "Origin": "Configures SSL or TLS of the default {@link VirtualHost} from the specified {@code keyManagerFactory}\nand {@code tlsCustomizer}.", "Reference": "Configures SSL or TLS of the {@link Server} from the specified {@code keyManagerFactory}\nand {@code tlsCustomizer}.", "LLMCandidates": ["Configures SSL or TLS of the default {@link VirtualHost} from the specified {@code keyManagerFactory} and {@code tlsCustomizer}.", "Configures SSL or TLS of the default {@link VirtualHost} from the specified {@code keyManagerFactory} and {@code tlsCustomizer}.", "Configures SSL or TLS of the default {@link VirtualHost} from the specified {@code keyManagerFactory} and {@code tlsCustomizer}.", "Configures SSL or TLS of the default {@link VirtualHost} from the specified {@code keyManagerFactory} and {@code tlsCustomizer}.", "Configures SSL or TLS of the default {@link VirtualHost} from the specified {@code keyManagerFactory} and {@code tlsCustomizer}."]}
{"SampleId": 234560, "Origin": "If it fails, an exception is thrown and the read lock will not be locked.", "Reference": "If the reinitialization fails, an exception is thrown.", "LLMCandidates": ["If it fails, an exception is thrown and the read lock will not be locked.", "The function acquires a resource for blocking reinitialization. If it fails, an exception is thrown and the resource will not be acquired.", "If it fails, an exception is thrown and the resource will not be acquired.", "If it fails, an exception is thrown and the resource will not be acquired.", "Acquire a read lock resource if the exception is not present; otherwise, throw the exception and do not acquire the read lock."]}
{"SampleId": 6272767, "Origin": "Returns true if the specified String name, is found within JsonArray checks.", "Reference": "Returns true if the expectedName, is found within JsonArray checks.", "LLMCandidates": ["Returns true if the specified String expectedName is found within JsonArray checks.", "Returns true if the specified String expectedName is found within JsonArray checks.", "Returns true if the specified String expectedName is found within JsonArray checks.", "Returns true if the specified String expectedName is found within JsonArray checks.", "Returns true if the specified String name, is found within JsonArray checks with a different input variable \"expectedName\" instead of \"name\"."]}
{"SampleId": 4232775, "Origin": "Create a new {@link ICrypter} for the given context.", "Reference": "Create a new {@link ICrypter}.", "LLMCandidates": ["Return a new {@link ICrypter} instance without specifying the context.", "Create a new {@link ICrypter} without the given context.", "Create a new {@link ICrypter} without the given context.", "Create a new {@link ICrypter} without context.", "Create a new {@link ICrypter} without context."]}
{"SampleId": 3923667, "Origin": "Produces a Collapsed SemanticGraph with no extras.", "Reference": "Produces a Collapsed SemanticGraph.", "LLMCandidates": ["Produces a Collapsed SemanticGraph with no extras. However, this method is deprecated.", "Deprecated method that produces a Collapsed SemanticGraph with no extras.", "Generate a collapsed SemanticGraph with no extras.", "Generate a collapsed SemanticGraph with no extras.", "Produces a Collapsed SemanticGraph with no extras. This method is now deprecated."]}
{"SampleId": 3221596, "Origin": "WorkItemLifecycleEvent} and calls the {@link #publish(WorkItemLifecycleEvent)} method", "Reference": "WorkItemLifecycleEvent} and calls the {@link #publish(IWorkItemLifecycleEvent)} method", "LLMCandidates": ["Builds an IWorkItemLifecycleEvent object by calling createEvent() and passing it workItemUid, details extracted from a map, WorkItemLifecyclePhase, lifecycleDetails, and sourceTimestamp. Then, calls the {@link #publish(IWorkItemLifecycleEvent)} method with the created event.", "Build the initial value by adding 8 to n.", "Build the initial value by adding 8 to n.", "Build the initial value by adding 8 to n.", "Build the initial value by adding 8 to n."]}
{"SampleId": 3512230, "Origin": "Gets the {@link Value.Mutable} for the {@link Keys#LLAMA_VARIANT llama variant}.", "Reference": "Gets the {@link Value.Mutable} for the {@link LlamaType} of this\n{@link Llama}.", "LLMCandidates": ["Gets the {@link Value.Mutable} for the {@link Keys#LLAMA_TYPE llama type}.", "Gets the {@link Value.Mutable} for the {@link Keys#LLAMA_TYPE llama type}.", "Gets the {@link Value.Mutable} for the {@link Keys#LLAMA_TYPE llama type}.", "Gets the {@link Value.Mutable} for the {@link Keys#LLAMA_TYPE llama type}.", "Gets the {@link Value.Mutable} for the {@link Keys#LLAMA_TYPE llama type}."]}
{"SampleId": 4850294, "Origin": "Set a new {@link JacksonResourceProvider} to this builder, dedicated to provide an {@link ObjectMapper} for\nserialization and deserialization of data.", "Reference": "Set a new {@link JacksonResources} to this builder, dedicated to provide an {@link ObjectMapper} for\nserialization and deserialization of data.", "LLMCandidates": ["Set a new {@link JacksonResources} to this builder, dedicated to provide an {@link ObjectMapper} for serialization and deserialization of data.", "Set a new {@link JacksonResources} to this builder, dedicated to provide an {@link ObjectMapper} for serialization and deserialization of data.", "Set a new {@link JacksonResources} to this builder, dedicated to provide an {@link ObjectMapper} for serialization and deserialization of data.", "Set a new {@link JacksonResources} to this builder, dedicated to provide an {@link ObjectMapper} for serialization and deserialization of data.", "Set a new {@link JacksonResources} to this builder, dedicated to provide an {@link ObjectMapper} for serialization and deserialization of data."]}
{"SampleId": 5631112, "Origin": "Lists a feedback entry with a specified `feedback_id`.", "Reference": "Gets a feedback entry with a specified `feedback_id`.", "LLMCandidates": ["Lists a feedback entry with a specified `feedback_id` using provided options.", "Lists a feedback entry with a specified `feedback_id`. If a model is provided, it is included in the query parameter. The response format is set to application/json and additional headers are added for authentication purposes.", "Lists a feedback entry with a specified `feedback_id` and returns it as an object of type GetFeedback.", "Lists a feedback entry with a specified `feedback_id` using a specific model if provided.", "Lists a feedback entry with a specified `feedback_id`. The updated code modifies the ResponseConverterUtils.getObject method to use a generic type instead of specifying the concrete class GetFeedback in order to be more flexible."]}
{"SampleId": 5459588, "Origin": "Adds an export.", "Reference": "Sets module opens.", "LLMCandidates": ["Adds an exported package name.", "Adds an opens configuration.", "Adds an opens configuration.", "Adds an export definition for a list of opens.", "Adds an export definition for a list of opens."]}
{"SampleId": 1837504, "Origin": "If the new address is {@code null}, a pending flight is cancelled and an\nongoing handshake is failed.", "Reference": "If the new address is {@code null}, an ongoing handshake is failed.", "LLMCandidates": ["Updates the peerAddress attribute and checks if an establishedSession is present. If it exists, updates its peer address; otherwise, checks if the new peerAddress is null and cancels any pending flight and fails any ongoing handshake with an IOException. If the peerAddress is not null but no established session is present, an IllegalArgumentException is thrown as it is not supported in this method.", "If the new address is {@code null}, a pending flight is cancelled and an ongoing handshake is failed; otherwise, an IllegalArgumentException is thrown if there's no established session.", "The updated comment is as follows: \"Updates the peer address. If the new address is {@code null}, a pending flight is cancelled and an ongoing handshake is failed unless an established session is available.", "If the new address is {@code null}, a pending flight is cancelled and an ongoing handshake is failed. If the updated code has no establishedSession, then an IllegalArgumentException is thrown.", "If the new address is {@code null}, a pending flight is cancelled and an ongoing handshake is failed; otherwise, it throws an IllegalArgumentException if there's no established session."]}
{"SampleId": 2624576, "Origin": "Binds the specified {@link Service} at the specified path pattern.", "Reference": "Binds the specified {@link HttpService} at the specified path pattern.", "LLMCandidates": ["Binds the specified {@link HttpService} at the specified path pattern.", "Binds the specified {@link HttpService} at the specified path pattern.", "Binds the specified {@link HttpService} at the specified path pattern.", "Binds the specified {@link HttpService} at the specified path pattern.", "Binds the specified {@link HttpService} at the specified path pattern."]}
{"SampleId": 2823477, "Origin": "Maps all index descriptors according to {@link #indexReference(IndexDescriptor2)}.", "Reference": "Maps all index descriptors according to {@link #indexReference(IndexDescriptor)}.", "LLMCandidates": ["Maps all index descriptors according to {@link #indexReference(IndexDescriptor)}.", "Maps all index descriptors according to {@link #indexReference(IndexDescriptor)}.", "Maps all index descriptors according to {@link #indexReference(IndexDescriptor)}.", "Maps all index descriptors according to {@link #indexReference(IndexDescriptor)}.", "Maps all index descriptors according to {@link #indexReference(IndexDescriptor)}."]}
{"SampleId": 2482288, "Origin": "Queries this contact source for the given queryString.", "Reference": "Creates query for the given queryString.", "LLMCandidates": ["Queries this contact source for the given queryString and specified cache.", "Queries this contact source for the given queryString, optionally specifying the number of results to retrieve (-1 means all results).", "Queries this contact source for the given queryString using a default value of -1 for any additional parameters.", "Queries this contact source for the given queryString with a default value of -1.", "Creates a ContactQuery for the given queryString and optional limit parameter."]}
{"SampleId": 5425070, "Origin": "Get the next value.", "Reference": "Returns the next value from the input.", "LLMCandidates": ["Read the next value and return the result.", "Get the next value based on the JSON data type structure.", "Get the next value based on the JSON data type structure.", "Retrieve the next value according to different types of input data.", "Retrieve the next value according to different types of input data."]}
{"SampleId": 4624009, "Origin": "Normalizes the specified URL and creates a new instance of this class.", "Reference": "Normalizes the specified URI and creates a new instance of this class.", "LLMCandidates": ["Converts the specified URI and returns a new instance of IOFile class with the normalized path.", "Converts the specified URI to a file path by normalizing slashes and removing file scheme. If an exception occurs, return the original URI.", "Converts the specified URI into a local file path string by normalizing slashes and removing scheme if needed.", "Converts the given URL to a file path using conventional conversion or fallback methods if required.", "Converts the given URL to a file path using conventional conversion or fallback methods if required."]}
{"SampleId": 3467749, "Origin": "Makes the given visitor visit all of the instructions in this list.", "Reference": "Makes the given visitor visit all the instructions in this list.", "LLMCandidates": ["Visits all instructions in this list using the given visitor.", "Makes the given visitor visit all of the instructions in this list.", "Makes the given visitor visit all of the instructions in this list.", "Makes the given visitor visit all of the instructions in this list.", "Visits all instructions in this list by invoking the accept method on each instruction and passing the given MethodVisitor to process them."]}
{"SampleId": 4132919, "Origin": "Removes the trace associated with this CallableStatement\nfrom the Connection that created it.", "Reference": "Removes the trace associated with this CallableStatement from the", "LLMCandidates": ["Removes the trace associated with this CallableStatement from the Connection that created it.", "Removes the trace associated with this CallableStatement from the Connection that created it, and closes any open ResultSets.", "Removes the trace associated with this CallableStatement from the Connection that created it by setting closedInternal to true and removing the trace if needed. It also closes any open ResultSet's according to JDBC specification.", "Removes the trace associated with this CallableStatement from the Connection that created it. Closes any open ResultSet's as required by JDBC spec when the statement is closed.", "Removes the trace associated with this CallableStatement from the Connection that created it."]}
{"SampleId": 3380964, "Origin": "If you actual latency will be lower than \"desirableOperationLatency\",\nwill calculate the difference and use it as {@link BulkheadConfig}.maxWaitTime", "Reference": "If you actual latency will be lower than \"slowCallDurationThreshold\",\nwill calculate the difference and use it as {@link BulkheadConfig}.maxWaitTime", "LLMCandidates": ["public Builder<T> slowCallDurationThreshold(long desirableOperationLatency) {\n    if (desirableOperationLatency <= 0.0) {\n        throw new IllegalArgumentException(\"slowCallDurationThreshold must be a positive value greater than zero\");\n    }\n    config.desirableLatency = Duration.ofMillis(desirableOperationLatency);\n    return this;", "Sets the slow call duration threshold by using \"desirableOperationLatency\" as the latency value for the {@link BulkheadConfig}.", "Sets the slowCallDurationThreshold by defining \"desirableOperationLatency\" as a positive value greater than zero. If the actual latency is lower than this threshold, calculates the difference and uses it as {@link BulkheadConfig}.maxWaitTime.", "Set the desirable latency for slow call duration threshold by using \"slowCallDurationThreshold\" method. If you actual latency will be lower than \"desirableOperationLatency\", will calculate the difference and use it as {@link BulkheadConfig}.maxWaitTime.", "If the slowCallDurationThreshold is lower than \"desirableOperationLatency\", will calculate the difference and use it as {@link BulkheadConfig}.maxWaitTime"]}
{"SampleId": 1946076, "Origin": "Provide the implementation of the PlatformDecoder for the current platform using the provided", "Reference": "Provide the implementation of the PlatformDecoder for the current platform using the\nprovided PoolFactory", "LLMCandidates": ["This method creates a PlatformDecoder instance based on the current platform using provided PoolFactory and enabling direct WebP decoding if supported by the device.", "Build a PlatformDecoder using the given parameters and return it based on the current platform version. If the platform is LOLLIPOP or higher, create an ArtDecoder with flexible thread count. Otherwise, if directWebpDirectDecodingEnabled is true but the platform is GINGERBREAD or lower, use a GingerbreadPurgeableDecoder. If directWebpDirectDecodingEnabled is false or the platform is KITKAT or higher, use a KitKatPurgeableDecoder.", "Provide the implementation of the PlatformDecoder for the current platform using the provided PoolFactory and enabling direct WebP decoding if supported by the device.", "Provide the implementation of the PlatformDecoder for the current platform using the provided PoolFactory and directWebpDirectDecodingEnabled flags.", "Provide the implementation of the PlatformDecoder based on the current platform using the provided PoolFactory and enabling direct WebP decoding if supported."]}
{"SampleId": 1052905, "Origin": "add partition of buffer to consume", "Reference": "add whole buffer to consume", "LLMCandidates": ["Add data source from a QueueBuffer", "Add a data source from QueueBuffer", "Add a DataSource with QueueBuffer as the source buffer.", "Add a DataSource with QueueBuffer as the source buffer.", "Adds a data source from the given queue buffer to the list of data sources."]}
{"SampleId": 4713376, "Origin": "Rule a subsumes rule b, if a subsumes b\nAND\na has got least the same expected predictive accuracy as b.", "Reference": "The defintion\nof subsumption is: Rule a subsumes rule b, if a subsumes b AND a has got\nleast the same expected predictive accuracy as b.", "LLMCandidates": ["Rule a subsumes rule b if a has got least the same expected predictive accuracy as b and a's consequence is equal to b's consequence.", "Rule a subsumes rule b, if a has the same consequence as b AND a has got least the same expected predictive accuracy as b.", "Rule a subsumes rule b, if a has got at least the same expected predictive accuracy as b and their consequences are equal.", "Rule a subsumes rule b if a has got least the same expected predictive accuracy as b and a's consequence is equal to b's consequence.", "Rule a subsumes rule b if a has got at least the same expected predictive accuracy as b and their consequents are equal."]}
{"SampleId": 5433550, "Origin": "Do nothing if\n{@link BaseConfiguration#nocomment} is set to true.", "Reference": "Do nothing if\n{@link BaseOptions#noComment} is set to true.", "LLMCandidates": ["Build the initial value by adding 8 to n if {@link BaseConfiguration#noComment} is set to true.", "Build the initial value by adding 8 to n.", "Build the initial value by adding 8 to n if {link BaseConfiguration#noComment} is set to false.", "Do nothing if {@link BaseConfiguration#noComment} is set to true.", "Do nothing if {@link BaseConfiguration#noComment} is set to true."]}
{"SampleId": 361244, "Origin": "Saves all writable accounts and the default account, which can later be obtained\nwith {@link #getDefaultAccount}.", "Reference": "Saves the default account, which can later be obtained with {@link #getOnlyOrDefaultAccount}.", "LLMCandidates": ["Saves the default account which can later be obtained with {@link #getDefaultAccount}.", "Saves the default account, which can later be obtained with {@link #getDefaultAccount}.", "Saves the default account, which can later be obtained with {@link #getDefaultAccount}.", "Saves the default account only, which can later be obtained with {@link #getDefaultAccount}.", "Saves the default account only, which can later be obtained with {@link #getDefaultAccount}."]}
{"SampleId": 1531004, "Origin": "Returns the full set of traversal parameters specified on the command line, including parsed intervals without\nmerging intervals specified by the user on the command line.", "Reference": "Returns the full set of traversal intervals specified on the command line, including parsed intervals without\nmerging intervals specified by the user on the command line.", "LLMCandidates": ["Returns the full set of traversal parameters specified on the command line, including parsed intervals without merging intervals specified by the user on the command line.", "Returns the full set of traversal parameters specified on the command line, including parsed intervals without merging", "Returns a list of intervals without merging specified by the user on the command line. The method checks if the intervals are specified or not and throws an exception if they aren't. It then parses the intervals using GenomeLocParser with IntervalMergingRule.NONE and returns the converted SimpleIntervals for traversal purposes.", "This method returns a List of SimpleIntervals, representing the set of traversal parameters specified on the command line, including parsed intervals without merging", "Returns the full set of traversal parameters specified on the command line, including parsed intervals without merging intervals specified by the user on the command line. The method first checks if the intervals are specified, and throws an exception if not. Then it parses the intervals and returns a TraversalParameters object with the intervals for traversal."]}
{"SampleId": 4396524, "Origin": "Returns a string representation of this object; useful for testing and debugging.", "Reference": "Returns a string representation of this object.", "LLMCandidates": ["Returns a string representation of this object; useful for testing and debugging. The password value will be replaced with \"***Sensitive Data Redacted***\" for security reasons.", "Returns a string representation of this object; useful for testing and debugging; password information is redacted with '***Sensitive Data Redacted***' to protect privacy.", "Returns a string representation of this object; useful for testing and debugging; sensitive data is redacted by replacing it with \"***Sensitive Data Redacted***\".", "Returns a string representation of this object; useful for testing and debugging with sensitive data redacted when necessary.", "Returns a string representation of this object; useful for testing and debugging; password is replaced with '***Sensitive Data Redacted***'."]}
{"SampleId": 5433639, "Origin": "Sets {@link HtmlOptions#createOverview} field to true.", "Reference": "Sets {@code HtmlOptions.createOverview} field to true.", "LLMCandidates": ["Sets the createOverview field to true if noOverview is false and specific conditions are met.", "Sets the {@link HtmlOptions#createOverview} field to true if certain conditions are met.", "Sets the {@link HtmlOptions#createOverview} field to true if certain conditions are met, such as not disabling the overview option or having multiple modules or packages.", "Sets the {@link HtmlOptions#createOverview} field to true if specific conditions are met.", "Sets {@link HtmlOptions#createOverview} field to true if certain conditions are met."]}
{"SampleId": 4476930, "Origin": "This operation requires the {@code secrets/get} permission.", "Reference": "This operation requires the {@code secrets/delete} permission.", "LLMCandidates": ["This operation requires the {@code secrets/beginDeleteSecret} permission.", "This operation requires the {@code secrets/delete} permission.", "This operation requires the {@code secrets/delete} permission.", "This operation requires the {@code secrets/delete} permission.", "This operation requires the {@code secrets/delete} permission."]}
{"SampleId": 2443728, "Origin": "Binds a new instance {@link Descriptor} using the information from the Jersey descriptor {@link InstanceBeanDescriptor}.", "Reference": "Binds a new instance {@link Binding} using the information from the Jersey descriptor {@link InstanceBinding}.", "LLMCandidates": ["Binds a new instance {@link Descriptor} using the information from the Jersey descriptor {@link InstanceBeanDescriptor}. The method takes in a {@link ServiceLocator}, a {@link DynamicConfiguration}, an {@link ActiveDescriptor}, and a set of {@link AliasBinding}s. It then binds the active descriptor to the configuration, and for each alias binding, it creates a new alias and binds that as well.", "Binds a new instance {@link Descriptor} using the information from the Jersey descriptor {@link InstanceBeanDescriptor}, considering the change of aliases from {@link AliasDescriptor} to {@link AliasBinding}.", "Binds a new instance {@link Descriptor} using the information from the Jersey descriptor {@link ActiveDescriptor}.", "Binds a new instance {@link Descriptor} using the information from the Jersey descriptor {@link ActiveDescriptor}.", "Binds a new instance {@link Descriptor} using the information from the Jersey descriptor {@link ActiveDescriptor}."]}
{"SampleId": 6191403, "Origin": "The {@link MessagingExceptionHandler} configured on {@link MessageProcessorChain} or {@link FlowConstruct} will be used to\nhandle any errors that occur.", "Reference": "The {@link FlowExceptionHandler} configured on {@link MessageProcessorChain} or {@link FlowConstruct} will be used to handle\nany errors that occur.", "LLMCandidates": ["The {@link FlowExceptionHandler} configured on {@link MessageProcessorChain} or {@link FlowConstruct} will be used to handle any errors that occur.", "The {@link FlowExceptionHandler} configured on {@link MessageProcessorChain} or {@link FlowConstruct} will be used to handle any errors that occur.", "The {@link FlowExceptionHandler} configured on {@link MessageProcessorChain} or {@link FlowConstruct} will be used to handle any errors that occur.", "The {@link FlowExceptionHandler} configured on {@link MessageProcessorChain} or {@link FlowConstruct} will be used to handle any errors that occur.", "The {@link FlowExceptionHandler} configured on {@link MessageProcessorChain} or {@link FlowConstruct} will be used to handle any errors that occur."]}
{"SampleId": 708321, "Origin": "Adds a fatal exception to the message set and throws\nthe unit as a PhaseFailedException.", "Reference": "Adds an error to the message set and throws CompilationFailedException.", "LLMCandidates": ["Adds a fatal exception to the message set and throws the unit as a CompilationFailedException if there are errors.", "Adds a fatal exception to the message set and throws the unit as a PhaseFailedException using a final modifier for the message parameter.", "Adds a fatal exception to the message set and throws a CompilationFailedException if there are errors.", "Adds a fatal exception to the message set and throws the unit as a PhaseFailedException.", "Adds a fatal exception to the message set and throws the unit as a PhaseFailedException."]}
{"SampleId": 5245177, "Origin": "If the option to use a central repository has been selected, does not\nindicate the central repository is configured for use.", "Reference": "If the option to use a central repository has been selected, does not\nindicate the central repository is configured for use simply that the\ncheckbox allowing configuration is checked on the options panel.", "LLMCandidates": ["If the option to use a central repository has been selected, does not indicate that the central repository is enabled for use.", "If the option to use a central repository has been selected, does not indicate whether the central repository is configured for use.", "If the option to allow use of a central repository has been selected, it does not indicate that the central repository is enabled for use.", "If the option to use a central repository has been selected, it does not indicate the central repository is configured for use.", "Determines if the option to use a central repository is selected and indicates whether or not it has been configured for use. This method will typically be called alongside EamDb.isEnabled() to ensure that the selected type of central repository is not DISABLED."]}
{"SampleId": 1354136, "Origin": "Report the ending barline.", "Reference": "Report the ending PartBarline.", "LLMCandidates": ["Return the right part barline.", "Return the right part barline.", "Return the right part barline.", "Report the ending part barline.", "Report the ending part barline."]}
{"SampleId": 6006999, "Origin": "Add a series for a X-Y type chart using Lists with error bars", "Reference": "Add a series for a X-Y type chart using Lists", "LLMCandidates": ["Add a series for a X-Y type chart using Lists with error bars and considering data type conversion from List to DoubleArray for date or number types.", "Add a series for a X-Y type chart using Lists with error bars and data type conversion", "Add a series for a X-Y type chart using Lists with error bars and data types (Date or Number). This method uses the getDataType() helper method to determine the appropriate conversion of the input data. The series is then added to the seriesMap and returned.", "Add a series for a X-Y type chart using Lists with error bars and automatically detecting data types of input lists to handle date or number inputs accordingly.", "Add a series for a X-Y type chart using Lists with error bars and identifying data types."]}
{"SampleId": 4396496, "Origin": "Returns a string representation of this object; useful for testing and debugging.", "Reference": "Returns a string representation of this object.", "LLMCandidates": ["Returns a string representation of this object; useful for testing and debugging. If the AccessToken is not null, it will be included in the string with the value redacted. The AttributeName, if not null, will also be included in the string.", "Returns a string representation of this object; useful for testing and debugging, with sensitive data redacted.", "Returns a string representation of this object; useful for testing and debugging, with sensitive data redacted.", "Returns a string representation of this object; useful for testing and debugging with sensitive data redacted.", "Returns a string representation of this object; useful for testing and debugging while retaining sensitive data."]}
{"SampleId": 1606491, "Origin": "Get the hex color for the primary displayed usernote of a user", "Reference": "Get the color for the primary displayed usernote of a user", "LLMCandidates": ["Get the hex color for the primary displayed usernote of a user", "Get the hex color for the primary displayed usernote of a user", "Get the hex color for the primary displayed usernote of a user", "Get the hex color for the primary displayed usernote of a user. If there's a note with warning index from that user, return its corresponding color; otherwise, return the light gray color (0xFF808080).", "Get the hex color for the primary displayed usernote of a user"]}
{"SampleId": 2542310, "Origin": "Rotate this vector the specified radians about the given rotation axis.", "Reference": "Rotate this vector the specified radians around the given rotation axis.", "LLMCandidates": ["Rotate this vector the specified radians about the given rotation axis.", "Rotate this vector the specified radians about the given rotation axis.", "Rotate this vector the specified radians about the given rotation axis.", "Rotate this vector the specified radians about the given rotation axis.", "Rotate this vector the specified radians about the given rotation axis."]}
{"SampleId": 4245480, "Origin": "Does nothing if\nthe given node is currently not visible or target is .", "Reference": "Does nothing if\nthe given node is currently not visible or target is {@code null}.", "LLMCandidates": ["This method updates a node with the given 'node' argument when the target is not null. It first retrieves the model for the given node and visits all children of type Node, stopping when it finds a match between the current node's model and the provided node. Finally, it detaches the model from its previous source.", "Does nothing if the given node is currently not visible or target is .", "Update the node's visual representation if it is currently not visible and target is not null.", "Does nothing if the given node is not currently visible or target is.", "Does nothing if the given node is not currently visible or target is."]}
{"SampleId": 2014106, "Origin": "Tests that apply works.", "Reference": "See issue\n1683.", "LLMCandidates": ["Tests that numeric properties are frozen and not mutable after invoking freeze() method.", "Tests for the correct handling of numeric properties during freezing of objects.", "Tests the freezeNumerics functionality of an object descriptor.", "Tests the freezeNumerics functionality of an object descriptor.", "Tests that numeric properties can be frozen without issue."]}
{"SampleId": 5653269, "Origin": "Returns the value of the node as a module identifier, or null if the node is undefined.", "Reference": "Returns the value of the node as a module identifier.", "LLMCandidates": ["Returns a ModuleIdentifier object by parsing the given ModelNode value as a string.", "Converts a ModelNode value into a ModuleIdentifier by parsing its string representation.", "Converts the ModelNode value into a ModuleIdentifier if possible, otherwise returns null.", "Converts a ModelNode value into a ModuleIdentifier object by parsing its string representation.", "Converts a ModelNode value into a ModuleIdentifier object by parsing its string representation."]}
{"SampleId": 4615504, "Origin": "Returns a lightweight, low-level preceding-sibling axis iterator.", "Reference": "Returns a light-weight, low-level preceding-sibling axis iterator.", "LLMCandidates": ["Returns a lightweight, low-level preceding-sibling axis iterator for child nodes of the current node.", "Returns an iterator for the preceding sibling nodes. This method creates a lightweight and low-level iterator for locating the preceding sibling node in an XML document. It returns null if there are no more siblings to iterate through. The type of the node is checked, and the parent node's children are examined to locate the preceding sibling nodes.", "Returns a lightweight, low-level preceding-sibling axis iterator using childIter() instead of children().", "Returns a lightweight, low-level preceding-sibling axis iterator using childIter() instead of children().", "Returns a lightweight, low-level preceding-sibling axis iterator with childIter() method."]}
{"SampleId": 1879788, "Origin": "Testing the normalize(Vector) and normalizeEquals(Vector) methods of the VMath class.", "Reference": "Testing the normalizeVector) and normalizeEquals(Vector) methods of the\n{@link VMath} class.", "LLMCandidates": ["This JUnit test checks if both normalize(Vector) and normalizeEquals(Vector) methods of VMath return a vector with length 1 by using the squareSum method instead of euclideanLength. It also ensures that they return the same vector, and that the normalize Vector multiplied by the Euclidean length of the original Vector is equal to the original vector.", "Testing the normalize(Vector) and normalizeEquals(Vector) methods of the VMath class to ensure that both return a vector with length 1, and that they return the same Vector and produce the correct result when multiplied by the original vector's euclidean length.", "Testing the normalize(Vector) and normalizeEquals(Vector) methods of the VMath class by ensuring they return a vector with length 1 and checking that both methods return the same Vector, as well as verifying that the resulting normalization Vector times the euclidean length of the original Vector equals the original vector.", "Testing the normalize(Vector) and normalizeEquals(Vector) methods of the VMath class to ensure they return a vector with length 1 and are consistent between the two methods. Additionally, verify that the normalized vectors can be used to reconstruct the original vector by multiplying them with their respective euclidean lengths.", "Testing the normalize(Vector) and normalizeEquals(Vector) methods of the VMath class, using squareSum and euclideanLength methods to ensure correctness."]}
{"SampleId": 1390765, "Origin": "Adds a 'followingUser' type notification with the specified request json object.", "Reference": "Adds a 'following - user' type notification with the specified request json object.", "LLMCandidates": ["Adds a 'following_user' type notification with the specified request json object.", "Adds a 'following_user' type notification with the specified request json object.", "Adds a 'following_user' type notification with the specified request json object.", "Adds a 'following_user' type notification with the specified request JSONObject.", "Adds a 'following_user' type notification with the specified request json object."]}
{"SampleId": 3964762, "Origin": "Turn a toX of Either3 into a single Either with Lists of values.", "Reference": "Turn an IterableX of Either3 into a single Either with Lists of values.", "LLMCandidates": ["Turn a collection of Either3 into a single Either with ReactiveSeq of values.", "Convert a collection of Either3 values into a single Either with ListX values from the right sides of the Either3 instances.", "Turn a stream of Either3 of type LT1, LT2 and PT into a single Either with a list of values of type LT1, LT2 and ListX<PT> respectively.", "Convert a sequence of Either3 into a single Either with Lists of values using an IterableX of Either3s.", "Convert a sequence of Either3 into a single Either with Lists of values using an IterableX of Either3s."]}
{"SampleId": 4617610, "Origin": "Tests {@link Array#from(Value...)}.", "Reference": "Tests {@link XQArray#from(Value...)}.", "LLMCandidates": ["Tests {@link XQArray#from(Value...)}.", "Tests {@link XQArray#from(Value...)}.", "Tests {@link XQArray#from(Value...)}.", "Tests {@link XQArray#from(Value...)}.", "Tests {@link XQArray#from(Value...)}."]}
{"SampleId": 1220434, "Origin": "Ingest a Matrix into an H2O Frame.", "Reference": "Ingest a Mahout Matrix into an H2O DRM.", "LLMCandidates": ["Create an H2O DRM from a Matrix. Ingest a matrix into an H2O Frame with min_hint and exact_hint options.", "Create an H2ODrm object from a given Matrix by constructing a Frame and setting values according to the input Matrix. If the Matrix has string labels, create an auxiliary vector with labels.", "Ingest a Matrix into an H2O Frame, given row and column sizes, min_hint, and exact_hint values.", "Create an empty H2O Frame with the specified dimensions, fill it with values from the input Matrix, and return a new H2ODrm object containing the frame and an auxiliary Vector if the input Matrix has string labels.", "Create a 0-filled frame with given dimensions from a Matrix, and populate it based on the input Matrix values. Optionally, if there's a string labeled matrix, create an auxiliary vector for the labels. Returns an H2O Drm object containing the frame and label vector."]}
{"SampleId": 2734301, "Origin": "Returns {@link List} of collapsed {@link AccordionPane}s", "Reference": "Asks {@link WebAccordion} to collapse {@link AccordionPane}s with the specified identifiers.", "LLMCandidates": ["Collapse the given pane ids in the model", "Collapses the given AccordionPane IDs.", "Collapses the given AccordionPane IDs.", "Collapse the specified panes using their IDs.", "Collapse the specified panes using their IDs."]}
{"SampleId": 2008719, "Origin": "Same as {@link #awaitResult(long, TimeUnit)},\nbut throw InterruptedException and TimeoutException as an OperationCancellation.", "Reference": "Same as {@link #awaitResult(long, TimeUnit)},\nbut throw InterruptedException as an OperationCancellation.", "LLMCandidates": ["Same as {@link #awaitResult(long, TimeUnit)}, but throw InterruptedException and OperationCancellation.", "Same as {@link #awaitResult(long, TimeUnit)}, but throws InterruptedException and TimeoutException as OperationCancellation.", "Same as {@link #awaitResult(long, TimeUnit)}, but throws InterruptedException and TimeoutException as OperationCancellation.", "Same as {@link #awaitResult(long, TimeUnit)}, but throw InterruptedException and OperationCancellation.", "The content of the updated code is as follows: default RESULT getResult(long timeout, TimeUnit unit) throws EXCEPTION, OperationCancellation { try { return awaitResult(timeout, unit); } catch(InterruptedException e) { throw new OperationCancellation(); }"]}
{"SampleId": 3863845, "Origin": "shows full-screen preview of the passed media", "Reference": "show full-screen preview of the item and the passed position", "LLMCandidates": ["Shows full-screen preview of the photo or video at a given position.", "Shows full-screen preview of the passed media item with position", "Shows full-screen preview of the passed media item with position", "Shows full-screen preview of a PhotoPickerItem at a specified position.", "Shows full-screen preview of the media item at the specified position."]}
{"SampleId": 237074, "Origin": "Handles a netty RPC callable with logging.", "Reference": "Handles a streaming RPC callable with logging.", "LLMCandidates": ["Handles a streaming RPC callable with logging.", "Handles a streaming RPC callable with logging.", "Handles a streaming RPC callable with logging.", "Handles a streaming RPC callable with logging.", "Handles a streaming RPC callable with logging."]}
{"SampleId": 6305223, "Origin": "Build an HTTP Ok without any content.", "Reference": "Build an HTTP No content.", "LLMCandidates": ["Build an HTTP NoContent without any content.", "Build an HTTP NoContent without any content.", "Build an HTTP NoContent without any content.", "Build an HTTP NoContent without any content.", "Build an HTTP No Content with no content payload."]}
{"SampleId": 2230477, "Origin": "Sets the quorum name for operations.", "Reference": "Sets the split brain protection name for operations.", "LLMCandidates": ["Sets the split brain protection name for operations.", "Sets the splitBrainProtectionName for operations.", "Sets the splitBrainProtectionName for operations.", "Sets the split brain protection name for operations.", "Sets the split brain protection name for operations."]}
{"SampleId": 3270031, "Origin": "Returns the expression to the left of the \"::\" if it exists and is\nunambiguous.", "Reference": "Returns the node to the left of the \"::\".", "LLMCandidates": ["Returns the left expression of the \"::\" if it exists and is not null.", "Returns the expression to the left of the \"::\" if it exists and is unambiguous.", "Returns the expression to the left of the \"::\" if it exists and is unambiguous.", "Returns the left expression of \"::\" if it exists and is unambiguous.", "Returns the expression to the left of the \"::\" if it exists and is unambiguous."]}
{"SampleId": 2825133, "Origin": "Determine type of a store base on a store file name.", "Reference": "Determine type of a store base on provided database file.", "LLMCandidates": ["Determine type of a store base on a database file.", "Determine type of a store base on a database file.", "Determine type of a store base on a database file.", "Determine type of a store based on a database file.", "Determine type of a store based on a database file."]}
{"SampleId": 4472680, "Origin": "Set name of the Cosmos DB table.", "Reference": "Set the resource value.", "LLMCandidates": ["Set the resource for table properties.", "Set the resource for table get properties.", "Set the resource for the TableGetPropertiesResource.", "Set the resource for the TableGetPropertiesResource.", "Set the resource by providing TableGetPropertiesResource object."]}
{"SampleId": 6233845, "Origin": "Returns prefix {@code byte} for this type.", "Reference": "Returns length of this type.", "LLMCandidates": ["Returns the length of the value if it is not null; otherwise, returns 0.", "/**\n * Returns the length of the value if it is not null, otherwise returns 0.\n */", "Returns the length of this type. If it is not null, it returns RedisConstants.TYPE_LENGTH; otherwise, it returns 0.", "Returns prefix {@code int} for this type if value is not null, otherwise returns 0.", "Returns the length of the type based on the presence of {@code value}. If {@code value} is not null, it returns {@code RedisConstants.TYPE_LENGTH}, otherwise it returns 0."]}
{"SampleId": 4617576, "Origin": "Adds part of another token to the token.", "Reference": "Adds the part of a token to the token.", "LLMCandidates": ["Adds a part of another token to the token by copying the specified range from the input byte array and appending it to the current content.", "Adds part of another token to the token by copying a portion of the source byte array into the target byte array and updating the size and position of the token within the builder.", "Adds part of another token to the token using Array.copy method.", "Adds part of another token to the token using Array.copy method.", "Adds part of another token to the current token, using Array.copy() to perform the operation efficiently."]}
{"SampleId": 6043598, "Origin": "and repositoryId = ?.", "Reference": "and type = ?.", "LLMCandidates": ["Find SyncDLObjects by repositoryId and type.", "Finds SyncDLObjects by repositoryId = ? and type = ?", "Finds SyncDLObjects by repositoryId = ? and type = ?", "Find SyncDLObjects by repository Id and type, ordering by the specified criteria.", "Find SyncDLObjects by repository Id and type, ordering by the specified criteria."]}
{"SampleId": 2327545, "Origin": "Generates random trits for a transaction.", "Reference": "Generates trits for a hash.", "LLMCandidates": ["Generates a random transaction hash using the given size of trits.", "Generates random trits for a transaction.", "Generates random trits for a transaction.", "Generates random trits for a transaction.", "Generates random trits for a transaction."]}
{"SampleId": 704476, "Origin": "Thread signaled test for {@link PredicateLock#waitForever()}", "Reference": "Thread signaled test for {@link PredicateLock#waitForTimeoutOrFail(long)}", "LLMCandidates": ["Tests the wait functionality of a PredicateLock for 5 minutes before failing. The event is created with a ProgressableStub, a SignalThread is started and joins after the waitForTimeoutOrFail() method is called on the BspEvent. The test still asserts that waitMsecs(0) returns true.", "Test the PredicateLock with a timeout of 5 minutes before failing.", "Test the PredicateLock with a timeout of 5 minutes before failing.", "Testing PredicateLock's waitForTimeoutOrFail() method with a 5 minute timeout before failing.", "Testing PredicateLock's waitForTimeoutOrFail(5 * 60_000), waiting for a timeout of 5 minutes before failing."]}
{"SampleId": 6045130, "Origin": "or throws a {@link com.liferay.calendar.NoSuchResourceException} if it could not be found.", "Reference": "or throws a {@link NoSuchResourceException} if it could not be found.", "LLMCandidates": ["Public static CalendarResource findByUUID_G(java.lang.String uuid, long groupId) throws com.liferay.calendar.NoSuchResourceException - Finds the CalendarResource with the given UUID and group ID, or throws a {@link com.liferay.calendar.NoSuchResourceException} if it could not be found.", "Find a CalendarResource by UUID_G, throwing a com.liferay.calendar.NoSuchResourceException if it could not be found.", "Finds a CalendarResource by UUID and group ID or throws a {@link com.liferay.calendar.NoSuchResourceException} if it could not be found.", "Finds a calendar resource by UUID and group ID, or throws a {@link com.liferay.calendar.NoSuchResourceException} if it could not be found.", "Find a CalendarResource with the specified UUID and group ID, or throws a {@link com.liferay.calendar.NoSuchResourceException} if it could not be found."]}
{"SampleId": 2218209, "Origin": "n choose k. Returns 0 if n is less than k.", "Reference": "The n choose k. Returns 0 if n is less than k.", "LLMCandidates": ["n choose k. Returns 0 if n is less than k.", "n choose k. Returns 0 if n is less than k.", "Calculate n choose k. Returns 0 if n is less than k.", "Calculate n choose k. Returns 0 if n is less than k.", "n choose k. Returns 0 if n is less than k."]}
{"SampleId": 6311227, "Origin": "Show {@link Toast} for exception", "Reference": "Show {@link Toast} for throwable", "LLMCandidates": ["Show {@link Toast} for an error", "Show a Toast with the exception message", "Show a Toast with the exception message", "Show a Toast displaying an error message based on the exception.", "Show a Toast displaying an error message based on the exception."]}
{"SampleId": 3357845, "Origin": "List a range of recording descriptors which match a channel and stream id.", "Reference": "List a range of recording descriptors which match a channel URI fragment and stream id.", "LLMCandidates": ["List a range of recording descriptors which match a channel fragment and stream id.", "List a range of recording descriptors which match a channel fragment and stream id.", "List a range of recording descriptors which match a channel fragment and stream id.", "List a range of recording descriptors which match a channel fragment and stream id.", "List a range of recording descriptors which match a channel fragment and stream id."]}
{"SampleId": 437801, "Origin": "Register the runnable to process the specific pTransformId.", "Reference": "Register the runnable to process the specific pTransformId and track its execution time", "LLMCandidates": ["Registers a runnable for a specific pTransformId, attaching additional labels metadata and handling execution states.", "Registers a runnable for the specified pTransformId, wrapping it with execution state and adding it to the list of runnables.", "Registers a runnable to process the specific pTransformId and adds it to the list of runnables with proper state sampler state for ExecutionTime Metrics. Additionally, stores the labels metadata in executionStates.", "Registers a runnable that processes the specific pTransformId and sets the execution state for ExecutionTime Metrics to use.", "Registers a runnable for specific pTransformId while setting up execution states and managing metrics containers."]}
{"SampleId": 1879510, "Origin": "Robust computation of the inverse covariance matrix.", "Reference": "Update the cholesky decomposition.", "LLMCandidates": ["Computes an inverse covariance matrix, potentially resolving singularity issues.", "Update Cholesky decomposition for inverse covariance matrix calculation.", "Update Cholesky decomposition for inverse covariance matrix calculation.", "Robust computation of the inverse covariance matrix by updating Cholesky decomposition and handling degenerated cases.", "Performs an update on the Cholesky decomposition of the covariance matrix to improve its handling of degenerated cases by adding a small value to the diagonal. Additionally, computes the logarithm of the determinant and weighted normal distribution factor for use in subsequent calculations."]}
{"SampleId": 4117678, "Origin": "See the\n{@link BlowfishCipher} class-level JavaDoc for more information and why it might be good to provide your own.", "Reference": "See the\nclass-level JavaDoc for more information and why it might be good to provide your own.", "LLMCandidates": ["/** * Set the {@link CipherService} instance to be used. * @see {@link CipherService} for more information on what it does and why you might want to provide your own implementation. */", "@inheritDoc} For more information on {@link BlowfishCipherService}, see its class-level JavaDoc and why it might be good to provide your own.", "See the {@link BlowfishCipher} class-level JavaDoc for more information and why it might be good to provide your own.", "See the {@link BlowfishCipher} class-level JavaDoc for more information and why it might be good to provide your own.", "See the {@link BlowfishCipher} class-level JavaDoc for more information and why it might be good to provide your own."]}
{"SampleId": 3357566, "Origin": "Get the channel parameter for the cluster log and snapshot replay channel.", "Reference": "Set the counter for the current state of the cluster backup.", "LLMCandidates": ["Set the initial value by adding 8 to n.", "Return the current state counter parameter for the cluster log and snapshot replay channel.", "Sets the channel parameter for the cluster log and snapshot replay channel.", "Set the state counter for the cluster log and snapshot replay channel.", "Set the state counter for the cluster log and snapshot replay channel."]}
{"SampleId": 1142511, "Origin": "Reset the leader election throttle.", "Reference": "Reset the leader election throttles.", "LLMCandidates": ["Reset the leader election throttles.", "Reset all leader election throttles.", "Reset all leader election throttles.", "Reset all leader election throttles.", "Reset all leader election throttles."]}
{"SampleId": 2544552, "Origin": "Apply the rotation transformation of the given {@link Quaterniond} to this matrix.", "Reference": "Apply the rotation transformation of the given {@link Quaterniondc} to this matrix.", "LLMCandidates": ["Apply the rotation transformation of the given {@link Quaterniond} to this matrix.", "Apply the rotation transformation of the given {@link Quaterniond} to this matrix.", "Apply the rotation transformation of the given {@link Quaterniond} to this matrix.", "Apply the rotation transformation of the given {@link Quaterniond} to this matrix.", "Apply the rotation transformation of the given {@link Quaterniond} to this matrix."]}
{"SampleId": 4476357, "Origin": "Fetches the configuration settings that match the {@code options}.", "Reference": "Fetches the configuration settings that match the {@code selector}.", "LLMCandidates": ["Fetches the configuration settings that match the {@code selector}.", "Fetches the configuration settings that match the {@code options}.", "Fetches the configuration settings that match the {@code options}.", "Fetches the configuration settings that match the {@code options}.", "Fetches the configuration settings that match the {@code options}."]}
{"SampleId": 5316646, "Origin": "Autodetect a {@link FreeMarkerConfig} object via the ApplicationContext.", "Reference": "Autodetect a {@link FreeMarkerConfig} object in the {@code ApplicationContext}.", "LLMCandidates": ["Autodetect a {@link FreeMarkerConfig} object via the ApplicationContext.", "Autodetect a {@link FreeMarkerConfig} object via the ApplicationContext with updated wording for the Application context usage.", "Autodetect a {@link FreeMarkerConfig} object via the ApplicationContext.", "Autodetect a {@link FreeMarkerConfig} object via the ApplicationContext.", "Autodetect a {@link FreeMarkerConfig} object via the ApplicationContext."]}
{"SampleId": 1294322, "Origin": "Invoked when the txn has been removed from the queue and is starting to execute at a local ExecutionSite", "Reference": "Invoked when the txn has been removed from the queue and is starting to execute at a local PartitionExecutor", "LLMCandidates": ["Invoked when the txn has been removed from the queue and is starting to execute at a local ExecutionSite", "Invoked when the txn has been removed from the queue and is starting to execute at a local ExecutionSite", "Invoked when the txn has been removed from the queue and is starting to execute at a local ExecutionSite", "Invoked when the txn has been removed from the queue and is starting to execute at a local ExecutionSite", "Invoked when the txn has been removed from the queue and is starting to execute at a local ExecutionSite"]}
{"SampleId": 1985691, "Origin": "Then return all - block to get the trapped water", "Reference": "Then return total - blocks to get the trapped water.", "LLMCandidates": ["Return the difference between total water without blocks and the occupied blocks to get the trapped water.", "Return the total possible water minus the number of blocks occupied to get the trapped water.", "Return all - block to get the trapped water", "Return all - block to get the trapped water", "The trapped water is found by subtracting the total from the number of blocks occupied."]}
{"SampleId": 2337095, "Origin": "Delete RADIUS Configuration\n### Functional Description:   Delete existing RADIUS configuration.", "Reference": "Delete RADIUS configuration\n### Functional Description:   Delete existing RADIUS configuration.", "LLMCandidates": ["Delete existing RADIUS configuration by deleting it using the specified X-Sds-Auth-Token.", "Delete RADIUS Configuration\n### Functional Description:   Delete existing RADIUS configuration.", "Delete existing RADIUS configuration.", "Delete existing RADIUS configuration.", "Delete existing RADIUS configuration."]}
{"SampleId": 1259760, "Origin": "Check whether the given member is a proxy member of a proxy object.", "Reference": "Check whether the given member is a proxy member of a proxy object or is a static proxy member.", "LLMCandidates": ["Check whether the given member is a proxy member of a proxy object if it's not static and if the object is a proxy.", "Check whether the given member is a proxy member of a proxy object if it's not static and check for the proxy object.", "Check whether the given member is a proxy member of a proxy object if it's not static.", "Check whether the given member is a proxy member of a proxy object, considering static modifier on the member variable.", "Check whether the given member is a proxy member of a proxy object, considering static modifier on the member variable."]}
{"SampleId": 4396574, "Origin": "Returns a string representation of this object; useful for testing and debugging.", "Reference": "Returns a string representation of this object.", "LLMCandidates": ["Returns a string representation of this object; useful for testing and debugging, with some sensitive data redacted by placing \"***Sensitive Data Redacted***\" in the appropriate fields.", "Returns a string representation of this object; useful for testing and debugging. Sensitive data is redacted with \"***Sensitive Data Redacted***\" placeholder for privacy.", "Returns a string representation of this object; useful for testing and debugging. Sensitive data has been redacted where necessary.", "Returns a string representation of this object; useful for testing and debugging with sensitive data redacted.", "Returns a string representation of this object; useful for testing and debugging, with sensitive data redacted."]}
{"SampleId": 1875792, "Origin": "Get the normalized variation of information (normalized, 0 = equal) NVI = 1\n- NMI_Joint", "Reference": "Get the normalized variation of information (normalized, small values are\ngood).", "LLMCandidates": ["Calculate the normalized variation of information (normalized, 0 = equal), where NVI is obtained by subtracting entropy Mutual Information from entropy Joint.", "Calculate the normalized variation of information, where NVI ranges from 0 to 1 based on the mutual information and entropy joint values.", "The normalized variation of information is calculated using the ratio of the difference between the entropyJoint and mutualInformation, resulting in a value between 0 (equal) and 1.", "Calculate the normalized variation of information by subtracting the mutual information from the entropy joint.", "Calculate the normalized variation of information by subtracting the mutual information from the entropy joint."]}
{"SampleId": 1309906, "Origin": "Generates a valid document ID for a service, used to index the service in ES.", "Reference": "Generates a valid document ID for a API, used to index the API in ES.", "LLMCandidates": ["Generates a valid document ID for an API, used to index the API in ES.", "Generates a valid document ID for an API, used to index the API in ES.", "Generates a valid document ID for an API, used to index the API in ES.", "Generates a valid document ID for an API, used to index the API in ES.", "Generates a valid document ID for an API, used to index the API in ES."]}
{"SampleId": 4132872, "Origin": "Returns the JDBC connection {@link #username} property.", "Reference": "Returns the JDBC connection {@link #userName} property.", "LLMCandidates": ["Returns the JDBC connection {@link #userName} property.", "Returns the user account {@link #userName} property.", "Returns the user account {@link #userName} property.", "Returns the property of the {@link #userName} method.", "Returns the property of the {@link #userName} method."]}
{"SampleId": 1629435, "Origin": "When the insertion is complete, the\n{@code ticker} will be {@link CountUpLatch#countUp() incremented} by 1.", "Reference": "When the insertion is complete, the\n{@code tracker} will be {@link CountUpLatch#countUp() incremented} by 1.", "LLMCandidates": ["When the insertion is complete, the {@code tracker} will be {@link CountUpLatch#countUp() incremented} by 1.", "When the insertion is complete, the {@code tracker} will be {@link CountUpLatch#countUp() incremented} by 1.", "When the insertion is complete, the {@code tracker} will be {@link CountUpLatch#countUp() incremented} by 1.", "When the insertion is complete, the {@code tracker} will be {@link CountUpLatch#countUp() incremented} by 1.", "When the insertion is complete, the {@code tracker} will be {@link CountUpLatch#countUp() incremented} by 1."]}
{"SampleId": 1442385, "Origin": "Calculates all distances of atoms within this cell returning those that are within the given cutoff\nas a list of AtomContacts", "Reference": "Calculates all distances of atoms within this cell returning those that are within the given cutoff\nas a list of Contacts containing the indices of the pair and the calculated distance.", "LLMCandidates": ["Calculates all distances of atoms within this cell returning those that are within the given cutoff as a list of Contacts", "Calculates all distances of atoms within this cell returning those that are within the given cutoff as a list of Contacts.", "Calculates all distances of atoms within this cell returning those that are within the given cutoff as a list of Contacts", "Calculates all distances of atoms within this cell returning those that are within the given cutoff as a list of Contacts", "Calculates all distances of atoms within this cell returning those that are within the given cutoff as a list of Contacts"]}
{"SampleId": 291293, "Origin": "Converts milliseconds to a string containing hours and minutes", "Reference": "Converts milliseconds to a string containing hours and minutes or minutes and seconds", "LLMCandidates": ["Converts milliseconds to a string containing hours and minutes if duration is in hours; otherwise, converts to minutes and seconds", "Converts milliseconds to a string containing hours and minutes with an option to include hours.", "Converts milliseconds to a string containing hours and minutes (optionally in hours format)", "Converts milliseconds to a string containing hours and minutes (optionally in hours format)", "Converts milliseconds to a string containing hours and minutes if specified with durationIsInHours argument"]}
{"SampleId": 4019592, "Origin": "WebPage on a job-by-job basis and thier values indicative of what actions\nshould be associated with a WebPage.", "Reference": "They are assigned to a WebPage on a job-by-job basis and thier values indicative of what actions should be associated with a WebPage.", "LLMCandidates": ["This method checks if markers are dirty.", "This method checks if markers are dirty, however, it throws an UnsupportedOperationException since IsDirty is not supported on tombstones.", "Indicates whether markers are dirty based on a WebPage's values and actions associated with them.", "Determine if markers are dirty without considering a map of values associated with WebPages.", "Determine if markers are dirty without considering a map of values associated with WebPages."]}
{"SampleId": 2912049, "Origin": "Gets the price that was traded, in decimal form.", "Reference": "Gets the price that was traded, together with the trade date, optional.", "LLMCandidates": ["Gets an Optional object containing the traded price if it exists, or an empty Optional object otherwise.", "Gets an Optional value representing the traded price, if available, or empty if not available.", "Gets the price that was traded, represented by an Optional<TradedPrice> object.", "Gets the price that was traded, represented by an Optional<TradedPrice> object.", "Gets the traded price if it is available, otherwise returns an empty Optional."]}
{"SampleId": 6291857, "Origin": "Create a TripTimeSubset from a given trip pattern, date and time window.", "Reference": "Create a TripTimeSubset from a given trip pattern, bitset of services running, and time window.", "LLMCandidates": ["Create a TripTimeSubset from a given trip pattern, date and time window using an index of services running.", "Create a TripTimeSubset from a given trip pattern, date, and time window using the service running status.", "Create a TripTimeSubset from a given trip pattern, date and time window using servicesRunning BitSet instead of graph's index.", "Create a TripTimeSubset from a given trip pattern, date and time window using BitSet to represent services running.", "Create a TripTimeSubset from a given trip pattern, date, time window and servicesRunning bit set."]}
{"SampleId": 4383855, "Origin": "Availability Zone in the same Region to increase fault tolerance in\nthe event of a service disruption.", "Reference": "Zone in the same Region to increase fault tolerance in the event of a\nservice disruption.", "LLMCandidates": ["Update the availability options for an instance to increase fault tolerance within a specific Availability Zone in the same Region.", "Update Availability Options for an existing resource to modify the fault tolerance settings and increase resilience in the event of a service disruption within the same Region.", "Update the availability options of a resource within the same region to increase fault tolerance and minimize service disruption.", "Updates the availability options in the specified Availability Zone within the same Region to increase fault tolerance in the event of a service disruption. This method is used to modify the current configuration for improved reliability and stability.", "Update the availability options for an existing resource within the same region to increase fault tolerance in the event of a service disruption."]}
{"SampleId": 3344326, "Origin": "RxRatpack.promise(new AsyncService().observe(\"foo\"))\n    ).getValue();", "Reference": "RxRatpack.promiseAll(new AsyncService().observe(\"foo\"))\n    ).getValue();", "LLMCandidates": ["Use the promiseAll() method to create a Promise of List from Observable.", "Use Promise.async to process Observable data from an observable source. This method is used for transforming an Observable<T> into a Promise<List<T>> by calling the subscribe() method on the Observable. If successful, it invokes the f::success method; if there's an error, it invokes the f::error method.", "Converts Observable<T> to a Promise<List<T>> using Async.subscribe(f::success, f::error). This method is used for processing multiple Observables asynchronously.", "/** \n * Converts an Observable into a Promise of List.\n * @param observable The Observable to process.\n * @return A promise with the converted list value.\n */", "Use promiseAll() to convert Observable<T> into a Promise<List<T>>, handling both success and error cases."]}
{"SampleId": 6044273, "Origin": "Returns all the push notifications devices where platform = ?.", "Reference": "Returns all the push notifications devices where userId = any ?", "LLMCandidates": ["Finds all push notifications devices where u_p (userIds and platform) are matched. Returns a list of PushNotificationsDevices based on the input parameters.", "Finds all push notifications devices associated with a specified platform for a list of user IDs.", "Finds all push notifications devices associated with a specified platform for a list of user IDs.", "Finds all push notifications devices where uIds = ? and platform = ?", "Finds all the push notifications devices associated with a given userIds and platform."]}
{"SampleId": 1985765, "Origin": "| Then we can use this range we retrieve levels from the map.", "Reference": "| Then this range can be used to retrieve column values from the map.", "LLMCandidates": ["Then we can use this range we retrieve columns from the map.", "We can use this range we retrieve columns from the map.", "We can use this range we retrieve columns from the map.", "Retrieve the result from the map using the column range we retrieve levels from.", "Then we can use this range we retrieve columns from the map."]}
{"SampleId": 4850466, "Origin": "Gets the user's avatar URL, if present and in a supported format.", "Reference": "Gets the user's avatar URL, if present.", "LLMCandidates": ["Gets the user's avatar URL if present and in a supported format.", "Gets the user's avatar URL, if present and in a supported format.", "Gets the user's avatar URL, if present and in a supported format.", "Gets the user's avatar URL, if present and in a supported format.", "Gets the user's avatar URL, if present and in a supported format."]}
{"SampleId": 4781233, "Origin": "Return  if {@link ITokenTypeAttribute#TF_COMMON_WORD} is set.", "Reference": "Return  if {@link ITokenizer#TF_COMMON_WORD} is set.", "LLMCandidates": ["Return if {@link ITokenizer#TF_COMMON_WORD} is set.", "Return if {@link ITokenizer#TF_COMMON_WORD} is set.", "Return if {@link ITokenizer#TF_COMMON_WORD} is set.", "Return if {@link ITokenizer#TF_COMMON_WORD} is set.", "Return if {@link ITokenizer#TF_COMMON_WORD} is set."]}
{"SampleId": 2048822, "Origin": "Calls {@link #reset()} and releases any held DRM resources.", "Reference": "Calls {@link #reset()} and releases any owned {@link DrmSession} references.", "LLMCandidates": ["Calls {@link #reset()} and releases any held DRM resources, specifically by invoking {@link #metadataQueue} to release DRM session references.", "Calls {@link #reset()} and releases any held DRM resources.", "Calls {@link #reset()} and releases any held DRM resources using {@link metadataQueue#releaseDrmSessionReferences()}.", "Calls {@link #reset()} and releases any held DRM resources by invoking {@link metadataQueue#releaseDrmSessionReferences()}.", "Calls {@link #reset()} and releases any held DRM resources by invoking {@link metadataQueue#releaseDrmSessionReferences()}."]}
{"SampleId": 2478395, "Origin": "Removes given PacketExtension from the list of child packet\nextensions.", "Reference": "Removes given ExtensionElement from the list of child packet\nextensions.", "LLMCandidates": ["Removes given ExtensionElement from the list of child packet extensions.", "Removes given ExtensionElement from the list of child packet extensions.", "Removes given ExtensionElement from the list of child extension elements.", "Removes given ExtensionElement from the list of child extension elements.", "Removes given ExtensionElement from the list of child packet extensions."]}
{"SampleId": 5078149, "Origin": "Prepare task event for execution on agent.", "Reference": "Prepare exe params for send REST request on node.", "LLMCandidates": ["Prepare task event for execution on agent.", "Prepare task event for execution on agent with modified parameter clusterId and arguments.", "Fill task parameters for execution on agent.", "Fill task parameters for execution on agent.", "Fill task parameters for execution on agent."]}
{"SampleId": 5452379, "Origin": "This method returns an interface that is\nboth \"up\" and supports multicast.", "Reference": "This method returns the first interface that\nis both \"up\" and supports multicast.", "LLMCandidates": ["This method returns an interface that is both \"up\" and supports multicast, with a preference for those interfaces that have IPv4 and IPv6 addresses.", "This method returns an interface that is both \"up\" and supports multicast, and checks if it has IPv4 and IPv6 addresses before returning.", "This method returns an interface that is both \"up\" and supports multicast and also checks if the address type is IPv4 or IPv6.", "This method returns an interface that is both \"up\" and supports multicast. Additionally, it checks if the interface has IPv4 and IPv6 addresses before returning a preferred choice, falling back to a non-loopback or point-to-point interface.", "This method returns an interface that is both \"up\" and supports multicast, with priority given to interfaces having both IPv4 and IPv6 addresses. If such an interface is found, it is returned directly. Otherwise, the method falls back to returning either a point-to-point (PPP) interface or a loopback interface, in that order."]}
{"SampleId": 101881, "Origin": "Return true if the given CmsTreeItem or its children is selected.", "Reference": "Return true if at least one child of the given tree item is selected.", "LLMCandidates": ["Return true if the given CmsTreeItem or its children is selected, considering the checked state of the current item and any of its children.", "Determine if the given CmsTreeItem or its children is selected by iterating through all of its children and checking their selection state.", "Return true if the given CmsTreeItem or any of its children is selected.", "Return true if the given CmsTreeItem or any of its children is selected.", "Determine if the given CmsTreeItem or its descendants is selected."]}
{"SampleId": 6191662, "Origin": "Note that this performs chains\nconstruction but wil not inject {@link MuleContext} or {@link FlowConstruct} or perform any lifecycle.", "Reference": "Note that this performs chains\nconstruction but will not inject {@link MuleContext} or perform any lifecycle.", "LLMCandidates": ["Creates a MessageProcessorChain based on the provided processing strategy and list of processors. If there is only one processor in the list and it's an instance of MessageProcessorChain but not ExplicitMessageProcessorChain, returns it directly. Otherwise, builds a new chain using the DefaultMessageProcessorChainBuilder with the given processing strategy and list of processors.", "This method creates a new MessageProcessorChain using a given list of processors and an optional ProcessingStrategy. If there is only one processor in the list and it is a MessageProcessorChain, it returns that processor. Otherwise, it constructs a DefaultMessageProcessorChainBuilder with the provided processing strategy (if present) and builds the chain using the processors.", "Constructs a chain from the given list of processors with optional processing strategy. If the list contains only one processor that is an instance of MessageProcessorChain and not ExplicitMessageProcessorChain, it returns the single processor. Otherwise, it creates a new DefaultMessageProcessorChainBuilder, sets the processing strategy if provided, and returns the built chain from the processors list. This method does not inject MuleContext or FlowConstruct, nor does it perform any lifecycle management.", "Constructs a MessageProcessorChain object based on the given processing strategy and processors list, but does not inject {@link MuleContext} or {@link FlowConstruct} nor perform any lifecycle management.", "Creates a MessageProcessorChain object based on the provided processingStrategy and list of processors. If there is only one processor in the list and it's an instance of MessageProcessorChain but not ExplicitMessageProcessorChain, returns that single processor directly; otherwise, builds a new DefaultMessageProcessorChain using the provided processing strategy and processors list. Note that this method does not inject MuleContext or FlowConstruct, nor perform any lifecycle management."]}
{"SampleId": 4386724, "Origin": "NOTE: Amazon Glacier retains recently completed jobs for a\nperiod before deleting them; however, it eventually removes completed\njobs.", "Reference": "Amazon Glacier retains recently completed jobs for a period before\ndeleting them; however, it eventually removes completed jobs.", "LLMCandidates": ["Retrieves a list of jobs for the specified account", "Amazon Glacier retains recently completed jobs for a period before deleting them; however, it eventually removes completed jobs.", "This method retrieves a list of jobs from Amazon Glacier, which may eventually remove completed jobs after some time.", "Amazon Glacier retains recently completed jobs for a period before deleting them; however, it eventually removes completed jobs after a certain time.", "The listJobs method is used to obtain a List of jobs from Amazon Glacier. It takes a ListJobsRequest and returns a ListJobsResult containing the job details. This method uses an ExecutionContext for request metrics and an AWSRequestMetrics to track client execution time."]}
{"SampleId": 5440480, "Origin": "Appends the information about the given handle to {@link #buf buf}.", "Reference": "Appends a string representation of the given handle to {@link #stringBuilder}.", "LLMCandidates": ["Appends the information about the given handle to {@link #stringBuilder stringBuilder}.", "Appends the information about the given handle to {@link #stringBuilder stringBuilder}.", "Appends the information about the given handle to {@link #stringBuilder stringBuilder}.", "Appends the information about the given handle to {@link #stringBuilder stringBuilder}.", "Appends the information about the given handle to {@link #stringBuilder stringBuilder}."]}
{"SampleId": 5177566, "Origin": "Handler method converting a Jetty Connection into a Restlet Call.", "Reference": "Handler method converting a Jetty HttpChannel into a Restlet Call.", "LLMCandidates": ["Handler method converting a Jetty Channel into a Restlet Call.", "Handler method converting a Jetty Channel into a Restlet Call.", "Handler method converting a Jetty Server Channel into a Restlet Call.", "Handler method converting a Jetty Channel into a Restlet Call.", "Handler method converting a Jetty Channel into a Restlet Call."]}
{"SampleId": 5631550, "Origin": "The timestamp for creation of the synonym.", "Reference": "The timestamp for creation of the object.", "LLMCandidates": ["The timestamp for creation of the synonym.", "The timestamp for creation of the synonym.", "The timestamp for creation of the synonym.", "The timestamp for creation of the synonym.", "The timestamp for creation of the synonym."]}
{"SampleId": 2312757, "Origin": "Returns the (unbiased) skew of all the values within a {@link PointSet}\nregion of a {@link Dataset}", "Reference": "Returns the (unbiased) kurtosis of all the values within a {@link PointSet}\nregion of a {@link Dataset}", "LLMCandidates": ["Returns the sample kurtosis of all the values within a {@link PointSet} region of a {@link Dataset}.", "Returns the (unbiased) kurtosis of all the values within a {@link PointSet} region of a {@link Dataset}.", "Returns the (unbiased) kurtosis of all the values within a {@link PointSet} region of a {@link Dataset}.", "Returns the (unbiased) kurtosis of all the values within a {@link PointSet} region of a {@link Dataset}.", "Calculates the kurtosis of all values within a PointSet region of a Dataset"]}
{"SampleId": 5218994, "Origin": "remove space for SQL expression and outside parentheses", "Reference": "remove space for SQL expression", "LLMCandidates": ["Removes space for SQL expression and processes input string directly.", "Removes space for SQL expression but no longer removes from outside parentheses.", "Removes space for SQL expression only.", "Removes space for SQL expression only.", "Removes spaces for SQL expression and outside parentheses directly from the string."]}
{"SampleId": 1311345, "Origin": "Reads the inbound request headers from the request and sets them on\nthe {@link ServiceRequest}.", "Reference": "Reads the inbound request headers from the request and sets them on\nthe {@link ApiRequest}.", "LLMCandidates": ["Reads the inbound request headers from the request and sets them on {@link ApiRequest}.", "Reads the inbound request headers from the request and sets them on the {@link ApiRequest}.", "Reads the inbound request headers from the request and sets them on the {@link ApiRequest}.", "Reads the inbound request headers from the request and sets them on {@link ApiRequest}.", "Reads the inbound request headers from the request and sets them on the {@link ApiRequest}."]}
{"SampleId": 594031, "Origin": "Returns the input stream of this message content.", "Reference": "Returns the CachedOutputStream of this message content.", "LLMCandidates": ["Returns a cached output stream of this message content.", "Returns an output stream of this message content.", "Returns an output stream of this message content.", "Returns an output stream of this message content.", "Returns the output stream of this message content."]}
{"SampleId": 1404511, "Origin": "The value is {@link ArtifactFileMetadata#PLACEHOLDER} if the artifact's metadata is not\nfully captured in {@link #additionalOutputData}.", "Reference": "The value is {@link FileArtifactValue#PLACEHOLDER} if the artifact's metadata is not fully\ncaptured in {@link #additionalOutputData}.", "LLMCandidates": ["The value is {@link FileArtifactValue#PLACEHOLDER} if the artifact's metadata is not fully captured in {@link #additionalOutputData}.", "The value is {@link ArtifactFileMetadata#PLACEHOLDER} if the artifact's metadata is not fully captured in {@link #additionalOutputData}.", "The value is {@link ArtifactFileMetadata#PLACEHOLDER} if the artifact's metadata is not fully captured in {@link #additionalOutputData}.", "The value is {@link ArtifactFileMetadata#PLACEHOLDER} if the artifact's metadata is not fully captured in {@link #additionalOutputData}.", "The value is {@link FileArtifactValue#PLACEHOLDER} if the artifact's metadata is not fully captured in {@link #additionalOutputData}."]}
{"SampleId": 3036959, "Origin": "Currently, SONA supports Flat, VXLAN and VLAN modes.", "Reference": "Currently, SONA supports Flat, VXLAN, GRE and VLAN modes.", "LLMCandidates": ["SONA currently supports Flat, VXLAN, GRE, and VLAN modes.", "SONA now supports Flat, VXLAN, GRE, and VLAN modes.", "SONA supports Flat, VXLAN, GRE and VLAN modes.", "SONA supports Flat, VXLAN, GRE, and VLAN modes now.", "SONA currently supports Flat, VXLAN, GRE, and VLAN modes."]}
{"SampleId": 5459561, "Origin": "Returns {@code true} if this module reflectively exports the given\npackage package to the given module.", "Reference": "Returns {@code true} if this module reflectively exports or opens given\npackage package to the given module.", "LLMCandidates": ["Returns {@code true} if this module reflectively exports or opens the given package to the given module and the open flag is set to true.", "Returns {@code true} if this module reflectively exports or opens the given package to the given module and its subpackages.", "Returns {@code true} if this module reflectively exports or opens the given package to the given module.", "Returns {@code true} if this module reflectively exports or is open to the given package of the given module.", "Returns {@code true} if this module reflectively exports or has open access to the given package to the given module."]}
{"SampleId": 5451749, "Origin": "Search for package name in the sorted regular expression\nlist, if found return the group name.", "Reference": "Search for element name in the sorted regular expression\nlist, if found return the group name.", "LLMCandidates": ["Search for element name in the sorted regular expression list, if found return the group name.", "Search for element name in the sorted regular expression list, if found return the group name.", "Search for elementName in the sorted regular expression list, if found return the group name.", "Search for element name in the sorted regular expression list, if found return the group name.", "Search for element name in the sorted regular expression list, if found return the group name."]}
{"SampleId": 2615604, "Origin": "Returns the keyFrames[] array where all the TextureRegions of the animation are stored.", "Reference": "Returns the keyframes[] array where all the frames of the animation are stored.", "LLMCandidates": ["Returns the keyFrames[] array where all the TextureRegions of the animation are stored.", "Returns the keyFrames[] array where all the elements of the animation are stored.", "Returns a generic array of keyFrames where all the elements of the animation are stored.", "Returns a generic array of keyFrames where all the elements of the animation are stored.", "Returns the keyFrames[] array where all the elements of the animation are stored."]}
{"SampleId": 2443539, "Origin": "Get the current {@link RequestScope.Instance request scope instance}\nand mark it as suspended.", "Reference": "Get the current {@link RequestContext request scope context}\nand mark it as suspended.", "LLMCandidates": ["Get the current {@link RequestScope.RequestContext request scope context} and mark it as suspended.", "Get the current {@link RequestScope.RequestContext request scope context} and mark it as suspended.", "Get the current {@link RequestScope.RequestContext request scope context} and mark it as suspended.", "Get the current {@link RequestScope.RequestContext request scope context} and mark it as suspended.", "Get the current {@link RequestScope.Context request scope context} and mark it as suspended."]}
{"SampleId": 5377094, "Origin": "Whether to group the REST resources together.", "Reference": "How to group the REST resources together.", "LLMCandidates": ["Return the grouped REST resources.", "Return the group REST resources as a string.", "Indicate whether or not REST resources are grouped together.", "Indicate whether or not REST resources are grouped together.", "Retrieve the group REST resources identifier."]}
{"SampleId": 1353529, "Origin": "Assign available voices to the chords that have no voice assigned yet.", "Reference": "Assign available voices to the chords in this measure with no voice assigned yet.", "LLMCandidates": ["Assign available voices to the chords that have no voice assigned yet within a specific measure and its incoming chords.", "Assign available voices to the chords that have no voice assigned yet in a given measure and list of chords for that measure.", "Assign available voices to the chords that have no voice assigned yet, using first voice available in part and with staff continuity whenever possible.", "Assign available voices to chords that have no voice assigned yet within a measure, using first voice available in part and with staff continuity whenever possible.", "Assign available voices to the chords that have no voice assigned yet, considering staff continuity whenever possible and using first voice in part if applicable."]}
{"SampleId": 4404113, "Origin": "NOTE:This operation is eventually consistent.", "Reference": "This operation is eventually consistent.", "LLMCandidates": ["This operation is eventually consistent. The response handler now sets the 'IsPayloadJson' flag to true for handling JSON payloads.", "NOTE: This operation is eventually consistent.", "This operation is eventually consistent.", "This operation is eventually consistent.", "This operation is eventually consistent."]}
{"SampleId": 2403174, "Origin": "Ensures server received authentication request.", "Reference": "Ensures server received an extensions request.", "LLMCandidates": ["Ensures server received authentication request with empty path.", "Asserts that server received an authentication request, checking for a specific request count and request line.", "Asserts that server received an authentication request, checking for a specific request count and request line.", "Assert server received an extension request.", "Ensures server received authentication request."]}
{"SampleId": 470385, "Origin": "The option will be converted to a  type.", "Reference": "The option is a:\n type.", "LLMCandidates": ["Set the value by adding 8 to n.", "The option will be converted to a dataFrame type.", "The option will be converted to a dataFrame type.", "Set the initial value by adding 8 to n.", "Set the initial value by adding 8 to n."]}
{"SampleId": 5446194, "Origin": "Returns true if the given class loader is in the system domain\nin which all permissions are granted.", "Reference": "Returns true if the given class loader is the bootstrap class loader\nor the platform class loader.", "LLMCandidates": ["Returns true if the given class loader is in the system domain in which all permissions are granted, or it's the platform class loader.", "Returns true if the given class loader is in the system domain or it's equal to the platform class loader.", "Returns true if the given class loader is either null or ClassLoader.getPlatformClassLoader(), representing the system domain in which all permissions are granted.", "This method returns true if the given class loader is either null or ClassLoader.getPlatformClassLoader(), representing a system domain loader in which all permissions are granted.", "Returns true if the given class loader is in the system domain in which all permissions are granted, or if it's the platform class loader."]}
{"SampleId": 4404087, "Origin": "IMPORTANT:Because the number of workflow history events for a\nsingle workflow execution might be very large, the result returned\nmight be split up across a number of pages.", "Reference": "Because the number of workflow history events for a single\nworkflow execution might be very large, the result returned might be\nsplit up across a number of pages.", "LLMCandidates": ["The result returned might be split up across a number of pages because the number of workflow history events for a single workflow execution could be very large.", "Because the number of workflow history events for a single workflow execution might be very large, the result returned might be split up across a number of pages.", "Because the number of workflow history events for a single workflow execution might be very large, the result returned might be split up across a number of pages.", "Because the number of workflow history events for a single workflow execution might be very large, the result returned might be split up across a number of pages.", "The number of workflow history events for a single workflow execution might be very large, so the result returned might be split up across a number of pages."]}
{"SampleId": 3774087, "Origin": "The default resolution is {@link Resolution#DAY} since Vaadin VERSION.", "Reference": "The default resolution is {@link DateResolution#DAY} since Vaadin VERSION.", "LLMCandidates": ["The default resolution is {@link R#DAY} since Vaadin VERSION.", "The default resolution is {@link R#DAY} since Vaadin VERSION.", "The default resolution is {@link R#DAY} since Vaadin VERSION.", "The default resolution is {@link R#DAY} since Vaadin VERSION.", "The default resolution is {@link R#DAY} since Vaadin VERSION."]}
{"SampleId": 2734304, "Origin": "Returns {@link List} of expanded {@link AccordionPane}s.", "Reference": "Asks {@link WebAccordion} to collapse {@link AccordionPane}s with the specified identifiers.", "LLMCandidates": ["Collapses the specified AccordionPane ids.", "Collapses the specified {@link AccordionPane}s with their IDs provided as arguments.", "Collapses panes with the given ids.", "Collapses panes with the given ids.", "Collapses the specified AccordionPane(s) with ids."]}
{"SampleId": 1348111, "Origin": "Initializes the execution of a task.", "Reference": "Initializes the state machine.", "LLMCandidates": ["Initializes the execution of a task by initializing the state machine with the given parameters.", "Initializes the execution of a task, specifically setting up a state machine based on the provided context. This method is called when starting a new session. If the state machine implements SessionListener, it is added as a listener. Finally, the state machine's init method is called with the current context as an argument.", "Initializes the execution of a task, if the stateMachine is a SessionListener, add it to sessions and initiate the state machine with this object.", "Initializes a state machine execution by setting up its context with the given input parameters.", "Initializes a state machine execution by setting up its context with the given input parameters."]}
{"SampleId": 1578397, "Origin": "Removes the specified properties of the {@link NamespacedEntityId}.", "Reference": "Removes the specified properties of the {@link MetadataEntity}.", "LLMCandidates": ["Removes the specified properties of the {@link MetadataEntity}.", "Removes the specified properties of the {@link MetadataEntity}.", "Removes the specified properties of the {@link MetadataEntity}.", "Removes the specified properties of the {@link MetadataEntity}.", "Removes the specified properties of the {@link MetadataEntity}."]}
{"SampleId": 3074972, "Origin": "Called in response to the {@link RContext#destroy} method.", "Reference": "Called in response to the {@link RContext#dispose} method.", "LLMCandidates": ["Called in response to the {@link RContext#dispose} method.", "Called in response to the {@link RContext#dispose} method.", "Called in response to the {@link RContext#dispose} method.", "Called in response to the {@link RContext#dispose} method.", "Called in response to the {@link RContext#dispose} method."]}
{"SampleId": 5315712, "Origin": "Each class must represent an annotated class.", "Reference": "Each class must represent a component class.", "LLMCandidates": ["Each class must represent a component class.", "Each class must represent a component class.", "Each class must represent a component class.", "Each class must represent a component class.", "Each class must represent an annotated class."]}
{"SampleId": 1989254, "Origin": "Add the specified {@link Graph} to the cache.", "Reference": "Add the specified {@link Store} to the cache.", "LLMCandidates": ["Add the specified {@link Store} to the cache.", "Add the specified {@link Store} to the cache.", "Add a specified Store to the cache.", "Add a specified Store to the cache.", "Add a specified Store to the cache."]}
{"SampleId": 4311215, "Origin": "High order byte is serverId, next 5\n5 bytes are from timestamp, and low order 2 bytes are 0s.", "Reference": "High order 1 byte is serverId, next\n5 bytes are from timestamp, and low order 2 bytes are 0s.", "LLMCandidates": ["The next session ID is determined by taking the current timestamp's high order byte, using it as the serverID, and then adding this to a long term (id << 56). If the result is EphemeralType.CONTAINER_EPHEMERAL_OWNER, increment the result to avoid an edge case.", "The session id is initialized by shifting the current elapsed time to the high order byte, then adding the given id to a new byte and returning it. If the result equals the EphemeralType constant for container ephemeral owner, increment it to ensure uniqueness.", "Initialize a new session ID by using the high order byte as serverId and the next 5 bytes from timestamp with low order 2 bytes set to 0s.", "Initialize a long value for the next session ID using the server ID and current timestamp", "Initialize a new session identifier by combining the server's current elapsed time with an 8-bit offset and the provided server ID."]}
{"SampleId": 1135686, "Origin": "Common test method to be able to check security from any authentication plugin", "Reference": "Common test method to be able to check auth metrics from any authentication plugin", "LLMCandidates": ["Common test method for asserting security metrics minimums from any authentication plugin", "Assert that minimum security metric counts are met for given prefix.", "Common test method to be able to check security metrics from any authentication plugin", "Common test method to be able to check security metrics from any authentication plugin", "Common test method to be able to check security metrics from any authentication plugin"]}
{"SampleId": 5230482, "Origin": "An example of a valid direction is\n{@code new Vector(1, 0, 1)}.", "Reference": "An example of a valid direction is\n{@code new BlockVector3(1, 0, 1)}.", "LLMCandidates": ["An example of a valid direction is {@code new BlockVector3(1, 0, 1)", "An example of a valid direction is {@code new BlockVector3(1, 0, 1)", "An example of a valid direction is {@code new BlockVector3(1, 0, 1)", "An example of a valid direction is {@code new BlockVector3(1, 0, 1)}.", "An example of a valid direction is {@code new BlockVector3(1, 0, 1)"]}
{"SampleId": 4478306, "Origin": "Code snippets for {@link LeaseClientBuilder#buildClient()}.", "Reference": "Code snippets for {@link BlobLeaseClientBuilder#buildClient()}.", "LLMCandidates": ["Code snippets for {@link BlobLeaseClientBuilder#buildClient()}.", "Code snippets for {@link BlobLeaseClientBuilder#buildClient()}.", "Code snippets for {@link BlobLeaseClientBuilder#buildClient()}.", "Code snippets for {@link BlobLeaseClientBuilder#buildClient()}.", "Code snippets for {@link BlobLeaseClientBuilder#buildClient()}."]}
{"SampleId": 2050142, "Origin": "Pauses all downloads.", "Reference": "Pauses downloads.", "LLMCandidates": ["Pauses all downloads if they are not already paused. Sets the paused state and sends a message to reflect the change.", "Pauses all downloads if not already paused.", "Pauses all downloads if not already paused.", "Pauses all downloads if not already paused.", "Pauses all downloads if not already paused."]}
{"SampleId": 1118538, "Origin": "Decodes a String representing a number of events into a Vector of LoggingEvents", "Reference": "Decodes a String representing a number of events into a", "LLMCandidates": ["Decodes a String representing a number of events into a Vector of LoggingEvents", "Decodes a String representing a number of events into a Vector of LoggingEvents.", "Decodes a String representing a number of events into a Vector of LoggingEvents. The method first separates the input String into two parts, one ending with </record> and the other being a partial event, which will be combined and processed. It then parses the separated parts to get a Document object. If the Document is not null, it returns a Vector containing the decoded events using the decodeEvents method.", "Decodes a String representing a number of events into a Vector of LoggingEvents", "Decodes a String representing a number of events into a Vector of LoggingEvents by separating it into partial and complete portions, parsing the document and processing its contents."]}
{"SampleId": 4245364, "Origin": "Checks whether or not resources in the WEB-INF folder can be access.", "Reference": "Checks whether or not resources in the web root folder can be access.", "LLMCandidates": ["Checks whether or not resources in the root folder can be accessed.", "Checks whether or not resources in the ROOT folder can be access.", "Checks whether or not resources in the ROOT folder can be accessed.", "Checks whether or not resources in the ROOT folder can be accessed.", "Checks whether or not resources in the ROOT folder can be accessed."]}
{"SampleId": 2705593, "Origin": "Get Stringwert.", "Reference": "Get Eingaberegister Name.", "LLMCandidates": ["Retrieves the DataEntry_Tab_Name from the column.", "Get String value for DataEntry_Tab_Name.", "Retrieves the Data Entry Tab Name from the given column.", "Retrieves the Data Entry Tab Name from the given column.", "Get DataEntry_Tab_Name"]}
{"SampleId": 617199, "Origin": "Compare the two queues containing operator/task output by converting them to an array first.", "Reference": "Compare the two queues containing operator/task output by converting them to an array first, sort array by\ncomparator.", "LLMCandidates": ["Compare the two queues containing operator/task output by converting them to an array first and sorting based on a specific comparator before checking if they are equal.", "Compare two collections of objects by converting them to sorted arrays and asserting their equality. This method assumes that the first collection contains expected records, and the second one contains actual output records from a stream processing. The comparator is used to sort both arrays in a deterministic way.", "This method compares two queues containing operator/task output by converting them to an array first and then checking if they are equal after sorting based on the expected order. The input expected and actual collections contain elements that need to be compared, while the message parameter provides information for error messages during comparison.", "Compare two collections by first converting them into arrays and sorting them using a specified comparator. Then, verify that the resulting arrays are equal using an assertion.", "Compares two collections by first converting them into an array. Then, sorts the arrays and asserts that they are equal. This method is useful for checking if the output of a program or function is in the correct sorted order."]}
{"SampleId": 4132895, "Origin": "Wrapper for close of ResultSet which removes this\nresult set from being traced then calls close on\nthe original ResultSet.", "Reference": "Wrapper for close of ResultSet which removes this result set from being traced then calls close on the original", "LLMCandidates": ["Wrapper for close of ResultSet which removes this result set from being traced then calls close on the original ResultSet.", "Wrapper for close of ResultSet which removes this result set from being traced then calls close on the original ResultSet using local variables \"statement\" and \"connection\".", "Wrapper for close of ResultSet which removes this\nresult set from being traced then calls close on the original ResultSet.", "Wrapper for close of ResultSet which removes this result set from being traced then calls close on the original ResultSet.", "Wrapper for close of ResultSet which removes this result set from being traced then calls close on the original ResultSet."]}
{"SampleId": 4372852, "Origin": "Sets the Single character used to indicate a row should be ignored when present at the start of a row.", "Reference": "Sets the character used to indicate a row should be ignored when present at the start of a row.", "LLMCandidates": ["Sets the single character used to indicate a row should be ignored when present at the start of a row; calls charToString(comments) to achieve this conversion.", "Sets the Single character used to indicate a row should be ignored when present at the start of a row. The method now calls another method named 'charToString' with the given Character object as argument before setting the comments.", "Sets the single character used to indicate a row should be ignored when present at the start of a row by converting it to a string using the charToString method.", "Sets the single character used to indicate a row should be ignored when present at the start of a row. The character is passed through a function, charToString, for conversion before being set.", "Sets the Single character used to indicate a row should be ignored when present at the start of a row."]}
{"SampleId": 2443544, "Origin": "The current thread might\nbe already in any request scope and in that case the scope will be changed to the\nscope defined by the {@link RequestScope.Instance scope instance}.", "Reference": "The current thread might\nbe already in any request scope and in that case the scope will be changed to the\nscope defined by the {@link RequestContext scope context}.", "LLMCandidates": ["The current thread might be already in any request scope and in that case, the scope will be changed to the scope defined by the {@link RequestScope.Context context}.", "The current thread might be already in any request scope and in that case, the scope will be changed to the scope defined by the {@link RequestScope.Context context}.", "The current thread might be already in any request scope and in that case the scope will be changed to the one defined by the {@link RequestScope.Context context}.", "The current thread might be already in any request scope and in that case, the scope will be changed to the scope defined by the {@link RequestScope.Context context}.", "The current thread might be already in any request scope and in that case, the scope will be changed to the new one defined by the {@link RequestScope.Instance scope instance}."]}
{"SampleId": 2891684, "Origin": "and \"..\" in file names.", "Reference": "and \"..\" in {@link File} names.", "LLMCandidates": ["Finds the parent directory of a file by iterating through its directories and handling \".\" and \"..\" entries in file names.", "Finds the parent file of a given file by iterating through directories while counting and skipping \"..\" in file names.", "The function finds the parent file of a given file while considering \"..\" and \".\" in file names.", "The function finds the parent file of a given file while considering \"..\" and \".\" in file names.", "This method returns the parent file of the given file by navigating upwards through directory hierarchy, considering \"..\" and regular file names."]}
{"SampleId": 2616150, "Origin": "Parses the {@code Vector2} represented by the given string according to the format of {@link #toString()}.", "Reference": "Sets this {@code Vector2} to the value represented by the specified string according to the format of {@link #toString()}.", "LLMCandidates": ["Parses a Vector2 represented by the given string according to the format of toString().", "Parses the {@code Vector2} represented by the given string according to the format of {@link #toString()}.", "Parses the {@code Vector2} represented by the given string according to the format of {@link #toString()}, taking into account any changes to the method signature and variable names in the code.", "Parses the {@code Vector2} represented by the given string according to the format of {@link #toString()}.", "Parses the {@code Vector2} represented by the given string according to the format of {@link #toString()}, with the change that it now returns a {@code Vector2} object instead of using the {@code Vector2(x, y)} constructor."]}
{"SampleId": 4624426, "Origin": "Returns the function annotations.", "Reference": "Returns the function body expression.", "LLMCandidates": ["Returns the function body by taking the last expression from the list of expressions.", "Returns the function body.", "Returns the function body.", "Returns the function body.", "Returns the function body."]}
{"SampleId": 5360172, "Origin": "Configure a {@link RSocketOutboundGateway.Command} for RSocket request type.", "Reference": "Configure an {@link RSocketOutboundGateway.Command} for the RSocket request type.", "LLMCandidates": ["Configure a {@link RSocketOutboundGateway.Command} for RSocket request type.", "Configure a {@link RSocketOutboundGateway.Command} for RSocket request type.", "Configure a deprecated {@link RSocketOutboundGateway.Command} for RSocket request type; use interactionModel() instead.", "Configure a {@link RSocketOutboundGateway} for RSocket request type using {@link ValueExpression}. Note that this method is now deprecated.", "Configure a {@link RSocketOutboundGateway.Command} for RSocket request type. Note: This method is deprecated and replaced by {@code interactionModel(new ValueExpression<>(command))}."]}
{"SampleId": 1630674, "Origin": "Inserts a {@link Set} to the {@link Dataset}", "Reference": "Inserts a {@code Set} to the {@link Dataset}.", "LLMCandidates": ["Inserts a Set of {@link DatasetEntry} objects to the {@link Dataset}, returning the number of successfully inserted entries.", "Inserts a Set of {@link DatasetEntry} objects to the {@link Dataset}, returns the number of inserted entries.", "Inserts a {@link Set} of {@link DatasetEntry}s to the {@link Dataset}, returning the number of successfully inserted entries.", "Inserts a {@link Set} of {@link DatasetEntry} objects to the {@link Dataset}, returning the number of successfully inserted entries.", "Inserts a {@link Set} of {@link DatasetEntry} objects to the {@link Dataset}, returning the number of successfully inserted entries."]}
{"SampleId": 402253, "Origin": "Handles: POST /clusters/{clusterName}/servicegroups/{serviceGroupName}/services/{serviceDisplayName}", "Reference": "Handles: POST /clusters/{clusterName}/servicegroups/{serviceGroupName}/services/{serviceName}", "LLMCandidates": ["Handles: POST /clusters/{clusterName}/servicegroups/{serviceGroupName}/services/{serviceName", "Handles: POST /clusters/{clusterName}/servicegroups/{serviceGroupName}/services/{serviceName", "Handles: POST /clusters/{clusterName}/servicegroups/{serviceGroupName}/services/{serviceName", "Handles: POST /clusters/{clusterName}/servicegroups/{serviceGroupName}/services/{serviceName", "Handles: POST /clusters/{clusterName}/servicegroups/{serviceGroupName}/services/{serviceName"]}
{"SampleId": 242261, "Origin": "Then log4j invokes the {@link #setAppenderName(String)}\nmethod to set the value of {@link #mAppenderName}.", "Reference": "Then log4j invokes the {@link #setProcessType(String)}\nmethod to set the value of {@link #mProcessType}.", "LLMCandidates": ["Then log4j invokes the {@link #setProcessType(String)} method to set the value of {@link #mProcessType}.", "log4j invokes the {@link #setProcessType(String)} method to set the value of {@link #mProcessType}.", "Log4j invokes the {@link #setProcessType(String)} method to set the value of {@link #mProcessType}.", "Then log4j invokes the {@link #setProcessType(String)} method to set the value of {@link #mProcessType}.", "Log4j invokes the {@link #setProcessType(String)} method to set the value of {@link #mProcessType}."]}
{"SampleId": 6047022, "Origin": "Returns the status with the primary key or throws a {@link com.liferay.chat.NoSuchStatusException} if it could not be found.", "Reference": "Returns the status with the primary key or throws a {@link NoSuchStatusException} if it could not be found.", "LLMCandidates": ["Returns the status with the primary key or throws a {@link com.liferay.chat.NoSuchStatusException} if it could not be found.", "Returns the status with the primary key or throws a {@link com.liferay.chat.NoSuchStatusException} if it could not be found.", "Finds the Status with the given primary key or throws a {@link com.liferay.chat.NoSuchStatusException} if not found.", "Returns the Status with the primary key or throws a {@link com.liferay.chat.NoSuchStatusException} if it could not be found.", "Returns the Status with the primary key or throws a {@link com.liferay.chat.NoSuchStatusException} if it could not be found."]}
{"SampleId": 4388500, "Origin": "IMPORTANT: After you create a DB parameter group, you should\nwait at least 5 minutes before creating your first DB instance that\nuses that DB parameter group as the default parameter group.", "Reference": "After you create a DB parameter group, you should wait at least 5 minutes\nbefore creating your first DB instance that uses that DB parameter group\nas the default parameter group.", "LLMCandidates": ["The content of the original code is as follows:\n\npublic DBParameterGroup createDBParameterGroup(CreateDBParameterGroupRequest createDBParameterGroupRequest) {\n        ExecutionContext executionContext = createExecutionContext(createDBParameterGroupRequest);\n        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();\n        awsRequestMetrics.startEvent(Field.ClientExecuteTime);\n        Request<CreateDBParameterGroupRequest> request = null;\n        Response<DBParameterGroup> response = null;\n        \n        try {\n            awsRequestMetrics.startEvent(Field.RequestMarshallTime);\n            try {\n                request = new CreateDBParameterGroupRequestMarshaller().marshall(super.beforeMarshalling(createDBParameterGroupRequest));\n                // Binds the request metrics to the current request.\n                request.setAWSRequestMetrics(awsRequestMetrics);\n            } finally {\n                awsRequestMetrics.endEvent(Field.RequestMarshallTime);\n            }\n\n            response = invoke(request, new DBParameterGroupStaxUnmarshaller(), executionContext);\n            return response.getAwsResponse();\n\n        } finally {\n            \n            endClientExecution(awsRequestMetrics, request, response);\n        }", "After you create a DB parameter group, wait at least 5 minutes before creating your first DB instance that uses that DB parameter group as the default parameter group.", "After you create a DB parameter group, you should wait at least 5 minutes before creating your first DB instance that uses that DB parameter group as the default parameter group.", "After you create a DB parameter group, wait at least 5 minutes before creating your first DB instance that uses that DB parameter group as the default parameter group.", "After creating a DB parameter group, wait at least 5 minutes before creating your first DB instance that uses this group as its default parameter group."]}
{"SampleId": 2484703, "Origin": "Sets the state attribute of this User to\nstate", "Reference": "Sets the state attribute of this User's element to\nstate", "LLMCandidates": ["Sets the state attribute of this UserElement to state", "Sets the state attribute of this UserElement to", "Sets the state attribute of this UserElement to", "Sets the state attribute of this UserElement to state", "Sets the state attribute of this UserElement to state"]}
{"SampleId": 3084770, "Origin": "This call returns true in the interpreter or a low tier compilation that does profiling.", "Reference": "This call returns true in the interpreter or a low grade compilation that does profiling.", "LLMCandidates": ["This call returns true in the interpreter or a low-grade compilation that does profiling.", "This call returns true in the interpreter or a low-grade compilation that does profiling.", "This call returns true in the interpreter or a low grade compilation that does profiling.", "This call returns true in the interpreter or a low grade compilation that does profiling.", "This call returns true in the interpreter or a low grade compilation that does profiling."]}
{"SampleId": 4117768, "Origin": "Returns the InetAddress associated with the client who created/is interacting with this Subject.", "Reference": "Returns the host name or IP associated with the client who created/is interacting with this Subject.", "LLMCandidates": ["Returns the host associated with the client who created/is interacting with this Subject.", "Returns the host associated with the client who created/is interacting with this Subject.", "Returns the host associated with the client who created/is interacting with this Subject.", "Returns the host associated with the client who created/is interacting with this Subject.", "Returns the host associated with the client who created/is interacting with this Subject."]}
{"SampleId": 4479674, "Origin": "Code snippet for {@link AppendBlobAsyncClient#createWithResponse(BlobHTTPHeaders, Map, BlobAccessConditions)}", "Reference": "Code snippet for {@link AppendBlobAsyncClient#createWithResponse(BlobHttpHeaders, Map, BlobAccessConditions)}", "LLMCandidates": ["Code snippet for {@link AppendBlobAsyncClient#createWithResponse(BlobHttpHeaders, Map, BlobAccessConditions)", "Code snippet for {@link AppendBlobAsyncClient#createWithResponse(BlobHttpHeaders, Map, BlobAccessConditions)", "Code snippet for {@link AppendBlobAsyncClient#createWithResponse(BlobHttpHeaders, Map, BlobAccessConditions)", "Code snippet for {@link AppendBlobAsyncClient#createWithResponse(BlobHttpHeaders, Map, BlobAccessConditions)", "Code snippet for {@link AppendBlobAsyncClient#createWithResponse(BlobHttpHeaders, Map, BlobAccessConditions)"]}
{"SampleId": 5600561, "Origin": "class|delay|cron", "Reference": "class|intervalSchedule|cron", "LLMCandidates": ["/**\n * Match the given statement with the pattern for creating a task.\n *\n * @param statement The input string to match.\n * @return Matcher An instance of Matcher to check if the statement matches the pattern.\n */", "match a pattern for creating a task in the given statement.", "match a pattern for creating a task in the given statement.", "Matcher matchCreateTask(String statement){\n        return PAT_CREATE_TASK.matcher(statement);", "Match a string using a specific pattern for creating a task."]}
{"SampleId": 3083932, "Origin": "The returned context supplier is intended to be cached in the currently adopted\nAST.", "Reference": "The returned context reference is intended to be cached in the currently adopted\nAST.", "LLMCandidates": ["The returned context reference is intended to be cached in the currently adopted AST.", "The returned context reference is intended to be cached in the currently adopted AST.", "The returned context reference is intended to be cached in the currently adopted AST.", "The returned ContextReference is intended to be cached in the currently adopted AST.", "The returned ContextReference is intended to be cached in the currently adopted AST."]}
{"SampleId": 291294, "Origin": "Converts short duration string (HH:MM) to milliseconds.", "Reference": "Converts short duration string (XX:YY) to milliseconds.", "LLMCandidates": ["Converts short duration string (HH:MM) to milliseconds with an optional boolean flag indicating if the input is in hours.", "Converts short duration string with hours option (HH:MM) to milliseconds.", "Converts short duration string with hours option (HH:MM) to milliseconds.", "Convert short duration string (HH:MM) with optional hours modifier to milliseconds.", "Converts short duration string (HH:MM) to milliseconds with a boolean flag indicating if the input is in hours or not."]}
{"SampleId": 5927587, "Origin": "Returns a new fresh folder with the given name under the temporary\nfolder.", "Reference": "Returns a new fresh folder with the given path under the temporary\nfolder.", "LLMCandidates": ["Returns a new fresh folder with the given name under the temporary folder if it is a relative path and does not already exist.", "Creates a new folder with the given relative path under the temporary root directory. If the folder already exists, it will throw an IOException.", "Creates a new folder with the given name under the temporary directory if it does not already exist.", "Create a new folder with the specified name under the temporary root folder and return it. If the folder already exists, throw an IOException.", "Create a new folder with the given name under the temporary folder, returning it if successful; otherwise, throw an IOException with a message indicating that a folder with the same name already exists."]}
{"SampleId": 5319337, "Origin": "Adds a new CONSTANT_Double_info to the constant pool of this symbol table.", "Reference": "Adds a new CONSTANT_Integer_info or CONSTANT_Float_info to the constant pool of this symbol\ntable.", "LLMCandidates": ["Adds a new CONSTANT_IntegerOrFloat_info to the constant pool of this symbol table.", "Adds a new CONSTANT_IntegerOrFloat_info to the constant pool of this symbol table.", "Adds a new CONSTANT_Integer_info or CONSTANT_Float_info to the constant pool of this symbol table.", "Adds a new CONSTANT_Integer_info or CONSTANT_Float_info to the constant pool of this symbol table.", "Adds a new CONSTANT_IntegerOrFloat_info to the constant pool of this symbol table."]}
{"SampleId": 5447625, "Origin": "timed invokeAll(empty collection) returns empty collection", "Reference": "timed invokeAll(empty collection) returns empty list", "LLMCandidates": ["timed invokeAll(empty collection) returns empty list after a random timeout with random time unit", "Timed invokeAll(empty collection) returns empty list of futures.", "Testing timed invokeAll2() with an empty collection returns an empty list of futures.", "Asserts that invokeAll returns an empty list when invoked with an empty collection and a random timeout from the custom executor", "timed invokeAll(empty collection) returns empty list"]}
{"SampleId": 2337267, "Origin": "Created by user info", "Reference": "Created by user", "LLMCandidates": ["The information about who created the object", "Created by user", "Created by user", "Created by user", "Created by user"]}
{"SampleId": 2337065, "Origin": "### Effects: If `brandingServerBrandingId` is set, `brandingServerCustomer` is not supplied.", "Reference": "### Effects: If `brandingServerBrandingId` is set, `brandingServerCustomer` is **NOT** supplied.", "LLMCandidates": ["Retrieves information about a branding server.", "Obtain branding server information by invoking an API with GET method and returning a BrandingServerInfo object. The method is deprecated in favor of using getBrandingServerInfoWithHttpInfo(), which additionally provides the response status code.", "This method retrieves the BrandingServerInfo object with a GET request to /v4/public/branding/info endpoint.", "Gets the branding server info. If `brandingServerBrandingId` is set, `brandingServerCustomer` is not supplied.", "Retrieve the branding server information. If a brandingServerBrandingId is provided, the brandingServerCustomer value will not be supplied."]}
{"SampleId": 2544551, "Origin": "In order to set the matrix to a rotation transformation without post-multiplying,\nuse {@link #rotation(Quaterniond)}.", "Reference": "In order to set the matrix to a rotation transformation without post-multiplying,\nuse {@link #rotation(Quaterniondc)}.", "LLMCandidates": ["In order to set the matrix to a rotation transformation without post-multiplying, use {@link #rotation(Quaterniond)}.", "In order to set the matrix to a rotation transformation without post-multiplying, use {@link #rotation(Quaterniond)}.", "Rotate a matrix using a quaternion without modifying its current transformation state.", "Rotate a matrix using a quaternion without modifying its current transformation state.", "In order to set the matrix to a rotation transformation without post-multiplying, use {@link #rotation(Quaterniond)}."]}
{"SampleId": 1574727, "Origin": "When translated into a QueryTerm object, search terms\ncontaining an operator have the operator removed from the string representation.", "Reference": "When translated into a QueryTerm object, search terms\ncontaining a qualifying operator have the operator removed from the string representation.", "LLMCandidates": ["When translated into a QueryTerm object, search terms containing an operator have the operator removed from the string representation.", "When translated into a QueryTerm object, search terms containing an operator have the operator removed from the string representation.", "When translated into a QueryTerm object, search terms with an operator have the operator removed from the string representation.", "When translated into a QueryTerm object, search terms with an operator have the operator removed from the string representation.", "When translated into a QueryTerm object, search terms containing an operator have the operator removed from the string representation."]}
{"SampleId": 4962979, "Origin": "This method is currently only used for root-level serializer\nhandling to allow for simpler caching.", "Reference": "This method is mostly used for root-level serializer\nhandling to allow for simpler caching.", "LLMCandidates": ["Finds a JsonSerializer for a typed value, using local non-shared cache and shared cache lookups. It composes from pieces, finding the value serializer and type serializer, then wraps them in a TypeWrappedSerializer if necessary. If caching is enabled, it adds the typed serializer to the cache.", "This method finds a JsonSerializer for a typed value given the JavaType and BeanProperty. It first checks the local non-shared cache and then the shared one, composing the serializer from pieces if not found. If caching is enabled, it adds the result to the shared cache.", "This method is currently only used for root-level serializer handling to allow for simpler caching and composition from pieces.", "Finds a JsonSerializer for a given JavaType value, taking into account cache and BeanProperty parameters, potentially composing it from pieces if not found in the local or shared cache.", "This method is currently only used for root-level serializer handling to allow for simpler caching."]}
{"SampleId": 2891318, "Origin": "Appends BCC address.", "Reference": "Appends CC address.", "LLMCandidates": ["Appends CC address.", "Appends CC address.", "Appends CC address.", "Appends CC address.", "Appends CC address."]}
{"SampleId": 3758384, "Origin": "Look for contract stored by given slot contract id.", "Reference": "Look for the contract stored using the given slot contract id.", "LLMCandidates": ["Query the contract stored by the given slot id and optionally origin id and contract id.", "Look for contract stored by given slot id and origin id.", "Look for contract stored by given slot id and optionally origin_id and contract_id.", "Look for contract stored by given slot id and contract id.", "Look for contract stored by given slot id and contract id."]}
{"SampleId": 4237630, "Origin": "Sets the {@link IClassCache} for the given application.", "Reference": "Sets the {@link IGetAndSetLocator} for the given application.", "LLMCandidates": ["Sets the {@link IClassCache} for the given application, using a deprecated method that sets a locator to retrieve and set IGetAndSet objects from the cache.", "Sets the {@link IClassCache} for a given application or PropertyResolver if no application is provided. This method has been deprecated, and you are encouraged to use other methods instead. The purpose of this function is to provide an interface that allows for the retrieval and setting of getters/setters using the specified class cache.", "Sets the {@link IClassCache} for the given application using a custom {@link IGetAndSetLocator}. The method is deprecated and replaced by a new implementation.", "Sets the IClassCache for the given application if not null. Otherwise, it is used for PropertyResolver class. This method has been deprecated. The functionality of setting the cache has been moved to setLocator and implemented by using a DefaultGetAndSetLocator.", "Sets a deprecated {@link IClassCache} for the given application and returns an instance of {@link IGetAndSet}. The deprecated method calls a setter that will return an {@link IGetAndSet} object which can be used to get and set values on a class."]}
{"SampleId": 236986, "Origin": "Tests for the {@link BaseFileSystem#openFile(AlluxioURI, OpenFileOptions)} method to\ncomplete successfully.", "Reference": "Tests for the {@link BaseFileSystem#openFile(AlluxioURI, OpenFilePOptions)} method to\ncomplete successfully.", "LLMCandidates": ["Tests for the {@link BaseFileSystem#openFile(AlluxioURI, OpenFilePOptions)} method to complete successfully.", "Tests for the {@link BaseFileSystem#openFile(AlluxioURI, OpenFilePOptions)} method to complete successfully.", "Tests for the {@link BaseFileSystem#openFile(AlluxioURI, OpenFilePOptions)} method to complete successfully.", "Tests for the {@link BaseFileSystem#openFile(AlluxioURI, OpenFilePOptions)} method to complete successfully.", "Tests for the {@link BaseFileSystem#openFile(AlluxioURI, OpenFilePOptions)} method to complete successfully."]}
{"SampleId": 3576038, "Origin": "If there is any regular output or error\noutput, it is appended to the given s.", "Reference": "If there is any regular output or error\noutput, it is appended to the given {@code StringBuilder}s.", "LLMCandidates": ["If there is any output or error output from the shell command, it is appended to the given StringBuilder object.", "Appends regular output or error output from Process p to specified StringBuilder objects.", "Appends the regular output or error output to the given StringBuilder variables.", "Appends the regular output or error output to the given StringBuilder variables.", "Appends any regular output or error output to the given StringBuilder objects 'outputLines' and 'errorLines' respectively."]}
{"SampleId": 2048820, "Origin": "Calls {@link #discardToEnd()} and releases any held DRM resources.", "Reference": "Calls {@link #discardToEnd()} and releases any owned {@link DrmSession} references.", "LLMCandidates": ["Calls {@link #discardToEnd()} and releases any held DRM resources or {@link #metadataQueue} releases DrmSessionReferences.", "Calls {@link #discardToEnd()} and releases any held DRM resources by using {@link #metadataQueue}.", "Calls {@link #discardToEnd()} and releases any held DRM resources; additionally, it releases DrmSessionReferences from the metadataQueue.", "Calls {@link #discardToEnd()} and releases any held DRM resources, additionally releases Drm session references from the metadataQueue.", "Calls {@link #discardToEnd()} and releases any held DRM resources by calling {@link java.util.concurrent.ConcurrentLinkedQueue#releaseDrmSessionReferences()}."]}
{"SampleId": 2913862, "Origin": "This is measured from the bottom, that is, the quantile estimation with the level 99% corresponds to\nthe smallest 99% observations and 1% of the observation are above that level.", "Reference": "This is measured from the bottom, that is, Thus the quantile estimation with the level 99% corresponds to\nthe smallest 99% observations.", "LLMCandidates": ["This is measured from the bottom, that is, the quantile estimation with the level 99% corresponds to the smallest 99% observations and 1% of the observation are above that level.", "This method returns a quantile estimation from a sorted sample array based on the level input. The level is measured from the bottom, meaning that the quantile estimation with the level 99% corresponds to the smallest 99% observations and 1% of the observations are above that level.", "This is measured from the bottom, that is, the quantile estimation with the level 99% corresponds to the smallest 99% observations and 1% of the observation are above that level.", "This is measured from the bottom, that is, the quantile estimation with the level 99% corresponds to the smallest 99% observations and 1% of the observation are above that level.", "This is measured from the bottom, that is, the quantile estimation with the level 99% corresponds to the smallest 99% observations and 1% of the observation are above that level. This method returns a quantile result calculated on unsorted samples."]}
{"SampleId": 339673, "Origin": "Add a Content {@link Uri} to observe", "Reference": "Adds a content {@link Uri} for system observation", "LLMCandidates": ["Add a Content {@link Uri} to observe", "Add a Content {@link Uri} to observe", "Add a Content {@link Uri} to observe", "Add a Content {@link Uri} to observe", "Add a Content {@link Uri} to observe"]}
{"SampleId": 367563, "Origin": "Preference summary should be the activated device name", "Reference": "Preference summary should be device's name", "LLMCandidates": ["Preference summary should be the connected device name when more than one hearing aid Bluetooth devices are available.", "Preference summary should be the active Bluetooth device's name.", "Preference summary should be the active Bluetooth device's name.", "Preference summary should be the active Bluetooth device's name", "Preference summary should be the active Bluetooth device's name"]}
{"SampleId": 3467627, "Origin": "This method should only be used for steps whose value is\n{@link #TYPE_ARGUMENT TYPE_ARGUMENT}.", "Reference": "This method should\nonly be used for steps whose value is {@link #TYPE_ARGUMENT}.", "LLMCandidates": ["This method should only be used for steps whose value is {@link #TYPE_ARGUMENT TYPE_ARGUMENT}.", "This method should only be used for steps whose value is {@link #TYPE_ARGUMENT_INDEX TYPE_ARGUMENT_INDEX}.", "This method should only be used for steps whose value is {@link #TYPE_ARGUMENT TYPE_ARGUMENT}.", "This method should only be used for steps whose value is {@link #TYPE_ARGUMENT TYPE_ARGUMENT}.", "This method should only be used for steps whose value is {@link #TYPE_ARGUMENT TYPE_ARGUMENT}."]}
{"SampleId": 528022, "Origin": "Differs from the above because it can be used on any file, rather than only\nmanaged commit log segments (and thus cannot call waitForFinalSync).", "Reference": "Differs from the above because it can be used on any file, rather than only\nmanaged commit log segments (and thus cannot call waitForFinalSync), and in\nthe treatment of failures.", "LLMCandidates": ["This method may be used on any file, rather than only managed commit log segments, and thus cannot call waitForFinalSync.", "This method checks if a command is given for archiving and executes it using an executor if so. It can be used on any file, rather than only managed commit log segments (and thus cannot call waitForFinalSync).", "maybeArchive can be used on any file, rather than only managed commit log segments (and thus cannot call waitForFinalSync).", "This method checks if archiveCommand is not empty, then submits a task to execute the command with parameters path and name. If an IOException occurs, it logs a warning message.", "This method allows for archiving a file based on the given path and name without requiring that it be managed by commit log segments or calling waitForFinalSync."]}
{"SampleId": 5630798, "Origin": "Gets the description.", "Reference": "Gets the code.", "LLMCandidates": ["Gets the code.", "Gets the code.", "Gets the code.", "Gets the code.", "Gets the code."]}
{"SampleId": 1136150, "Origin": "Parses the timestamp from the collection list and returns them in reverse sorted order (most recent 1st)", "Reference": "Result is returned them in sorted order (most recent 1st)", "LLMCandidates": ["Parses the timestamp from the collection list and returns them in reverse sorted order (most recent 1st), considering the most recent collection when used later.", "Parses the timestamp from the collection list and returns them in reverse sorted order (most recent 1st), considering TreeMap but not using it due to log(N) for grabbing the most recent.", "Parses the timestamp from the collection list and returns them in reverse sorted order (most recent 1st), considering TreeMap but didn't like the log(N) just to grab the most recent when we use it later.", "Parses the timestamp from the collection list and returns them in reverse sorted order (most recent 1st).", "Parses the timestamp from the collection list and returns them in reverse sorted order (most recent 1st)"]}
{"SampleId": 3574164, "Origin": "Does a simple HEAD request to the server's /health endpoint to check if it's reachable If not an", "Reference": "Does a simple HEAD request to a configuration endpoint to check if it's reachable.", "LLMCandidates": ["Checks if the server's /health endpoint is reachable by making a HEAD request and throws an exception if it's not reachable.", "Does a simple HEAD request to the server's /health endpoint to check if it's reachable If not an", "Does a simple HEAD request to the server's /health endpoint to check if it's reachable If not an", "Performs a HEAD request to the config server's /health endpoint to ensure it is reachable.", "Checks if the Cloud Config Server is reachable by making a HEAD request to its /health endpoint. If not, throws an IllegalStateException."]}
{"SampleId": 4475929, "Origin": "Code snippet for {@link AppendBlobClient#appendBlockWithResponse(InputStream, long, AppendBlobRequestConditions,", "Reference": "Code snippet for {@link AppendBlobClient#appendBlockWithResponse(InputStream, long, byte[], AppendBlobRequestConditions,", "LLMCandidates": ["appends a new block of data to an AppendBlob using the provided InputStream, length, byte[] md5 value for content hash verification, AppendBlobRequestConditions, timeout and Context", "AppendBlob has %d committed blocks%n. Calls the appendBlockWithResponse method from {@link AppendBlobClient}. The input parameters include data (InputStream), length, md5 (byte array representation of the MD5 digest calculated from \"data\"), accessConditions (AppendBlobRequestConditions), and context (Context). The output is the number of committed blocks in the AppendBlob.", "Code snippet for {@link AppendBlobClient#appendBlockWithResponse(InputStream, long, byte[], AppendBlobRequestConditions, Duration, Context)", "Code snippet for {@link AppendBlobClient#appendBlockWithResponse(InputStream, long, byte[], AppendBlobRequestConditions, Duration, Context)", "public void appendBlock2() throws NoSuchAlgorithmException {\n        // BEGIN: com.azure.storage.blob.specialized.AppendBlobClient.appendBlockWithResponse#InputStream-long-byte-AppendBlobAccessConditions-Duration-Context\n        byte[] md5 = MessageDigest.getInstance(\"MD5\").digest(\"data\".getBytes(StandardCharsets.UTF_8));\n        AppendBlobRequestConditions accessConditions = new AppendBlobRequestConditions()\n            .setAppendPosition(POSITION)\n            .setMaxSize(maxSize);\n        Context context = new Context(\"key\", \"value\");\n\n        System.out.printf(\"AppendBlob has %d committed blocks%n\",\n            client.appendBlockWithResponse(data, length, md5, accessConditions, timeout, context)\n                .getValue().getBlobCommittedBlockCount());\n        // END: com.azure.storage.blob.specialized.AppendBlobClient.appendBlockWithResponse#InputStream-long-byte-AppendBlobAccessConditions-Duration-Context\n    }"]}
{"SampleId": 2395154, "Origin": "Returns true if the class has the specified annotation class.", "Reference": "Returns true if the class has the specified annotation type.", "LLMCandidates": ["Returns true if the class has the specified annotation type.", "Returns true if the class has the specified annotation type.", "Returns true if the class has the specified annotation type.", "Returns true if the class has the specified annotation class with the typeName parameter used instead of clz.", "Returns true if the class has the specified annotation type."]}
{"SampleId": 2911558, "Origin": "A typical use case would be to convert index names to curve names valid for an underlying system.", "Reference": "A typical use case would be to convert parameter metadata tenors to be valid for an underlying system.", "LLMCandidates": ["This method allows a client to apply a function over the ParameterMetadatas in the CurveSensitivities object, replacing the existing ones. This can be particularly useful for converting names or altering other properties of these metadatas. For example, this method could be used to transform a list of currency parameters into a format suitable for a specific trading system by changing their names.", "This method allows adjusting the CurveSensitivities by mapping each sensitivities value with a new Function provided that transforms the ParameterMetadatas. The use case would be to convert index names to curve names valid for an underlying system.", "This function applies a transformation to the input CurveSensitivities using a provided Function that takes List of ParameterMetadata and returns List of ParameterMetadata. This method modifies the existing sensitivities by replacing each element's ParameterMetadata with the result of applying the given function on its original value, then returns a new CurveSensitivities instance.", "Updates a CurveSensitivities object by applying a Function to each ParameterMetadata in the list. This method can be used for converting index names to curve names valid for an underlying system.", "This method allows for a transformation of typed sensitivities using a Function that takes a List of ParameterMetadata and returns a new List with the same parameter names but potentially different metadata. The resulting CurveSensitivities object is then returned."]}
{"SampleId": 2111867, "Origin": "There are cases where a type is seen as unresolved but can be found\namongst the imports of the module or within the default imports.", "Reference": "There are cases where a type is seen as unresolved but can be found\namongst the imports of the module.", "LLMCandidates": ["The fewer cases where a type is seen as unresolved but can be found amongst the imports of the module or within the default imports.", "The fewer cases where a type is seen as unresolved but can be found amongst the module's single-type and on-demand imports or within the default imports.", "There are cases where a type is seen as unresolved but can be found amongst the module's single-type and on-demand imports or within the default imports.", "The purpose of this method is to detect types that may be considered unresolved but can still be found among the imports of the module or within the default imports.", "This method checks if a missing type can be found among the module's single-type and on-demand imports."]}
{"SampleId": 5455011, "Origin": "Checks a name to ensure that it's a legal type name.", "Reference": "Checks a name to ensure that it's a legal qualified class name.", "LLMCandidates": ["Checks a name to ensure that it's a legal fully qualified class name.", "Checks a name to ensure that it's a legal qualified class name.", "Checks a name to ensure that it's a legal qualified class name.", "Checks a name to ensure that it's a legal qualified class name.", "Checks a name to ensure that it's a legal qualified class name for \"service provider name\"."]}
{"SampleId": 1348848, "Origin": "Returns the log compactor.", "Reference": "Returns the log writer.", "LLMCandidates": ["Returns the log writer.", "Returns the log writer.", "Returns the log writer.", "Returns the log writer.", "Returns the log writer."]}
{"SampleId": 5631506, "Origin": "This property is not returned if the dialog node has no parent.", "Reference": "This property is omitted if the dialog node has no parent.", "LLMCandidates": ["This property is not returned if the dialog node has no parent.", "This property is not returned if the dialog node has no parent.", "This property is not returned if the dialog node has no parent.", "This property is not returned if the dialog node has no parent.", "This property is not returned if the dialog node has no parent."]}
{"SampleId": 3847346, "Origin": "Parses {@link SparseVector} from the given Matrix Market string.", "Reference": "Parses {@link SparseVector} from the given Matrix Market.", "LLMCandidates": ["Parses {@link SparseVector} from a Matrix Market input stream.", "Parses {@link SparseVector} from the given InputStream.", "Parses {@link SparseVector} from the given InputStream.", "Parses {@link SparseVector} from the given Matrix Market InputStream.", "Parses {@link SparseVector} from an input stream."]}
{"SampleId": 4479574, "Origin": "Code snippets for {@link BlobAsyncClient#setHTTPHeaders(BlobHTTPHeaders)}", "Reference": "Code snippets for {@link BlobAsyncClient#setHTTPHeaders(BlobHttpHeaders)}", "LLMCandidates": ["Code snippets for {@link BlobAsyncClient#setHTTPHeaders(BlobHttpHeaders)", "Code snippets for {@link BlobAsyncClient#setHTTPHeaders(BlobHttpHeaders)", "Code snippets for {@link BlobAsyncClient#setHTTPHeaders(BlobHttpHeaders)", "Code snippets for {@link BlobAsyncClient#setHTTPHeaders(BlobHttpHeaders)", "Code snippets for {@link BlobAsyncClient#setHTTPHeaders(BlobHttpHeaders)"]}
{"SampleId": 5841626, "Origin": "Get the gradle paths for the given list of modules and all the tested projects (if it is a test app).", "Reference": "Get the gradle paths for the given module and all the tested projects (if it is a test app).", "LLMCandidates": ["Get the gradle paths for the given module and all the tested projects (if it is a test app).", "Get the gradle paths for the given module and all the tested projects (if it is a test app).", "Get the gradle paths for the given module and all the tested projects (if it is a test app).", "Get the gradle paths for the given module and all the tested projects (if it is a test app).", "Get the gradle paths for the given list of modules and all the tested projects (if it is a test app)."]}
{"SampleId": 5176845, "Origin": "Getter for {@link #exposeHeaders}", "Reference": "Getter for {@link #allowHeaders}", "LLMCandidates": ["Getter for {@link #allowHeaders", "Getter for {@link #allowHeaders", "Getter for {@link #allowHeaders", "Getter for {@link #allowHeaders", "Getter for {@link #allowHeaders"]}
{"SampleId": 4237183, "Origin": "Creates a {@link Behavior} that uses the given {@link WicketConsumer consumer}\nto do something with the component's tag.", "Reference": "Creates a {@link Behavior} that uses the given {@code SerializableConsumer consumer} to do\nsomething with the component's tag.", "LLMCandidates": ["Creates a {@link Behavior} that uses the given {@link SerializableConsumer consumer} to do something with the component's tag.", "Creates a {@link Behavior} that uses the given {@link SerializableConsumer consumer}\nto do something with the component's tag.", "Creates a {@link Behavior} that uses the given {@link SerializableConsumer consumer} to do something with the component's tag.", "Creates a {@link Behavior} that uses the given {@link SerializableConsumer consumer} to do something with the component's tag.", "Creates a {@link Behavior} that uses the given {@link SerializableConsumer consumer} to do something with the component's tag."]}
{"SampleId": 3964812, "Origin": "Accumulate secondarys into a LinkedListX (extended Persistent List) and Right with the supplied combiner function", "Reference": "Accumulate secondarys into a LazySeq (extended Persistent List) and Right with the supplied combiner function", "LLMCandidates": ["Accumulate secondarys into a LazySeq (extended Persistent List) and Right with the supplied combiner function", "Accumulate secondarys into a LazySeqX (extended Persistent List) and Right with the supplied combiner function", "Accumulate secondarys into a LazySeq (extended Persistent List) and Right with the supplied combiner function", "Accumulate secondarys into a LazySeq (extended Persistent List) and Right with the supplied combiner function", "Accumulate secondarys into a LazySeq<LT> (extended Persistent List) and Right with the supplied combiner function"]}
{"SampleId": 2872597, "Origin": "Retrieves the position in the list corresponding to itemId.", "Reference": "Retrieves the position in the list corresponding to itemId, subtracting any header views.", "LLMCandidates": ["Retrieves the position in the list corresponding to itemId, taking into account header views by returning the result minus the number of header views.", "Retrieves the position in the list corresponding to itemId, adjusted for header views.", "Retrieves the position in the list corresponding to itemId, considering the header views count.", "Retrieves the position in the list corresponding to itemId, considering the headerViewsCount.", "Retrieves the position in the list, considering the header views count and corresponding to itemId."]}
{"SampleId": 2624224, "Origin": "Configures SSL or TLS of the default {@link VirtualHost} from the specified {@code keyCertChainFile}\nand cleartext {@code keyFile}.", "Reference": "Configures SSL or TLS of the {@link Server} from the specified {@code keyCertChainFile}\nand cleartext {@code keyFile}.", "LLMCandidates": ["Configures SSL or TLS of the specified {@link VirtualHost} from the specified {@code keyCertChainFile} and cleartext {@code keyFile}.", "Configures SSL or TLS of the default {@link VirtualHost} from the specified {@code keyCertChainFile} and cleartext {@code keyFile}.", "Configures SSL or TLS of the default {@link VirtualHost} from the specified {@code keyCertChainFile} and cleartext {@code keyFile}.", "Configures SSL or TLS of the default {@link VirtualHost} from the specified {@code keyCertChainFile} and cleartext {@code keyFile}.", "Configures SSL or TLS of the default {@link VirtualHost} from the specified {@code keyCertChainFile} and cleartext {@code keyFile}."]}
{"SampleId": 2337239, "Origin": "Phone Number", "Reference": "Phone number", "LLMCandidates": ["Phone number", "Phone number", "Phone number", "Phone number", "Phone number"]}
{"SampleId": 3991730, "Origin": "Set the number of expected records for this task.", "Reference": "Set the number of expected records for this connector.", "LLMCandidates": ["Set the number of expected records for this task.", "Set the expected number of records for this task.", "Set the number of expected records for this task.", "Set the number of expected records for this task.", "Set the number of expected records for this task."]}
{"SampleId": 2134050, "Origin": "predict\n* predict the rating given a sparse appender vector", "Reference": "Predict the rating given a sparse appender vector.", "LLMCandidates": ["predict(int userId, int itemId, SparseVector x) throws LibrecException - predict the rating given a sparse appender vector", "predict the rating given a sparse appender vector with userId and itemId", "predict\n* predict the rating given a sparse appender vector and a userId and itemId", "Predict the rating given a sparse appender vector with userId and itemId.", "Predict the rating given a sparse appender vector with userId and itemId."]}
{"SampleId": 3760874, "Origin": "Each of the available players is passed the provided information\nand the first that reports it is compatible will be returned.", "Reference": "Each of the available {@link Player} instances are\npassed the provided information and the first that reports that it is\ncompatible will be returned.", "LLMCandidates": ["Each of the available players is passed the provided information and the first that reports it is compatible will be returned. If none are compatible, a trace message will be logged.", "Each of the available players is passed the provided information and the first that reports it is compatible will be returned.", "The first available player that is compatible with the provided resource will be returned.", "Each of the available players is passed the provided resource information and the first that reports it is compatible will be returned.", "Each of the available players is passed the provided resource information and the first that reports it is compatible will be returned."]}
{"SampleId": 617914, "Origin": "Adding fields to a POJO as operator state should require a state migration.", "Reference": "Adding fields to a POJO as operator state should succeed.", "LLMCandidates": ["Tests adding a field with operator state should require a state migration.", "Adding fields to a POJO as operator state should require a state migration.", "Adding fields to a POJO as operator state should require a state migration.", "Adding fields to a POJO as operator state should require a state migration.", "Adding fields to a POJO as operator state should require a state migration. This test ensures that additional field is added with the operator state for POJO serialization upgrade."]}
{"SampleId": 5630039, "Origin": "Sets the sensitivity.", "Reference": "Set the sensitivity.", "LLMCandidates": ["Sets the sensitivity using a builder pattern.", "Sets the sensitivity using a Builder pattern.", "Sets the sensitivity for the Builder instance.", "Sets the sensitivity for the Builder instance.", "Sets the sensitivity for the Builder instance."]}
{"SampleId": 340617, "Origin": "Requests that the player prefetch a media item with the media id for playback.", "Reference": "Requests that the player prepare a media item with the media id for playback.", "LLMCandidates": ["Requests that the player prepare a media item with the media id for playback.", "Requests that the player prepare a media item with the media id for playback.", "Requests that the player prepare a media item with the media id for playback.", "Requests that the player prepare a media item with the media id for playback.", "Requests that the player prepare a media item with the media id for playback."]}
{"SampleId": 4476666, "Origin": "Creates a new block blob, or updates the content of an existing block blob.", "Reference": "Creates a new block blob.", "LLMCandidates": ["Creates a new block blob, or updates the content of an existing block blob with an optional flag to indicate whether it should be appended.", "Creates a new block blob, or updates the content of an existing block blob with an additional option to enable/disable append operation.", "Creates a new block blob, or updates the content of an existing block blob with a specified boolean value for overwrite mode.", "Creates a new block blob, or updates the content of an existing block blob.", "Creates a new block blob, or updates the content of an existing block blob."]}
{"SampleId": 4479525, "Origin": "Get the etag property: The etag property.", "Reference": "Get the eTag property: The eTag property.", "LLMCandidates": ["Get the ETag property: The ETag property.", "Get the ETag property: The ETag property.", "Get the ETag property: The ETag property.", "Get the ETag property: The ETag property.", "Get the ETag property: The ETag property."]}
{"SampleId": 2484852, "Origin": "Causes  to have its \nmethod called in the event dispatch thread with low priority.", "Reference": "Causes runnable to have its run method called in the\nevent dispatch thread with low priority.", "LLMCandidates": ["Causes the given Runnable object to be called in the event dispatch thread with low priority using defaultToolkit.getSystemEventQueue().postEvent() method.", "Causes this method to have its  runnable object called in the event dispatch thread with low priority.", "Causes the given Runnable to be called in the event dispatch thread with low priority.", "Calls the given Runnable on the event dispatch thread with a low priority using the default Toolkit instance.", "Causes a given Runnable to be called in the event dispatch thread with low priority."]}
{"SampleId": 4903008, "Origin": "Checks if the deletion policy can release some index commits with the latest global checkpoint.", "Reference": "Checks if the deletion policy can delete some index commits with the latest global checkpoint.", "LLMCandidates": ["Checks if there are any index commits with a sequence number lower than or equal to the global checkpoint, which means they can be cleaned up safely.", "Checks if any index commits with sequence numbers less than or equal to the current global checkpoint can be deleted.", "Checks if the deletion policy can release any index commits with the latest global checkpoint.", "Checks if the deletion policy can release some index commits with the latest global checkpoint by comparing maxSeqNoOfNextSafeCommit and globalCheckpointSupplier.getAsLong().", "Checks if the deletion policy can release some index commits with the latest global checkpoint."]}
{"SampleId": 617915, "Origin": "Removing fields from a POJO as keyed state should require a state migration.", "Reference": "Removing fields from a POJO as keyed state should succeed.", "LLMCandidates": ["Removing fields from a POJO as keyed state should require a state migration.", "Removing fields from a POJO as keyed state should require a state migration.", "Removing fields from a POJO as keyed state should require a state migration.", "Test a POJO with missing fields when transitioning from one state to another should require state migration.", "Test a POJO with missing fields when transitioning from one state to another should require state migration."]}
{"SampleId": 5845110, "Origin": "When a layout is rendered in the layout, it is fetching resources from the app resource repository: it should see all the resources\njust like the app does.", "Reference": "When a layout is rendered in the layout editor, it is getting resources from the app resource repository: it should see all\nthe resources just like the app does.", "LLMCandidates": ["The method getAppResources returns an instance of LocalResourceRepository from the app resource repository, using AppManager to run a read action.", "When a layout is rendered in the layout, it is fetching resources from the app resource repository: it should see all the resources just like the app does.", "Fetches resources from the app resource repository, ensuring it sees all resources just like the app does.", "Fetching resources from the app resource repository for rendering a layout in the layout should see all the resources just like the app does.", "Get the AppResources from a repository. If there are no resources, create them and register them with the Disposer. Return the resources."]}
{"SampleId": 6034464, "Origin": "Enables initial {@literal PING} barrier before any connection is usable.", "Reference": "Returns the {@link ProtocolVersion} to use.", "LLMCandidates": ["Returns the current ProtocolVersion being used.", "Enables initial {@literal PING} barrier before any connection is usable.", "Enables initial {@literal PING} barrier before any connection is usable.", "Retrieves the current protocol version used by the system.", "Retrieves the current protocol version used by the system."]}
{"SampleId": 3242213, "Origin": "Get the content of this element.", "Reference": "Gets the value of the content property.", "LLMCandidates": ["Get the content of this element.", "Get the content of this element.", "Get the content of this element.", "Get the content of this element.", "Get the content of this element."]}
{"SampleId": 2535872, "Origin": "Extract the values of given field or property from the array's elements under test into a new array, this new array\nbecoming the array under test.", "Reference": "Extract the values of given field or property from the array's elements under test into a new list, this new list\nbecoming the object under test.", "LLMCandidates": ["Extract the values of given field or property from the array's elements under test into a new array, this new array becoming the array under test.", "Extract the values of given field or property from the array's elements under test into a new array, this new array becoming the array under test.", "Extract the values of given field or property from the array's elements under test into a new array, this new array becoming the array under test, using the list assert instance to create an AbstractListAssert object. The resulting object will have a description based on the extractedDescription and the info.description().", "Extract the values of given field or property from the array's elements under test into a new array, this new array becoming the array under test and being asserted with a suitable description.", "Extract the values of given field or property from the array's elements under test into a new array, this new array becoming the array under test."]}
{"SampleId": 671354, "Origin": "Converts a JSON document into a PdxInstance", "Reference": "Converts a Byte Array JSON document into a PdxInstance", "LLMCandidates": ["@inheritDoc} Converts a JSON document into a PdxInstance with the optional identity fields.", "Converts a JSON document into a PdxInstance using specified identity fields", "Converts a JSON document into a PdxInstance using specified identity fields", "Converts a JSON document into a PdxInstance with optional identity fields specified in the argument list.", "Converts a JSON document into a PdxInstance with the specified identityFields"]}
{"SampleId": 3512219, "Origin": "Gets the current {@link Art} value represented by this {@link Painting}.", "Reference": "Gets the current {@link ArtType} value represented by this {@link Painting}.", "LLMCandidates": ["Gets the current {@link ArtType} value represented by this {@link Painting}.", "Gets the current {@link ArtType} value represented by this {@link Painting}.", "Gets the current {@link ArtType} value represented by this {@link Painting}.", "Gets the current {@link ArtType} value represented by this {@link Painting}.", "Gets the current {@link ArtType} value represented by this {@link Painting}."]}
{"SampleId": 3894604, "Origin": "In error message, exclude {@code @rultor} from list of commanders (REF).", "Reference": "QnAskedBy can exclude {@code @rultor} from list of commanders (REF).", "LLMCandidates": ["Tests if {@code rultor} is excluded from the list of commanders in a GitHub repository and checks the error message.", "The test ensures that the error message excludes {@code @rultor} from the list of commanders when checking the Github repository.", "Exclude {@code @rultor} from list of commanders when displaying authorized commanders (REF).", "Ensure that the comment only includes {@code @testuser1} and {@code @testuser2}, not {@code @rultor}.", "In error message, exclude {@code @rultor} from list of commanders."]}
{"SampleId": 1843359, "Origin": "WebElement#getText()} equals to provided {@code expectedText}.", "Reference": "WebElement#getText()} equals to provided {@code expected} one.", "LLMCandidates": ["wait for the WebElement#getText() to be equal to the provided {@code expectedText} within a specified timeout.", "Wait for the text of WebElement#getText() to be equal to provided {@code expected}.", "Waits for the WebElement's text to equal the provided expected value within a specified timeout period. If not successful, prints a formatted error message with both the expected and actual texts.", "waitTextEqualsTo(WebElement element, String expected, int timeout). Checks if the visible text of the specified web element equals to the provided {@code expected} string within the given timeout. If not, it returns an error message with the actual text and the expected one.", "Waits for WebElement's text to be equal to the provided expected text within a specified timeout."]}
{"SampleId": 2700102, "Origin": "Set UPC/EAN.", "Reference": "Set CU-UPC.", "LLMCandidates": ["Set UPC/EAN_CU.", "Set UPC/EAN_CU.", "Set UPC/EAN_CU.", "Set UPC/EAN_CU.", "Set UPC/EAN_CU."]}
{"SampleId": 4396695, "Origin": "Returns a string representation of this object; useful for testing and debugging.", "Reference": "Returns a string representation of this object.", "LLMCandidates": ["Returns a string representation of this object; useful for testing and debugging with sensitive data redacted where necessary.", "This method returns a string representation of this object; useful for testing and debugging.", "Returns a string representation of this object; useful for testing and debugging. Sensitive data is redacted with ***Sensitive Data Redacted*** in the output.", "The toString() method returns a formatted string representation of the object for testing and debugging purposes.", "Returns a string representation of this object; useful for testing and debugging, with sensitive data redacted."]}
{"SampleId": 4236719, "Origin": "WARNING: Read the javadoc of {@link Component#canCallListenerInterface()} for important\nsecurity-related information.", "Reference": "WARNING: Read the javadoc of {@link Component#canCallListener()} for important\nsecurity-related information.", "LLMCandidates": ["WARNING: Read the javadoc of {@link Component#canCallListener()} for important security-related information.", "WARNING: Read the javadoc of {@link Component#canCallListener()} for important security-related information.", "WARNING: Read the javadoc of {@link Component#canCallListener()} for important security-related information.", "WARNING: Read the javadoc of {@link Component#canCallListener()} for important security-related information.", "WARNING: Read the javadoc of {@link Component#canCallListener()} for important security-related information."]}
{"SampleId": 2916154, "Origin": "They must not be of type {@link KnownAmountPaymentPeriod}.", "Reference": "They must not be of type {@link KnownAmountSwapPaymentPeriod}.", "LLMCandidates": ["They must not be of type {@link KnownAmountPaymentPeriod}.", "They must not be of type {@link KnownAmountPaymentPeriod}.", "They must not be of type {@link KnownAmountPaymentPeriod}.", "They must not be of type {@link SwapAmountPaymentPeriod}.", "Calculate the present value of a benefit payment (PVBP) for a swap leg using the given rates provider. They must not be of type {@link KnownAmountPaymentPeriod}."]}
{"SampleId": 4396563, "Origin": "Returns a string representation of this object; useful for testing and debugging.", "Reference": "Returns a string representation of this object.", "LLMCandidates": ["Returns a string representation of this object; useful for testing and debugging, where sensitive data is redacted.", "Returns a string representation of this object; useful for testing and debugging. If the getVariables() is not null, it will show \"Sensitive Data Redacted\" to hide the actual values.", "Returns a string representation of this object; useful for testing and debugging; sensitive data is redacted", "Returns a string representation of this object; useful for testing and debugging; sensitive data is redacted", "Returns a string representation of this object; useful for testing and debugging, with sensitive data redacted."]}
{"SampleId": 3771649, "Origin": "Checks whether caption and description are interpreted as html or plain\ntext.", "Reference": "Checks whether caption and description are interpreted as HTML or plain\ntext.", "LLMCandidates": ["Checks whether caption and description are interpreted as html or plain text based on the state provided.", "Checks whether caption and description are interpreted as html or plain text based on current state.", "Checks whether caption and description are interpreted as html or plain text based on the current state.", "Checks whether caption and description are interpreted as html or plain text based on the current state.", "Checks whether caption and description are interpreted as html or plain text. The method now uses getState() to access the value of htmlContentAllowed."]}
{"SampleId": 278863, "Origin": "Determines if this BeaconManager instance is part of the process hosting the beacon scanning\nservice.", "Reference": "Determines if this BeaconManager instance is not part of the process hosting the beacon scanning\nservice.", "LLMCandidates": ["Determines if this BeaconManager instance is part of a different process hosting the beacon scanning service.", "Determines if this BeaconManager instance is part of a process separate from the one hosting the beacon scanning service.", "Determines if this BeaconManager instance is part of a process different from the one hosting the beacon scanning service.", "Determines if this BeaconManager instance is part of a process different from the one hosting the beacon scanning service.", "Determines if this BeaconManager instance is part of a different process from the one hosting the beacon scanning service."]}
{"SampleId": 5873660, "Origin": "The domain portion of the ObjectName in the query if useObjDomain is set to true\n3. else, the Class Name of the MBean.", "Reference": "The domain portion of the ObjectName in the query if useObjDomainAsKey is set to true\n3. else, the Class Name of the MBean.", "LLMCandidates": ["The domain portion of the ObjectName in the query if useObjDomain is set to true, else, the Class Name of the MBean.", "Adds an MBean identifier to the query based on key alias, ObjectDomain or Class Name. If useObjDomainAsKey is set to true and there is no keyAlias, appends the cleaned ObjectDomain with AllowDottedKeys option. Otherwise, if useObjDomainAsKey is false, appends the cleaned ClassName.", "The domain portion of the ObjectName in the query if useObjectDomain is set to true; else, the Class Name of the MBean.", "The domain portion of the ObjectName in the query if useObjDomain is set to true; else, the Class Name of the MBean.", "The domain portion of the ObjectName in the query if useObjDomainAsKey is set to true, otherwise the Class Name of the MBean."]}
{"SampleId": 5762169, "Origin": "Forget all entries that match the scheme+host+port of the given key, so\nthat they can be crawled again if discovered again.", "Reference": "Forget all entries that match the scheme+host+port of the given url, so\nthat they can be crawled again if discovered again.", "LLMCandidates": ["Forget all entries that match the scheme+authority of the given URL, so that they can be crawled again if discovered again.", "Forget all entries that match the scheme+authority of the given URL, so that they can be crawled again if discovered again.", "Forget all entries that match the scheme+authority of the given url, so that they can be crawled again if discovered again.", "Forget all entries that match the scheme+authority of the given URL key, so that they can be crawled again if discovered again.", "Forget all entries that match the scheme+authority of the given URL so that they can be crawled again if discovered again."]}
{"SampleId": 5640433, "Origin": "Keys and values are separated by {@value #SEPARATOR}.", "Reference": "Keys and values are separated by {@value #KEY_VALUE_SEPARATOR}.", "LLMCandidates": ["Keys and values are separated by {@value #SEPARATOR}, using a method to parse filters and processing them one-by-one.", "Parses filters using {@value #SEPARATOR} to separate keys and values.", "Keys and values are separated by {@value #SEPARATOR}.", "Initializes the application with filters specified as key-value pairs, where keys and values are separated by {@value #SEPARATOR}.", "Initializes the application with filters specified as key-value pairs, where keys and values are separated by {@value #SEPARATOR}."]}
{"SampleId": 3357863, "Origin": "Set the time a publication will linger in nanoseconds after being drained.", "Reference": "Set the time a network publication will linger in nanoseconds after being drained.", "LLMCandidates": ["Set the time a publication will linger in nanoseconds after being drained.", "Set the time a publication will linger in nanoseconds after being drained.", "Set the time a publication will linger in nanoseconds after being drained.", "Set the time a publication will linger in nanoseconds after being drained.", "Set the time a publication will linger in nanoseconds after being drained."]}
{"SampleId": 4474502, "Origin": "{@codesnippet com.azure.storage.file.share.ShareDirectoryClient.createSubDirectory#string}", "Reference": "{@codesnippet com.azure.storage.file.share.ShareDirectoryClient.createSubdirectory#string}", "LLMCandidates": ["@codesnippet com.azure.storage.file.share.ShareDirectoryClient.createSubdirectory#string", "@codesnippet com.azure.storage.file.share.ShareDirectoryClient.createSubdirectory#string", "/** {@codesnippet com.azure.storage.file.share.ShareDirectoryClient.createSubdirectory#string} */", "@codesnippet com.azure.storage.file.share.ShareDirectoryClient.createSubdirectory#string", "@codesnippet com.azure.storage.file.share.ShareDirectoryClient.createSubdirectory#string"]}
{"SampleId": 2337263, "Origin": "Created by user info", "Reference": "Created by user", "LLMCandidates": ["Created by user", "The returned UserInfo represents the user who created this instance.", "The returned UserInfo represents the user who created this instance.", "Created by user", "Created by user"]}
{"SampleId": 1578381, "Origin": "Retrieves the metadata for the specified {@link NamespacedEntityId}.", "Reference": "Retrieves the metadata for the specified {@link MetadataEntity}.", "LLMCandidates": ["Retrieves the metadata for the specified {@link MetadataEntity}.", "Retrieves the metadata for the specified {@link MetadataEntity}.", "Retrieves the metadata for the specified {@link MetadataEntity}.", "Retrieves the metadata for the specified {@link MetadataEntity}.", "Retrieves the metadata for the specified {@link MetadataEntity}."]}
{"SampleId": 4477036, "Origin": "BlobRange, ParallelTransferOptions, ReliableDownloadOptions, BlobRequestConditions, boolean)}", "Reference": "BlobRange, ParallelTransferOptions, DownloadRetryOptions, BlobRequestConditions, boolean)}", "LLMCandidates": ["client.downloadToFile(file).subscribe(response -> System.out.println(\"Completed download to file\"));}\n\n{client.downloadToFileWithResponse(file, range, null, options, null, false).subscribe(response -> System.out.println(\"Completed download to file\"));", "Downloads a file from Azure Blob storage using downloadToFile() and provides options for customizing the download behavior through ReliableDownloadOptions, BlobRange, ParallelTransferOptions, DownloadRetryOptions, and BlobRequestConditions.", "downloadToFile#String - Begins a method that downloads a file using the client and subscribes to a response. DownloadToFileWithResponse#String-BlobRange-ParallelTransferOptions-DownloadRetryOptions-BlobRequestConditions-boolean - Begins a method with more advanced options for downloading a file, including BlobRange, ParallelTransferOptions, DownloadRetryOptions, BlobRequestConditions, and a boolean flag.", "client.downloadToFile(file).subscribe(response -> System.out.println(\"Completed download to file\")); BlobRange range = new BlobRange(1024, 2048L); DownloadRetryOptions options = new DownloadRetryOptions().setMaxRetryRequests(5); client.downloadToFileWithResponse(file, range, null, options, null, false).subscribe(response -> System.out.println(\"Completed download to file\"));", "downloads a file from a blob using the client."]}
{"SampleId": 5270017, "Origin": "Request for graceful stop then blocks until process is stopped.", "Reference": "Request for quick stop then blocks until process is stopped.", "LLMCandidates": ["Hard-stops the process by immediately terminating its execution without waiting for a graceful shutdown.", "Request for hard stop then blocks until process is stopped.", "Request for hard stop then blocks until process is stopped.", "Hard stop the process identified by processId, then blocks until stopped.", "Hard stop the process identified by processId, then blocks until stopped."]}
{"SampleId": 2384658, "Origin": "For now, just consume the message and throw it away.", "Reference": "Consume the message and save it.", "LLMCandidates": ["Reads a message from the input stream and discards it by converting it to bytes.", "Reads and processes a message from an input stream.", "Consume the message by writing it into a buffer and close when done.", "Read the message from input stream, then set it as the current message.", "Read the message from input stream, then set it as the current message."]}
{"SampleId": 2887747, "Origin": "This signature is the one specified in the\nconstructor (see {@link #SignatureReader(String) SignatureReader}).", "Reference": "This signature is\nthe one specified in the constructor (see {@link #SignatureReader}).", "LLMCandidates": ["This method parses a signature by accepting a SignatureVisitor and performing different actions based on the type of the signature. It is responsible for traversing and interpreting the signature string.", "This signature is parsed by the visitor and used in the method specified in the constructor of SignatureReader class.", "The signature parser parses a string into Java types according to the rules of the Java programming language for method signatures, type parameters, class bounds, and interface bounds. It maintains an offset into the input string which is incremented during each step in the process, with each position pointing to a specific point in the parsed signature.", "This method parses a signature by calling appropriate methods in the SignatureVisitor to process different types of signatures. The signature can be a TypeParameter, MethodSignature, ClassSignature or ThrowsSignature. It starts with '<' if there are any TypeParameters, followed by ReferenceTypeSignatures (for its class bound and interface bounds). If not, it begins with a '(' for a MethodSignature or 'L' for a ClassSignature. After parsing the signatures, it calls visitParameterType(), visitReturnType(), visitExceptionType(), visitSuperclass() and visitInterface() based on the type of signature found.", "This method parses a given signature string according to the specifications of the constructor (see {@link #SignatureReader(String) SignatureReader}). It accepts a visitor that will be called for each type found in the signature. The method is capable of parsing different kinds of signatures such as MethodSignature, ClassSignature, or TypeParameters, and handles the different characters and tokens within these signatures."]}
{"SampleId": 237013, "Origin": "Converts a {@link CreateFileOptions} object to an {@link OpenFileOptions} object with a\nmatching Alluxio storage type.", "Reference": "Converts a {@link CreateFilePOptions} object to an {@link OpenFilePOptions} object with a\nmatching Alluxio storage type.", "LLMCandidates": ["Converts a {@link CreateFilePOptions} object to an {@link OpenFilePOptions} object with a matching Alluxio storage type.", "Converts a {@link CreateFilePOptions} object to an {@link OpenFilePOptions} object with a matching Alluxio storage type.", "Converts a {@link CreateFilePOptions} object to an {@link OpenFilePOptions} object with a matching Alluxio storage type.", "Converts a {@link CreateFilePOptions} object to an {@link OpenFilePOptions} object with a matching Alluxio storage type.", "Converts a {@link CreateFilePOptions} object to an {@link OpenFilePOptions} object with a matching Alluxio storage type."]}
{"SampleId": 1314716, "Origin": "Called when the user reorders the policies in a service.", "Reference": "Called when the user reorders the policies in a API.", "LLMCandidates": ["Called when the user reorders the policies in an API version.", "Called when the user reorders the policies in an API.", "Called when the user reorders the policies in an API.", "Called when the user reorders the policies in an API.", "Called when the user reorders the policies in an API."]}
{"SampleId": 1880460, "Origin": "This lacks a mathematical argument, but is a handcrafted heuristic to avoid\nnumerical problems.", "Reference": "This lacks a thorough mathematical argument, but is a handcrafted heuristic\nto avoid numerical problems.", "LLMCandidates": ["This heuristic computes an initial beta value for t-Stochastic Neighbor Embedding based on the perplexity and dataset size, accounting for degenerate cases with a fallback mechanism. It is inspired by work referenced at the beginning of the code snippet.", "This estimates an initial value for the beta parameter used in t-Stochastic Neighbor Embedding methods for visualization and outlier detection purposes. The method avoids numerical issues by heuristically using a scaling factor based on perplexity and the number of neighboring points. In degenerate cases, where all distances are zero, the initial value is set to 1.", "The method estimates an initial value for Beta based on a DoubleDBIDListIter and perplexity. It avoids numerical problems by employing a heuristic approach. In degenerate cases, the method returns 1. The reference to Schubert and Gertz's work on t-Stochastic Neighbor Embedding is provided for context.", "This handcrafted heuristic estimates the initial value of Beta by adding all distances from objects not equal to the ignore object, dividing by the number of objects and then multiplying by 0.5 times perplexity. In degenerate cases where all distances are zero, it simply returns 1.", "This method calculates an initial beta value for use in t-Stochastic Neighbor Embedding algorithms. It does this by iterating through a list of double values, excluding any that are equal to the provided ignore value, and then summing the non-zero values. If all distances are zero, the method simply returns 1 instead."]}
{"SampleId": 2608946, "Origin": "Tests {@code globalRecommend(Set, int, Set, Set)}.", "Reference": "Tests {@code recommendRelatedItems()(Set, int, Set, Set)}.", "LLMCandidates": ["Tests {@code recommendRelatedItems(Set, int, Set, Set)}.", "Tests {@code recommendRelatedItems(Set, int, Set, Set)}.", "Tests {@code recommendRelatedItems(Set, int, Set, Set)}.", "Tests {@code recommendRelatedItems(Set, int, Set, Set)", "Tests {@code recommendRelatedItems(Set, int, Set, Set)"]}
{"SampleId": 1759643, "Origin": "Setter for the output directory where the data files are stored.", "Reference": "Setter for the directory where the data files are stored.", "LLMCandidates": ["Setter for the directory where the data files are stored.", "Setter for the directory where the data files are stored.", "Setter for the directory where the data files are stored.", "Setter for the directory where the data files are stored.", "Setter for the directory where the data files are stored."]}
{"SampleId": 4470079, "Origin": "In case of\nfailure the {@link Flux} will error.", "Reference": "In case of\nfailure the {@link CosmosContinuablePagedFlux} will error.", "LLMCandidates": ["In case of failure the {@link CosmosContinuablePagedFlux} will error.", "The queryItems method returns a CosmosContinuablePagedFlux of FeedResponse items based on a given SqlQuerySpec and Class. In case of failure the {@link CosmosContinuablePagedFlux} will error.", "In case of failure the {@link CosmosContinuablePagedFlux} will error.", "In case of failure the {@link CosmosContinuablePagedFlux} will error.", "In case of failure, the {@link CosmosContinuablePagedFlux} will error."]}
{"SampleId": 4404087, "Origin": "Note that you do not call", "Reference": "Note that you do\nnot call  with this\n.", "LLMCandidates": ["The method takes a PollForDecisionTaskRequest object, creates an ExecutionContext with it, and starts the AWSRequestMetrics event for ClientExecuteTime. The Request and Response objects are initialized, then the marshalling is done by PollForDecisionTaskRequestMarshaller. The AWSRequestMetrics event ends at RequestMarshallTime. A JsonResponseHandler is created, and the response is received after invoking the request. The method returns the DecisionTask object from the response's AWSResponse.", "Polls for a DecisionTask with the given PollForDecisionTaskRequest, and returns the response containing the DecisionTask. The AWS request metrics are initialized and tracked during the process.", "This method polls for a DecisionTask using an AWSClient and takes a PollForDecisionTaskRequest object as input. The ExecutionContext and AWSRequestMetrics are used to track client execution time and AWS request metrics. Request is marshalled using a specific marshaller, then invoked with the appropriate response handler and context. Finally, the response is unmarshalled into a DecisionTask object and returned.", "Polls for a DecisionTask with the given request parameters and returns the result.", "Polls for a DecisionTask based on the given PollForDecisionTaskRequest and returns the result as a DecisionTask response."]}
{"SampleId": 5452026, "Origin": "Adds a qualified \"exports dynamic\" directive to the declaration.", "Reference": "Adds a qualified \"opens\" directive to the declaration.", "LLMCandidates": ["Adds a qualified \"opens\" directive to the declaration.", "Adds a qualified \"opens\" directive to the declaration.", "Adds a qualified \"opens\" directive to the declaration.", "Adds a qualified \"opens\" directive to the declaration.", "Adds a qualified \"opens\" directive to the declaration."]}
{"SampleId": 1985765, "Origin": "| 2. if it's a right child, it should have a incremented column value.", "Reference": "| If it's a right child, its column should increment by 1.", "LLMCandidates": ["If it's a right child, it should have an incremented column value.", "If it's a right child, it should have a decremented column value.", "If it's a right child, it should have an incremented column value.", "If the current node is a right child, its column value should be incremented.", "If the current node is a right child, its column value should be incremented."]}
{"SampleId": 2482285, "Origin": "Queries this search source for the given queryString.", "Reference": "Creates query for the given queryString.", "LLMCandidates": ["Queries this search source for the given queryString.", "Queries this search source for the given queryString using createContactQuery method.", "Queries this search source for the given queryString using the specified method for creating a contact query.", "Queries this search source for the given queryString.", "Queries this search source for the given queryString."]}
{"SampleId": 4470466, "Origin": "Gets the list of {@link CertificateProperties CertificateProperties} on this page.", "Reference": "Gets the iterable stream of {@link CertificateProperties CertificateProperties} on this page.", "LLMCandidates": ["Get the iterable stream of {@link CertificateProperties CertificateProperties} on this page.", "Gets an IterableStream of {@link CertificateProperties CertificateProperties} on this page.", "Gets an IterableStream of {@link CertificateProperties CertificateProperties} on this page.", "Gets the list of {@link CertificateProperties CertificateProperties} on this page.", "Gets the IterableStream of {@link CertificateProperties CertificateProperties} on this page."]}
{"SampleId": 2312346, "Origin": "Users\ncannot poke the threshold values via this Condition.", "Reference": "Users must not poke the threshold values via this Condition.", "LLMCandidates": ["Users cannot poke the threshold values via this ConditionWithin.", "Users cannot poke the threshold values via this ConditionWithin.", "Users cannot poke the threshold values via this ConditionWithin.", "Users cannot poke the threshold values via this ConditionWithin.", "Users cannot poke the threshold values via this ConditionWithin."]}
{"SampleId": 2616149, "Origin": "Parses the {@code Rectangle} represented by the given string according to the format of {@link #toString()}.", "Reference": "Sets this {@code Rectangle} to the value represented by the specified string according to the format of {@link #toString()}.", "LLMCandidates": ["Parses the Rectangle represented by the given string according to the format of {@link #toString()}.", "Parses the {@code Rectangle} represented by the given string according to the format of {@link #toString()}.", "Parses the Rectangle represented by the given string according to the format of {@link #toString()}.", "Parses a {@code Rectangle} represented by the given string according to the format of {@link #toString()}.", "Parses a {@code Rectangle} represented by the given string according to the format of {@link #toString()}."]}
{"SampleId": 3573462, "Origin": "Set name of the noun.", "Reference": "Set the noun.", "LLMCandidates": ["Set the noun with the given String value.", "Set noun.", "Set noun.", "Set the noun.", "Set the noun."]}
{"SampleId": 2302360, "Origin": "Delegateaction to the track(s) clicked on.", "Reference": "Delegate action to the track(s) clicked on.", "LLMCandidates": ["Delegate action to the track(s) clicked on.", "Delegate action to the track(s) clicked on in the igv framework.", "Delegate action to the track(s) clicked on in the igv framework.", "Delegate action to the track(s) clicked on.", "Delegate action to the track(s) clicked on."]}
{"SampleId": 1052994, "Origin": "Receive indicator result from persistence, after it is saved into storage.", "Reference": "Receive metrics result from persistence, after it is saved into storage.", "LLMCandidates": ["Receive metrics result from persistence, after it is saved into storage.", "Receive metrics result from persistence, after it is saved into storage.", "Receive metrics result from persistence, after it is saved into storage.", "Receive metrics result from persistence, after it is saved into storage.", "Receive metrics result from persistence, after it is saved into storage."]}
{"SampleId": 1328525, "Origin": "Sets the journal serializer, returning the builder for method chaining.", "Reference": "Sets the journal namespace, returning the builder for method chaining.", "LLMCandidates": ["Sets the journal namespace, returning the builder for method chaining.", "Sets the journal namespace, returning the builder for method chaining.", "Sets the journal namespace, returning the builder for method chaining.", "Sets the namespace, returning the builder for method chaining.", "Sets the namespace, returning the builder for method chaining."]}
{"SampleId": 1066822, "Origin": "Return the {@code Graph} from the underlying switchable.", "Reference": "Return the {@code Graph} from the underlying DatasetGraph", "LLMCandidates": ["Return the {@code Graph} based on the specified graph name or return the default graph from the underlying data structure if no graph name is provided.", "Return the {@code Graph} from the underlying switchable based on the graph name or default graph if none provided.", "Return the {@code Graph} from the underlying switchable based on the specified graph name or returns the default graph if no graph name is provided.", "Return the {@code Graph} from the underlying switchable based on graph name. If no graph name is provided, return the default graph.", "Return the {@code Graph} from the underlying switchable based on the specified graph name or return the default graph if no graph name is provided."]}
{"SampleId": 1353787, "Origin": "(Try to) create a Flag inter (either standard FlagInter or SmallFlagInter).", "Reference": "(Try to) create and add a Flag inter (either standard FlagInter or SmallFlagInter).", "LLMCandidates": ["Create a valid FlagInter object from provided input parameters such as glyph, shape, grade, system information, and inter list. This method returns the created FlagInter instance if found to be valid based on lookupLink(systemStems), otherwise it returns null.", "Create a Flag inter (either standard AbstractFlagInter or SmallFlagInter).", "Create a valid FlagInter object given glyph, shape, and grade parameters, along with system information and a list of stems to look up links. If a link is found, add the flag to the system signature and apply the link. Return the created flag or null if none are found.", "Create a valid flag inter (either standard FlagInter or SmallFlagInter).", "Create a valid flag inter (either standard FlagInter or SmallFlagInter)."]}
{"SampleId": 4396618, "Origin": "Returns a string representation of this object; useful for testing and debugging.", "Reference": "Returns a string representation of this object.", "LLMCandidates": ["Returns a string representation of this object; useful for testing and debugging, with sensitive data redacted.", "Returns a string representation of this object; useful for testing and debugging while redacting sensitive data.", "Returns a string representation of this object; useful for testing and debugging, with sensitive data redacted in the payload.", "Returns a string representation of this object; useful for testing and debugging. If the Payload contains sensitive data, it will be redacted with \"***Sensitive Data Redacted***\" to protect confidentiality.", "Returns a string representation of this object; useful for testing and debugging; note that sensitive data is redacted with \"***Sensitive Data Redacted***\" when present."]}
{"SampleId": 5435232, "Origin": "If the new lookup class is not within the same package member\nas the old one, private members will not be accessible, and protected members\nwill not be accessible by virtue of inheritance.", "Reference": "If the new lookup class is not within the same package member\n as the old one, private members will not be accessible, and protected members\n will not be accessible by virtue of inheritance,\n i.e.", "LLMCandidates": ["If the new lookup class is not within the same package or module member as the old one, private and protected members will not be accessible by virtue of inheritance.", "If the new lookup class is not within the same package member or module as the old one, private members will not be accessible, and protected members will not be accessible by virtue of inheritance.", "If the new lookup class is not within the same package member or module as the old one, private members will not be accessible, and protected members will not be accessible by virtue of inheritance.", "If the new lookup class is not within the same package member or module as the old one, private members will not be accessible and protected members will not be accessible by virtue of inheritance.", "If the new lookup class is not within the same package member as the old one, private members will not be accessible, and protected members will not be accessible by virtue of inheritance."]}
{"SampleId": 2913759, "Origin": "Obtains an instance from the specified unique name.", "Reference": "Obtains an instance from the specified name.", "LLMCandidates": ["Obtains an instance from the specified unique name using a parser.", "Obtains an instance from the specified name.", "Obtains an instance from the specified name.", "Obtains an instance from the specified unique name by parsing it using NAMES.parse(name).", "Obtains an instance from the specified unique name by parsing it using NAMES.parse(name)."]}
{"SampleId": 1356182, "Origin": "Report the ID of the sample sheet that contains the provided sample.", "Reference": "Report the name of the sample sheet that contains the provided sample.", "LLMCandidates": ["Return the name of the sample sheet that contains the provided sample.", "Report the name of the sample sheet that contains the provided sample.", "Retrieve the name of the sample sheet that contains the provided sample.", "Retrieve the name of the sample sheet that contains the provided sample.", "Return the name of the sample sheet that contains the provided sample."]}
{"SampleId": 576503, "Origin": "The format used is ISO 8601-like:\nH:m:s.S.", "Reference": "The format used is ISO 8601-like: {@code HH:mm:ss.SSS}.", "LLMCandidates": ["The format used is ISO 8601-like with a capitalized 'H': HH:mm:ss.SSS.", "The format used is ISO 8601-like with HH for hours and H for hours (24 hour clock):\nHH:mm:ss.SSS", "The format used is ISO 8601-like with a minor modification: HH:mm:ss.SSS.", "The format used is ISO 8601-like: HH:mm:ss.SSS", "The format used is now ISO 8601-like:\nHH:mm:ss.SSS\n\n{Your response"]}
{"SampleId": 2251648, "Origin": "Get the object, and return it, throws RuntimeException", "Reference": "Get the object, and return it, throws RuntimeException if not found", "LLMCandidates": ["Get the object associated with the given key and return it; throws RuntimeException if key not found.", "Get the object based on a String key, and return it if found; otherwise, throw RuntimeException for key not found.", "Get an object using a key string and return it, throws RuntimeException if not found.", "Get an object using a key string and return it, throws RuntimeException if not found.", "Get the object by key, and return it, throws RuntimeException if not found."]}
{"SampleId": 2939253, "Origin": "This polling job tries to find another UPnP\ndevices related to same Samsung TV and create handler for those.", "Reference": "This function tries to find another UPnP\ndevices related to same Samsung TV and create handler for those.", "LLMCandidates": ["Checks for missing UPnP services and creates them. Additionally, it checks if a manual connection should be created. This method listens to the registry of devices and handles any new devices found.", "This polling job tries to find any missing UPnP devices related to the same Samsung TV and create handlers for those. Additionally, it checks if a manual connection should be established.", "This polling job tries to find missing UPnP services and create handlers for those.", "This polling job tries to find other UPnP devices related to the same Samsung TV and create handlers for those, also checking to create a manual connection.", "This polling job tries to find other UPnP devices related to the same Samsung TV and create a handler for those, also checks to create manual connection if necessary."]}
{"SampleId": 4474437, "Origin": "{@codesnippet com.azure.storage.file.datalake.DataLakeDirectoryAsyncClient.deleteSubDirectory#String}", "Reference": "{@codesnippet com.azure.storage.file.datalake.DataLakeDirectoryAsyncClient.deleteSubdirectory#String}", "LLMCandidates": ["Public Mono<Void> deleteSubdirectory(String subdirectoryName). This method is used to delete a subdirectory named 'subdirectoryName'. If an exception is encountered during the deletion process, it will return monoError with the error message.", "@codesnippet com.azure.storage.file.datalake.DataLakeDirectoryAsyncClient.deleteSubdirectory#String", "/**\n * Deletes a subdirectory in Data Lake Storage Gen2 by its name. \n * @param subdirectoryName The name of the subdirectory to delete. \n */", "Deletes a subdirectory within a data lake storage file system. The method takes the name of the subdirectory to delete and returns a Mono<Void>. If an exception occurs during execution, it is caught and wrapped in a MonoError for further processing.", "@codesnippet com.azure.storage.file.datalake.DataLakeDirectoryAsyncClient.deleteSubdirectory#String"]}
{"SampleId": 4471749, "Origin": "If {@code labels = \"\\0\"}, settings without any label are returned.", "Reference": "If {@code labelFilter = \"\\0\"}, settings without any label are returned.", "LLMCandidates": ["If {@code labelFilter = \"\\0\"}, settings without any specified label filter are returned.", "If {@code labelFilter = \"\"}, settings without any specific label filter are returned.", "If {@code labelFilter = \"\"}, settings without any specific label filter are returned.", "If {@code labelFilter = \"\"}, settings without any label are returned.", "If {@code labelFilter = \"\\0\"}, settings without any label are returned."]}
{"SampleId": 6165109, "Origin": "The namespaceDocument is a BsonDocument containing the values associated with a MongoNamespace.", "Reference": "The namespace document is a BsonDocument containing the values associated with a MongoNamespace.", "LLMCandidates": ["The namespaceDocument is a BsonDocument containing the values associated with a MongoNamespace. It can be @Nullable, meaning that it might not always have a value assigned to it.", "The namespaceDocument is a potentially empty BsonDocument containing the values associated with a MongoNamespace, if available.", "The namespaceDocument is a BsonDocument containing the values associated with a MongoNamespace, and may be nullable.", "The namespaceDocument is a BsonDocument containing the values associated with a MongoNamespace, and may be nullable.", "The namespaceDocument is a BsonDocument containing the values associated with a MongoNamespace. The method now adds a @Nullable annotation to indicate that the return value may be null."]}
{"SampleId": 3083929, "Origin": "Returns a supplier that returns the current language instance.", "Reference": "Returns a reference that returns the current language instance.", "LLMCandidates": ["Returns a LanguageReference that returns the current language instance.", "Returns a language reference that returns the current language instance.", "Returns a reference that returns the current language instance.", "Returns a reference that returns the current language instance.", "Returns a language reference that returns the current language instance."]}
{"SampleId": 5203568, "Origin": "After the recreation, it brings back its lifecycle state to the resumed state.", "Reference": "After the recreation, it brings back its lifecycle state to the original state.", "LLMCandidates": ["After the recreation process, it moves back to its previous stage if possible or to a resumed state if the previous stage was transient.", "After the recreation, it moves back to the original stage. If the original stage was a transient state (PAUSED or STOPPED), it will bring it to the RESUMED state to match the on-device behavior.", "This method simulates the Activity recreation process on behalf of ActivityThread and sets the \"mChangingConfigurations\" flag to true. After recreating, it moves back to the original stage by calling different methods depending on the stage (e.g., pause(), stop() or nothing). This way, the activity's lifecycle state is restored after the recreation.", "The comment indicates that after the activity is recreated, it moves back to its original stage, with pause and stop being executed if necessary, before resuming its lifecycle.", "This method simulates Activity recreation process on behalf of ActivityThread by setting the Activity's \"mChangingConfigurations\" flag and restoring its lifecycle state to the resumed state."]}
{"SampleId": 3242255, "Origin": "Create an instance of {@link CTWebProperties }", "Reference": "Create an instance of {@link CTRel }", "LLMCandidates": ["Create an instance of {@link CTRel", "Create an instance of {@link CTRel", "Create an instance of {@link CTRel", "Create an instance of {@link CTRel", "Create an instance of {@link CTRel"]}
{"SampleId": 2337259, "Origin": "Classification ID (for files only): * `1` - public * `2` - for internal use only * `3` - confidential * `4` - strictly confidential", "Reference": "Classification ID: * `1` - public * `2` - internal * `3` - confidential * `4` - strictly confidential", "LLMCandidates": ["Classification ID: * `1` - public * `2` - internal * `3` - confidential * `4` - strictly confidential", "Classification ID: * `1` - public * `2` - internal * `3` - confidential * `4` - strictly confidential", "Classification ID: * `1` - public * `2` - internal * `3` - confidential * `4` - strictly confidential", "Classification ID: * `1` - public * `2` - internal * `3` - confidential * `4` - strictly confidential", "Classification ID: * `1` - public * `2` - internal * `3` - confidential * `4` - strictly confidential"]}
{"SampleId": 1750901, "Origin": "Appends to a collection column, as in {@code SET l+=?}.", "Reference": "Appends to a collection column, as in {@code SET l=l+?}.", "LLMCandidates": ["Appends to a column with a specific suffix.", "Appends to a collection column, as in {@code SET l+=?}.", "Appends to a collection column, as in {@code SET l+=?}.", "Appends to a collection column, as in {@code SET l=?", "Appends to a collection column, as in {@code SET l+=?}."]}
{"SampleId": 2127259, "Origin": "Start a Task with a Tag to identify it and with a time threshold; a task represents some work\nthat spans some time, and you are interested in both its start time and end time.", "Reference": "End a Task with a Tag to identify it; a task represents some work that spans some time, and\nyou are interested in both its start time and end time.", "LLMCandidates": ["Start a Task with a Tag to identify it; a task represents some work that spans some time, and you are interested in its end time.", "Start a Task with a Tag to identify it; a task represents some work that spans some time and you are interested in its end time.", "Start a Task with a Tag to identify it and with a time threshold; a task represents some work that spans some time, and you are interested in both its start time and end time. This method is now called \"taskEnd\" instead of \"taskStartWithMinPeriod\".", "Start a Task with a Tag to identify it; a task represents some work that spans some time, and you are interested in both its start and end times.", "Start a Task with a Tag to identify it; a task represents some work that spans some time, and you are interested in its end time."]}
{"SampleId": 2913708, "Origin": "Obtains an instance from the specified unique name.", "Reference": "Obtains an instance from the specified name.", "LLMCandidates": ["Obtains an instance from the specified name.", "Obtains an instance from the specified unique name.", "Obtains an instance from the specified unique name.", "Obtains an instance from the specified unique name.", "Obtains an instance from the specified unique name by parsing it from a given list of names."]}
{"SampleId": 6048292, "Origin": "or throws a {@link com.liferay.mail.NoSuchAccountException} if it could not be found.", "Reference": "or throws a {@link NoSuchAccountException} if it could not be found.", "LLMCandidates": ["Finds an account by userId and address. Throws a {@link com.liferay.mail.NoSuchAccountException} if it could not be found.", "This method finds an Account by user ID (userId) and email address (address). If the Account is not found, it throws a {@link com.liferay.mail.NoSuchAccountException}.", "public static com.liferay.mail.model.Account findByU_A(long userId, java.lang.String address) throws com.liferay.mail.NoSuchAccountException; } throws a {@link com.liferay.mail.NoSuchAccountException} if it could not be found.", "Finds an Account by its userId and address. Throws a {@link com.liferay.mail.NoSuchAccountException} if it could not be found.", "Finds an account with the specified user ID and email address or throws a {@link com.liferay.mail.NoSuchAccountException} if it could not be found."]}
{"SampleId": 5828271, "Origin": "Loads the update center data, if any and if modified since last read.", "Reference": "Loads the update center data, if any.", "LLMCandidates": ["Loads the update center data if it has been modified since last read and if it exists.", "Loads the update center data if it has been modified since last read.", "Loads the update center data if it has been modified since last read.", "Loads the update center data if it exists and if modified since last read.", "Loads the update center data if it exists and if modified since last read."]}
{"SampleId": 3923671, "Origin": "Produces a Collapsed SemanticGraph with no extras.", "Reference": "Produces a Collapsed SemanticGraph.", "LLMCandidates": ["Produces a Collapsed SemanticGraph with no extras. (Deprecated method)", "This method generates a Collapsed SemanticGraph with no extras, but it is now deprecated and should not be used.", "Produces a Collapsed SemanticGraph with no extras (deprecated).", "Produces a Collapsed SemanticGraph with no extras (deprecated).", "Produces a Collapsed SemanticGraph with no extras."]}
{"SampleId": 5218897, "Origin": "Is has plain column or not.", "Reference": "Contains plain column or not.", "LLMCandidates": ["Checks if a table contains a plain column with the given logicTable.", "Checks if a table with a given logicTable contains a plain column or not.", "Checks if a table has a plain column with the given logicTable name.", "Checks if a table has a plain column.", "Checks if a table has a plain column."]}
{"SampleId": 1352583, "Origin": "Report the note which if vertically farthest from stem tail.", "Reference": "Report the highest note by default.", "LLMCandidates": ["Return the highest note in the chord.", "Return the highest note in the chord.", "Return the highest note in the chord.", "Return the highest note in the chord.", "Return the highest note in the chord."]}
{"SampleId": 5589244, "Origin": "If the given language code is {@code null}, uses {@link DisplaySettings#getContentLanguage(Context)}.", "Reference": "If the given language code is {@code null}, uses {@link DisplaySettings#getShowsLanguage(Context)}.", "LLMCandidates": ["If the given language code is {@code null}, uses {@link DisplaySettings#getShowsLanguage(Context)}.", "If the given language code is {@code null}, uses {@link DisplaySettings#getShowsLanguage(Context)}.", "If the given language code is {@code null}, uses {@link DisplaySettings#getShowsLanguage(Context)}.", "If the given language code is {@code null}, uses {@link DisplaySettings#getShowsLanguage(Context)}.", "If the given language code is {@code null}, uses {@link DisplaySettings#getShowsLanguage(Context)}."]}
{"SampleId": 5844942, "Origin": "Creates an Android framework resource repository without using a persistent cache.", "Reference": "Creates an Android framework resource repository.", "LLMCandidates": ["Creates an Android framework resource repository with optional use of a persistent cache and a specified executor for creating it.", "Creates an Android framework resource repository with optional use of a persistent cache and customized cache creation executor.", "Creates an Android framework resource repository using a persistent cache and optional executor for cache creation tasks.", "Creates an Android framework resource repository with the option to use a persistent cache and execute cache creation asynchronously using a specified Executor.", "Creates an Android framework resource repository with optional persistent cache and custom executor for cache creation tasks."]}
{"SampleId": 5631353, "Origin": "Convert file to HTML.", "Reference": "Convert document to HTML.", "LLMCandidates": ["Convert file to HTML using provided options.", "Converts a file to HTML using specified input options.", "Converts a file to HTML using specified input options.", "Convert a file into an HTML format using given options.", "Convert a file into an HTML format using given options."]}
{"SampleId": 1354710, "Origin": "Try to detect link between this Slur instance and head on left side\nplus head on right.", "Reference": "Try to detect link between this Slur instance and head on left side\nplus head on right side.", "LLMCandidates": ["The method searches for a link between this Slur instance and heads on both sides. It defines slur side areas, retrieves candidate chords, selects the best link pair, and returns the detected links if found.", "Look up link pairs between this Slur instance and head on left side plus head on right using slur side areas, candidate chords, and system information to form a list of links.", "Find link pairs between this Slur instance and heads on left and right side using provided information from the system.", "Search for a link between this Slur instance and heads on both left and right sides.", "This method finds link pairs between a given Slur instance and heads on both sides of it using provided system information. It defines slur side areas, retrieves candidate chords, selects the best link pair, and returns the resulting links."]}
{"SampleId": 1548425, "Origin": "Slight performance increase over {@link #render(BufferBuilder)}.", "Reference": "Slight performance increase over {@link #render(VertexBuffer)}.", "LLMCandidates": ["Provides a slight performance increase over {@link #render(VertexBuffer)}.", "Provides a minor performance increase over {@link #render(VertexBuffer)}.", "Slight performance increase over {@link #render(VertexBuffer)}.", "Slight performance increase over {@link #render(VertexBuffer)}.", "Slight performance increase over {@link #render(VertexBuffer)}."]}
{"SampleId": 2133750, "Origin": "Calculate a sample's standard deviation.", "Reference": "Calculate the standard deviation.", "LLMCandidates": ["Calculate a sample's standard deviation using a Collection of Numbers.", "Calculate a sample's standard deviation using a Collection of Numbers.", "Calculate a sample's standard deviation using a Collection of Numbers.", "Calculate a collection's standard deviation.", "Calculate a collection's standard deviation."]}
{"SampleId": 2545534, "Origin": "When transforming a vector by the resulting matrix the rotation transformation will be applied first and then the translation.", "Reference": "When transforming a vector by the resulting matrix the rotation - and possibly scaling - transformation will be applied first and then the translation.", "LLMCandidates": ["When transforming a vector by the resulting matrix, the rotation transformation will be applied first and then the translation.", "The transformation applies rotation first followed by translation when transforming a vector using this matrix.", "Transforms a vector by applying rotation transformation first, followed by translation.", "The translation is applied before the rotation, and then the resulting matrix transforms a vector by applying the rotation followed by the translation.", "When transforming a vector by the resulting matrix, the rotation transformation will be applied first, and then the translation."]}
{"SampleId": 6049369, "Origin": "Returns the foo with the primary key or throws a {@link com.liferay.sampleservicebuilder.NoSuchFooException} if it could not be found.", "Reference": "Returns the foo with the primary key or throws a {@link NoSuchFooException} if it could not be found.", "LLMCandidates": ["Finds the Foo with the specified primary key or throws a {@link com.liferay.sampleservicebuilder.NoSuchFooException} if it could not be found.", "Finds the foo with the primary key or throws a {@link com.liferay.sampleservicebuilder.NoSuchFooException} if it could not be found.", "Finds the Foo with the primary key or throws a {@link com.liferay.sampleservicebuilder.NoSuchFooException} if it could not be found.", "Finds the Foo with the specified primary key or throws a {@link com.liferay.sampleservicebuilder.NoSuchFooException} if it could not be found.", "Returns the Foo with the primary key or throws a {@link com.liferay.sampleservicebuilder.NoSuchFooException} if it could not be found."]}
{"SampleId": 2882033, "Origin": "Gets the String or Long id from the key, or null if incomplete", "Reference": "Gets the String or Long id from the key as a Value, or null if incomplete", "LLMCandidates": ["Gets the Long or String id value from the IncompleteKey, or null if incomplete", "Gets the Long or String id from the key, or null if incomplete", "Gets the Long or String id from the key, or null if incomplete", "Gets the Long or String id from the key, or null if incomplete", "Gets the String or Long id from the key, or returns null if incomplete"]}
{"SampleId": 1327914, "Origin": "Returns a list of backup nodes.", "Reference": "Returns a list of follower nodes.", "LLMCandidates": ["Returns a list of followers.", "Returns a list of followers.", "Returns a list of followers.", "Returns a list of followers.", "Returns a list of followers."]}
{"SampleId": 1542632, "Origin": "This method creates a temporary VCF file and it's appropriately named index file, and will delete them on exit.", "Reference": "This method creates a temporary VCF or Bam file and its appropriately named index file, and will delete them on exit.", "LLMCandidates": ["This method creates a temporary file with specified prefix and suffix, and its appropriately named index file, which will be deleted on exit. If the suffix ends with \"vcf.gz\", the index file extension is \".tbi;\". If it ends with \"vcf\", the index file extension is \".idx;\". If it ends with \".bam\", the index file extension is \".bai;\".", "This method creates a temporary indexed file and its corresponding index file, and will delete them on exit. The supported file suffixes are vcf.gz, vcf, and .bam.", "This method creates a temporary file with given prefix and suffix and its appropriately named index file, and will delete them on exit.", "This method creates a temporary indexed file with a given prefix and suffix, and will delete them on exit.", "This method creates a temporary file with the specified prefix and suffix, and it's appropriately named index file if needed; both files will be deleted on exit."]}
{"SampleId": 2050311, "Origin": "Starts the service if not started already and starts all downloads.", "Reference": "Starts the service if not started already and resumes all downloads.", "LLMCandidates": ["Resumes the service if not started already and resumes all downloads.", "Resumes the service if not started already and resumes all downloads.", "Resumes the service if not started already and resumes all downloads.", "Resumes the service if not started already and resumes all downloads.", "Resumes the service if not started already and resumes all downloads."]}
{"SampleId": 125737, "Origin": "Helper method to retrieve the parent folder type.", "Reference": "Helper method to retrieve the parent folder type or  if none available.", "LLMCandidates": ["Helper method to retrieve the parent folder type, considering it may return null.", "Helper method to retrieve the parent folder type if it is not null.", "Helper method to retrieve the parent folder type if it is not null.", "Helper method to retrieve the parent folder type or return null if none found. The method returns the parent folder type based on the provided root path and a cached map of folder types. If no corresponding type is found in the cache, it returns null.", "Helper method to retrieve the parent folder type by adding 8 to n."]}
{"SampleId": 6235650, "Origin": "The input stream should\ncontain an X.509 certificate chain in PEM format.", "Reference": "The input stream should\ncontain an X.509 certificate collection in PEM format.", "LLMCandidates": ["The input stream should contain an X.509 certificate collection in PEM format.", "The input stream should contain a collection of X.509 certificates in PEM format.", "The input stream should contain a collection of X.509 certificates in PEM format.", "The input stream should contain an X.509 certificate chain in PEM format.", "The input stream should contain an X.509 certificate collection in PEM format."]}
{"SampleId": 3389056, "Origin": "Unregister the given event from the current context (provided).", "Reference": "Unregister all methods observing the given event from the provided context.", "LLMCandidates": ["Unregister the given observer from the event based on its instance.", "Unregisters an instance of a specified event from the given context provider. This method iterates through the observers registered for the specified event and removes any observer that is an ObserverMethodListener with the same instance as the provided instance.", "Unregister the given event from the specified instance using its registered type.", "Unregister the given observer from a specific event type using its instance and class. This method removes the specified instance of the event type from the list of observers. If no such observer is found, this method does not perform any action.", "Unregister the given observer from the context by removing it from the list of registered observers."]}
{"SampleId": 1328163, "Origin": "Sets the storage serializer.", "Reference": "Sets the storage namespace.", "LLMCandidates": ["Sets the storage namespace.", "Set the namespace for the builder.", "Set the namespace for the builder.", "Sets the storage namespace.", "Sets the storage namespace."]}
{"SampleId": 2912410, "Origin": "Gets the groups used to find an issuer curve.", "Reference": "Gets the groups used to find an issuer curve by legal entity.", "LLMCandidates": ["Gets the groups used to find an issuer curve using LegalEntityId instead of StandardId.", "Gets the groups used to find an issuer curve with a LegalEntityId key.", "Gets the groups used to find an issuer curve with a LegalEntityId key.", "Gets the groups used to find an issuer curve based on a LegalEntityId rather than StandardId.", "Gets an ImmutableMap of LegalEntityIds and their associated LegalEntityGroups for finding issuer curves."]}
{"SampleId": 1578587, "Origin": "Creates a new {@link MetadataEntity} which consists of the given key and values following the key and values of\nthis {@link MetadataEntity}", "Reference": "Returns a new {@link MetadataEntity} which consists of the given key and values following the key and values of\nthis {@link MetadataEntity}.", "LLMCandidates": ["Appends a key-value pair to the given {@link MetadataEntity} by using the given key and value. The method creates a new {@link MetadataEntity} object which consists of the given key and values following the original {@link MetadataEntity}.", "Appends a new key-value pair to the existing {@link MetadataEntity} based on this instance's details.", "Appends the given key and value to the existing {@link MetadataEntity} instance, preserving the previous values.", "Creates a new {@link MetadataEntity} which consists of the given key and value following the existing key and values in this {@link MetadataEntity}.", "Appends a key-value pair to the given {@link MetadataEntity}. The new entity will consist of the given key and value followed by the key-values of this {@link MetadataEntity}."]}
{"SampleId": 4396433, "Origin": "Returns a string representation of this object; useful for testing and debugging.", "Reference": "Returns a string representation of this object.", "LLMCandidates": ["Returns a string representation of this object; useful for testing and debugging. Sensitive data redacted with \"***Sensitive Data Redacted***\".", "Returns a string representation of this object; useful for testing and debugging, while redacting sensitive data where necessary.", "Returns a string representation of this object; useful for testing and debugging sensitive data.", "Returns a string representation of this object; useful for testing and debugging sensitive data.", "Returns a string representation of this object; useful for testing and debugging sensitive data redacted."]}
{"SampleId": 3677761, "Origin": "The input 2011-01-15 (a Saturday) for parameter (SATURDAY) will return 2011-01-08 (one week earlier).", "Reference": "The input 2011-01-15 (a Saturday) for parameter (SATURDAY) will return 2011-01-08 (seven days earlier).", "LLMCandidates": ["Given 2011-01-15 (a Saturday), it will return 2011-01-08 (one week earlier).", "The input 2011-01-15 (a Saturday) for parameter (SATURDAY) will return 2011-01-08 (one week earlier).", "The input 2011-01-15 (a Saturday) for parameter (SATURDAY) will return 2011-01-08 (one week earlier).", "The input 2011-01-15 (a Saturday) for parameter (SATURDAY) will return 2011-01-08 (one week earlier).", "The input 2011-01-15 (a Saturday) for parameter (SATURDAY) will return 2011-01-08 (one week earlier)."]}
{"SampleId": 3993404, "Origin": "Complete the request.", "Reference": "2.", "LLMCandidates": ["Complete the request by setting the final state based on success or failure, and then invoke completeFutureAndFireCallbacks if successful.", "Completes a batch of work depending on the result of an operation and updates the final state accordingly, either marking it as succeeded or failed.", "Complete the request with the final state based on success or failure, and handle any exceptions accordingly.", "Complete the request by determining if the batch has been successfully produced or not.", "Complete the request by determining if the batch has been successfully produced or not."]}
{"SampleId": 2060821, "Origin": "It tests that the method {@code addEdge}\nwill silently add the missing nodes to the graph, then add the edge connecting them.", "Reference": "Tests that the method {@code addEdge} will silently add the missing nodes to the graph, then\nadd the edge connecting them.", "LLMCandidates": ["This test checks if adding an edge silently adds missing nodes to the graph and then connects them.", "Tests that if the graph is mutable, {@code addEdge} method will silently add missing nodes to the graph and then add an edge connecting them.", "Tests that when adding nodes not present in the graph first using the {@code addNode} method, then subsequently connecting them with edges via {@code putEdge}, it will silently do so and return a successful result.", "The test checks that when using the mutable graph's {@code addEdge} method with nodes not initially present in the graph, the method will silently add those missing nodes to the graph before connecting them.", "Tests that the method {@code addEdge} will silently add the missing nodes to the graph if they are not already present, then connect them with an edge."]}
{"SampleId": 6104045, "Origin": "Will set Object as TAG to this request, wrapped by WeakReference", "Reference": "Will set Object as TAG to underlying AsyncHttpRequest", "LLMCandidates": ["Set Object as TAG to this request, wrapped by WeakReference if null, setRequestTag in AsyncHttpRequest", "Set Object as TAG to this request using AsyncHttpRequest", "Set Object as TAG to this request using AsyncHttpRequest", "Set the initial value by adding 8 to n.", "Set the initial value by adding 8 to n."]}
{"SampleId": 3492756, "Origin": "Whether the channel product is a beta product", "Reference": "Whether the channel product is a betaMarker product", "LLMCandidates": ["Determine if the channel product is a beta product based on the presence of the \"betaMarker\" flag being equal to \"Y\".", "Whether the channel product is a beta product using the specified betaMarker", "Whether the channel product is a beta product using the given betaMarker.", "Whether the channel product is a beta product using the given betaMarker.", "Whether the channel product is a beta product with a specific marker"]}
{"SampleId": 6006976, "Origin": "Write a Chart series as rows in a CSV file.", "Reference": "Export a XYChart series into rows in a CSV file.", "LLMCandidates": ["Write a XYSeries series as rows in a CSV file.", "Write a chart series as rows in a CSV file with updated XYSeries object and path2Dir parameter.", "Write a Chart series as rows in a CSV file, considering the parameter change from Series_AxesChart to XYSeries and path2Dir variable.", "Write a XY series as rows in a CSV file.", "Write a XY series as rows in a CSV file."]}
{"SampleId": 3677760, "Origin": "The input 2011-01-15 (a Saturday) for parameter (SATURDAY) will return 2011-01-22 (one week later).", "Reference": "The input 2011-01-15 (a Saturday) for parameter (SATURDAY) will return 2011-01-22 (seven days later).", "LLMCandidates": ["The input 2011-01-15 (a Saturday) for parameter SATURDAY will return 2011-01-22 (one week later).", "The input 2011-01-15 (a Saturday) for parameter (SATURDAY) will return 2011-01-22 (one week later).", "The input 2011-01-15 (a Saturday) for parameter (SATURDAY) will return 2011-01-22 (one week later).", "The input 2011-01-15 (a Saturday) for parameter (SATURDAY) will return 2011-01-22 (one week later).", "The input 2011-01-15 (a Saturday) for parameter (SATURDAY) will return 2011-01-22 (one week later)."]}
{"SampleId": 2700520, "Origin": "Set Bewegungsdatum.", "Reference": "Set Inventurdatum.", "LLMCandidates": ["Set InventoryDatum.", "Set Bewegungsdatum to InventoryDate.", "Set Bewegungsdatum to InventoryDate.", "Set Bewegungsdatum. Now it is called InventoryDate.", "Set Lagersdatum."]}
{"SampleId": 5631504, "Origin": "Gets the dialogNodeId.", "Reference": "Gets the dialogNode.", "LLMCandidates": ["Get dialogNode.", "Gets the dialogNode.", "Gets the dialogNode.", "Gets the dialogNode.", "Gets the dialogNode."]}
{"SampleId": 2959054, "Origin": "the barChartProperties of the chart", "Reference": "the chartProperties of the chart", "LLMCandidates": ["the chartProperties of the chart", "chartProperties of the chart", "Get the chart properties of the chart.", "Get the chart properties of the chart.", "Get the chart properties of the chart."]}
{"SampleId": 3037217, "Origin": "Gets forwarding function type of the forwarding objective.", "Reference": "Attempts to guess the forwarding function type of the given forwarding\nobjective.", "LLMCandidates": ["Gets forwarding function type of the forwarding objective considering its criteria and meta-data. This method filters out criteria of ethDst type with value MacAddress.NONE as L2 broadcast to treat the objective as L2 unicast if not. Then, it checks which ForwardingFunctionType is compatible with the given criterion types and matches or mismatches criteria found in the forwarding objective, returning the best match among the candidates or UNKNOWN if no suitable match found.", "Gets forwarding function type of the forwarding objective by filtering out criteria which do not match the expected criterion types, and selecting the FFT that best matches the criteria found in the fwd objective.", "Gets forwarding function type of the forwarding objective by considering given criteria and matching it with supported ForwardingFunctionType. If multiple candidates are found, log a warning and return UNKNOWN as result.", "Gets the forwarding function type of a forwarding objective by checking the criterion types found in it.", "Gets forwarding function type of the forwarding objective, considering only criteria found in the fwd objective and filtering out any that match or mismatch the expected criterion types. If there is exactly one matching candidate, it returns that value; if there are no matches, it returns UNKNOWN; otherwise, it logs a warning and returns UNKNOWN."]}
{"SampleId": 5749203, "Origin": "Returns an iterator of all of the registered {@code SaslClientFactory}s where the order is based on the\norder of the Provider registration and/or class path order.", "Reference": "Returns a collection of all of the registered {@code SaslClientFactory}s where the order is based on the\norder of the Provider registration and/or class path order.", "LLMCandidates": ["Returns a collection of all of the registered {@code SaslClientFactory}s where the order is based on the order of the Provider registration and/or class path order.", "Returns an iterator of all of the registered {@code SaslClientFactory}s where the order is based on the order of the Provider registration and/or class path order.", "Returns a collection of all of the registered {@code SaslClientFactory}s where the order is based on the order of the Provider registration and/or class path order.", "Returns a collection of all of the registered {@code SaslClientFactory}s where the order is based on the order of the Provider registration and/or class path order.", "Returns a collection of all of the registered {@code SaslClientFactory}s where the order is based on the order of the Provider registration and/or class path order."]}
{"SampleId": 2229197, "Origin": "Otherwise, it traverses all objects in\ngiven array and adds their scalar values named\n{@code cursor#getNext()} to the result.", "Reference": "Otherwise, it traverses all objects in\ngiven array and adds their scalar values named\n{@code pathCursor#getNext()} to the result.", "LLMCandidates": ["The method traverses all objects in given array, and adds their scalar values to a MultiResult object.", "Traverses all objects in given array and adds their scalar values to the result.", "Traverses all objects in the given array and adds their scalar values found at {@code cursor#getNext()} to the result.", "Traverses all objects in given array, adds their scalar values named {@code cursor#getNext()} to the result.", "Traverses all objects in given array and adds their scalar values named cursor#getNext() to the result."]}
{"SampleId": 1665715, "Origin": "This method is run everytime the service is executed", "Reference": "This method is run every time the service is executed", "LLMCandidates": ["This method is run every time the service is executed.", "This method is run everytime the service is executed. It is responsible for backing up all books in the system by iterating through each book UID and generating an XML backup using GncXmlExporter. If a backup file already exists, it will be overridden with the new XML content.", "This method is run every time the service is executed to backup all books in the system by compressing their XML format and storing them into a gzip file.", "This method is executed every time the service runs.", "This method is executed every time the service runs."]}
{"SampleId": 4933730, "Origin": "If one param is a float, the other is converted to a float.", "Reference": "a/b If one param is a\nfloat, the other is converted to a float.", "LLMCandidates": ["If one param is a float, the other is converted to a float.", "If one param is a float, the other is converted to a float and the result is returned as an ExpressionValue.", "If one param is a float, both params are converted to floats.", "If one param is a float, both params are converted to floats.", "If one param is a float, the other is converted to a float before performing the calculation."]}
{"SampleId": 4478592, "Origin": "Get the fileContentType property: Sets the MIME content type of the\nfile.", "Reference": "Get the contentType property: Sets the MIME content type of the\nfile.", "LLMCandidates": ["Get the contentType property: Sets the MIME content type of the file.", "Get the contentType property: Sets the MIME content type of the file.", "Get the contentType property: Sets the MIME content type of the file.", "Get the contentType property: Sets the MIME content type of the file.", "Get the contentType property: Sets the MIME content type of the file."]}
{"SampleId": 4390872, "Origin": "For more information about managing snapshot copy grants, go to", "Reference": "For more information about managing snapshot copy grants, go to Amazon Redshift Database Encryption in the Amazon Redshift", "LLMCandidates": ["Create a SnapshotCopyGrant based on the provided CreateSnapshotCopyGrantRequest. This method uses an ExecutionContext and AWSRequestMetrics for timing metrics. It then marshals the request using a CreateSnapshotCopyGrantRequestMarshaller, binds the request metrics to the current request, and invokes the API with a StaxResponseHandler<SnapshotCopyGrant> using the appropriate unmarshaller. The method returns the SnapshotCopyGrant received in the response.", "This method creates a snapshot copy grant based on the given request. It initializes an ExecutionContext with AWSRequestMetrics and starts the ClientExecuteTime event. Next, it marshals the request using CreateSnapshotCopyGrantRequestMarshaller and binds the request metrics to the current request. The invoke() method is called to send the request, which returns a response containing a SnapshotCopyGrant object. Finally, the endClientExecution() method is executed to handle any cleanup tasks.", "For more information about managing snapshot copy grants with StaxResponseHandler, go to", "For more information about managing snapshot copy grants with StaxResponseHandler, go to", "Create a SnapshotCopyGrant object by invoking a service request with the given input parameters and handling the response accordingly. This method uses an execution context for managing AWS Request Metrics and handling the request, as well as a StaxResponseHandler to unmarshal the response from the service into a SnapshotCopyGrant object."]}
{"SampleId": 2061801, "Origin": "Uses a {@link HashMap} to map keys to value collections, initialized to expect the specified\nnumber of keys.", "Reference": "Uses a hash table to map keys to value collections, initialized to expect the specified\nnumber of keys.", "LLMCandidates": ["Uses a HashMap to map keys to value collections, initialized to expect the specified number of keys.", "Uses a {@link HashMap} provided by the Platform to map keys to value collections, initialized to expect the specified number of keys.", "Uses a HashMap (from Platform) to map keys to value collections, initialized to expect the specified number of keys.", "Uses a {@link HashMap} to map keys to value collections, initialized to expect the specified number of keys; however, this implementation has been replaced with the use of the {@link Platform#newHashMapWithExpectedSize} method.", "Uses a HashMap to map keys to value collections, initialized to expect the specified number of keys, via Platform implementation."]}
{"SampleId": 4620088, "Origin": "Returns the number of occurrences, or {@code -1} if the exact number is unknown.", "Reference": "Returns the result size, or {@code -1} if the exact size is unknown.", "LLMCandidates": ["Returns the number of items in the collection, or {@code -1} if the exact count is unknown.", "Returns the size of the collection, or {@code -1} if the exact size is unknown.", "Returns the number of items in the collection, or {@code -1} if the exact number is unknown.", "Returns the number of items, or {@code -1} if the exact number is unknown.", "Returns the number of items, or {@code -1} if the exact number is unknown."]}
{"SampleId": 1467613, "Origin": "Log rule execution statistics.", "Reference": "Log rule execution statistics @ INFO.", "LLMCandidates": ["Logs query execution statistics.", "Log rule execution statistics.\nNote: The static StringBuilder can not be used if the parent query has child subqueries without running into a deadlock on the [sb] object. If there are no children, we could reuse the global static [sb] and the AbstractRunningQuery.lock(). However, log(IRunningQuery) is ONLY invoke by AbstractRunningQuery.cancel() and then only runs IFF QueryLog is @ INFO. Since this is a rare combination, allocating a new StringBuilder object here will not have an adverse impact on the heap and avoids the possibility of a deadlock.", "Log rule execution statistics. \nThis method is invoked to log query execution details. The log message includes both a summary row and detailed rows of information about the rule execution. If there are child subqueries, their logs are also added before logging the final result.", "Log rule execution statistics using a StringBuilder object for each invocation to avoid deadlock and heap churn issues.", "Log rule execution statistics by allocating a new StringBuilder object to avoid deadlock and retain all the unchanged parts."]}
{"SampleId": 2217836, "Origin": "Test of var method, of class HyperGeometricDistribution.", "Reference": "Test of variance method, of class HyperGeometricDistribution.", "LLMCandidates": ["Test of variance method, of class HyperGeometricDistribution.", "Test of variance method, of class HyperGeometricDistribution.", "Test of variance method, of class HyperGeometricDistribution.", "Test of variance method, of class HyperGeometricDistribution.", "Test of variance method, of class HyperGeometricDistribution."]}
{"SampleId": 275709, "Origin": "Load all profile names.", "Reference": "A task that reads all profile names.", "LLMCandidates": ["Read all profile names.", "Read all profile names.", "Read all profile names.", "Read all profile names.", "Read all profile names."]}
{"SampleId": 337244, "Origin": "Get the {@link SessionConfiguration} for the specified camera id.", "Reference": "Get the {@link SessionConfig} for the specified camera id.", "LLMCandidates": ["Get the {@link SessionConfig} for the specified camera id.", "Get the {@link SessionConfig} for the specified camera id.", "Get the {@link SessionConfig} for the specified camera id.", "Get the {@link SessionConfig} for the specified camera id.", "Get the {@link SessionConfig} for the specified camera id."]}
{"SampleId": 3677731, "Origin": "Obtains an instance of {@code ZoneOffset} from a date-time object.", "Reference": "Obtains an instance of {@code ZoneOffset} from a temporal object.", "LLMCandidates": ["Obtains an instance of {@code ZoneOffset} from a date-time object if it is already a ZoneOffset; otherwise, it attempts to obtain the value from the given TemporalAccessor and throws an exception if not possible.", "Obtains an instance of {@code ZoneOffset} from a date-time object, checking if it's already an instance or trying to extract the offset seconds. In case of any error, a {@link DateTimeException} will be thrown.", "Obtains an instance of {@code ZoneOffset} from a date-time object if it is already available, otherwise parses the value from the given TemporalAccessor and throws an exception if unable to do so.", "Obtains an instance of {@code ZoneOffset} from a date-time object. If {@code temporal} is already an instance of {@code ZoneOffset}, it returns that; otherwise, it throws a {@link DateTimeException} if unable to obtain the ZoneOffset from the TemporalAccessor.", "Obtains an instance of {@code ZoneOffset} from a date-time object; if it is already a {@code ZoneOffset}, returns that; otherwise, attempts to obtain the total seconds value and wraps it in a {@code ZoneOffset}. If unable to do so, throws a {@code DateTimeException} with details."]}
{"SampleId": 4245995, "Origin": "Convert to object types, returning null if text is null.", "Reference": "Convert to object types, returning null if text is null or empty.", "LLMCandidates": ["Convert to object types, returning null if text is empty or null.", "Convert to object types, returning null if text is empty.", "Convert to object types, returning null if text is empty.", "Convert to object types, returning null if text is empty.", "Convert to object types, returning null if text is empty."]}
{"SampleId": 3384765, "Origin": "Returns the attack range for a {@link robocode.SentryRobot SentryRobot}.", "Reference": "Returns the border size that defines the attack range for a {@link robocode.SentryRobot SentryRobot}\nfrom the border.", "LLMCandidates": ["Returns the border size for a {@link robocode.SentryRobot SentryRobot}.", "Returns the border size for a {@link robocode.SentryRobot SentryRobot}.", "Returns the border size for a {@link robocode.SentryRobot SentryRobot}.", "Returns the border size for a {@link robocode.SentryRobot SentryRobot}.", "Returns the border size for a {@link robocode.SentryRobot SentryRobot}."]}
{"SampleId": 3036764, "Origin": "Decode an action profile member to PI action group member.", "Reference": "Decode an action profile member to PI action profile member.", "LLMCandidates": ["Decode an action profile member to PI action group member.", "Decode an action profile member to PI action group member using a provided pipeconf.", "Decode an action profile member to PI action group member using the given weight and pipeconf.", "Decode an action profile member to PI action group member using the given weight and pipeconf.", "Decode an action profile member to PI action group member using given weight and pipeconf."]}
{"SampleId": 3734139, "Origin": "If not, returns -1.", "Reference": "If not, returns null.", "LLMCandidates": ["Returns the minimum length value of the annotated type in the given tree using the provided ValueAnnotatedTypeFactory. If not found, returns -1.", "Get the minimum length of a Tree by using an AnnotatedTypeMirror from a ValueAnnotatedTypeFactory. If not found, return -1.", "Gets the minimum length annotated type for a tree and returns the minimum length value if available, otherwise returns -1.", "If not, returns -1.", "If not, returns -1."]}
{"SampleId": 2230461, "Origin": "Sets the quorum name for operations.", "Reference": "Sets the split brain protection name for operations.", "LLMCandidates": ["Sets the split brain protection name for operations.", "Sets the split brain protection name for operations.", "Sets the split brain protection name for operations.", "Sets the split brain protection name for operations.", "Sets the split brain protection name for operations."]}
{"SampleId": 2142909, "Origin": "Visit class header and get class name, access , and intefraces\ninformatoin (step 1,2, and 3) for SVUID computation.", "Reference": "Visit class header and get class name, access , and interfaces\ninformation (step 1,2, and 3) for SVUID computation.", "LLMCandidates": ["Visit class header and get class name, access, and interfaces information (step 1, 2, and 3) for SVUID computation.", "Visit class header and get class name, access, and interfaces information (step 1, 2, and 3) for SVUID computation.", "Visit class header and get class name, access, and interfaces information for SVUID computation.", "Visit class header and get class name, access, and interfaces information for SVUID computation.", "Visit class header and get class name, access, and interfaces information for SVUID computation."]}
{"SampleId": 3677731, "Origin": "This factory converts the arbitrary date-time object to an instance of {@code ZoneOffset}.", "Reference": "This factory converts the arbitrary temporal object to an instance of {@code ZoneOffset}.", "LLMCandidates": ["This factory converts the arbitrary date-time object to an instance of {@code ZoneOffset}, ensuring proper handling and conversion of any exceptions that may occur during this process.", "This factory converts the arbitrary date-time object to an instance of {@code ZoneOffset} if it's already a {@code ZoneOffset}, otherwise attempts to return an {@code ZoneOffset} with total seconds obtained from the given {@code TemporalAccessor}, handling exceptions.", "This factory converts the arbitrary date-time object to an instance of {@code ZoneOffset}, catching and handling exceptions during the process.", "This factory converts the arbitrary date-time object to an instance of {@code ZoneOffset} by parsing its offset seconds value. If unable to obtain a {@code ZoneOffset} from the {@code TemporalAccessor}, an exception is thrown.", "This factory converts the arbitrary date-time object to an instance of {@code ZoneOffset} and returns it if it is already a ZoneOffset. Otherwise, it attempts to obtain the offset seconds from the TemporalAccessor and returns a new ZoneOffset based on that. If an error occurs while obtaining the offset, a DateTimeException is thrown."]}
{"SampleId": 1381360, "Origin": "Validates that trailing checksums should be enabled based on {@link ClientType} and the presence\nor S3 specific headers.", "Reference": "Validates that checksums should be enabled based on {@link ClientType} and the presence\nor S3 specific headers.", "LLMCandidates": ["Validates that putObject checksum should be enabled based on {@link ClientType} and the presence or S3 specific headers.", "Validates that trailing checksums should be enabled based on the {@link ClientType} and specific S3 headers.", "Validates that trailing checksums should be enabled based on {@link ClientType} and the presence or S3 specific headers.", "Validates that trailing checksums should be enabled based on {@link ClientType} and the presence of S3 specific headers in the request.", "Validate if trailing checksums should be enabled based on ClientType and specific S3 headers"]}
{"SampleId": 6044783, "Origin": "or throws a {@link com.liferay.calendar.NoSuchBookingException} if it could not be found.", "Reference": "or throws a {@link NoSuchBookingException} if it could not be found.", "LLMCandidates": ["Finds a CalendarBooking with the specified UUID and group ID or throws a {@link com.liferay.calendar.NoSuchBookingException} if it could not be found.", "Find a CalendarBooking with the specified UUID and group ID, or throws a {@link com.liferay.calendar.NoSuchBookingException} if it could not be found.", "Finds a CalendarBooking by UUID and group ID, or throws a {@link com.liferay.calendar.NoSuchBookingException} if it could not be found.", "Finds a CalendarBooking by UUID and group ID. Throws a {@link com.liferay.calendar.NoSuchBookingException} if it could not be found.", "Finds a CalendarBooking with the specified UUID and group ID or throws a {@link com.liferay.calendar.NoSuchBookingException} if it could not be found."]}
{"SampleId": 4862706, "Origin": "This method will called {@link ByteBufferPool#release(ByteBuffer)} if a buffer pool has\nbeen configured.", "Reference": "This method calls {@link ByteBufferPool#release(ByteBuffer)} if a buffer pool has\nbeen configured.", "LLMCandidates": ["This method will be called {@link ByteBufferPool#release(ByteBuffer)} if a buffer pool has been configured.", "This method will be called {@link ByteBufferPool#release(ByteBuffer)} if a buffer pool has been configured and the buffer is not empty.", "This method will be called {@link ByteBufferPool#release(ByteBuffer)} if a buffer pool has been configured.", "This method will be called {@link ByteBufferPool#release(ByteBuffer)} if a buffer pool has been configured and the buffer is not empty.", "This method will be called {@link ByteBufferPool#release(ByteBuffer)} if a buffer pool has been configured."]}
{"SampleId": 5242834, "Origin": "Generate and write the html page that shows the snapshot and the state of\nthe ZoomParams", "Reference": "Generate and write the html page that shows the snapshot and the ZoomState", "LLMCandidates": ["Generate and write the html page that shows the snapshot and the state of the ZoomState", "Generate and write the html page that shows the snapshot and the state of the ZoomState", "Generate and write the html page that shows the snapshot and the state of the ZoomState", "Generate and write the html page that shows the snapshot and the state of the ZoomState", "Generate and write the HTML page that shows the snapshot and the state of the ZoomState"]}
{"SampleId": 4476928, "Origin": "SecretProperties secret} and call {@link SecretClient#getSecret(SecretProperties)}.", "Reference": "SecretProperties secret} and call {@link SecretClient#getSecret(String, String)}.", "LLMCandidates": ["Retrieve SecretProperties secret} and call {@link SecretClient#getSecret(SecretProperties)} with specified name and context", "listPropertiesOfSecretVersions(String name)\" and call {@link SecretClient#getSecret(SecretProperties)}.", "Gets a list of properties for SecretVersions with the specified name and call {@link SecretClient#getSecret(SecretProperties)", "listSecretVersions has been renamed to listPropertiesOfSecretVersions and its Javadoc comment has been updated accordingly.", "Get a PagedIterable of SecretProperties for a specified secret and call {@link SecretClient#getSecret(SecretProperties)}."]}
{"SampleId": 2615723, "Origin": "Removes all actors and cells from the table (same as {@link #clear()}) and additionally resets all table properties and\ncell, column, and row defaults.", "Reference": "Removes all actors and cells from the table (same as {@link #clearChildren()}) and additionally resets all table properties\nand cell, column, and row defaults.", "LLMCandidates": ["Removes all actors and cells from the table (same as {@link #clearChildren()}) and additionally resets all table properties and cell, column, and row defaults.", "Removes all actors and cells from the table (same as {@link #clearChildren()}) and additionally resets all table properties and cell, column, and row defaults.", "Removes all actors and cells from the table (same as {@link #clearChildren()}) and additionally resets all table properties and cell, column, and row defaults.", "Removes all actors and cells from the table (same as {@link #clearChildren()}) and additionally resets all table properties and cell, column, and row defaults.", "Resets all table properties and cell, column, and row defaults, removes all actors and cells from the table (same as {@link #clearChildren()})."]}
{"SampleId": 1220435, "Origin": "If the number of missing elements is\n    32 x times the number of present elements, treat it as sparse", "Reference": "If the number of missing elements is 32x times the number of present\nelements, consider it as sparse.", "LLMCandidates": ["Checks if a frame is sparse by comparing the number of missing elements to the product of the row and column count, where the ratio should be 32 or greater.", "Determine if a frame is sparse by checking if the number of missing elements is 32 times the number of present elements.", "If the number of missing elements is 32 times the number of present elements, treat it as sparse.", "This method checks if a frame is sparse or not. If the number of missing elements is significantly less than the total number of elements, it will be considered sparse.", "Determine if the frame is sparse by checking whether the product of rows and columns divided by the sum of missing elements plus one is greater than 32."]}
{"SampleId": 3629306, "Origin": "Returns an immutable set containing one element.", "Reference": "Returns an unmodifiable set containing one element.", "LLMCandidates": ["Returns an unmodifiable set containing one element.", "Returns a set containing one element which is unmodifiable.", "Returns a set containing one element which is unmodifiable.", "Returns an unmodifiable set containing one element.", "Returns an unmodifiable set containing one element."]}
{"SampleId": 1956974, "Origin": "Compute the number of bytes that would be needed to encode a {@code uint32} field.", "Reference": "Compute the number of bytes that would be needed to encode a varInt.", "LLMCandidates": ["Compute the number of bytes that would be needed to encode a {@code uint32} field using raw variable-length encoding.", "Compute the number of bytes that would be needed to encode a uint32 field using raw varint encoding.", "Compute the number of bytes that would be needed to encode a raw uint32 field.", "Compute the number of bytes that would be needed to encode a {@code uint32} field using the raw varint encoding method.", "Compute the number of bytes that would be needed to encode a raw var-int32 field."]}
{"SampleId": 3344422, "Origin": "Create a new read/write access object.", "Reference": "Create a new read/write access object with the given default timeout.", "LLMCandidates": ["Create a new read/write access object with the given default timeout.", "Create a new read/write access object with the specified default timeout.", "Create a new read/write access object with the specified default timeout.", "Create a new read/write access object with the specified default timeout.", "Create a new read/write access object with defaultTimeout."]}
{"SampleId": 2535861, "Origin": "Filter the array under test keeping only elements whose property or field specified by {@code propertyOrFieldName}\nis null.", "Reference": "Filter the array under test into a list composed of the elements whose property or field specified\nby {@code propertyOrFieldName} are null.", "LLMCandidates": ["Filter the array under test keeping only elements whose property or field specified by {@code propertyOrFieldName} is null. However, please note that this method cannot be called with null as it does not work properly with soft assertions proxying mechanism and could lead to double proxying which is not handle properly (improvements needed in our proxy mechanism).", "Filter the array under test keeping only elements whose property or field specified by {@code propertyOrFieldName} is null (currently not supported with soft assertions proxying).", "Filter the array under test keeping only elements whose property or field specified by {@code propertyOrFieldName} is null.", "Filter the array under test keeping only elements whose property or field specified by {@code propertyOrFieldName} is null (due to soft assertions proxying mechanism limitations, filtering with \"null\" value doesn't work as expected).", "Filter the array under test keeping only elements whose property or field specified by {@code propertyOrFieldName} is null, considering the soft assertions proxying mechanism."]}
{"SampleId": 1135007, "Origin": "First sends a request to the BlobStore and gets a list of all blob file summaries\nprefixed by the given coreName.", "Reference": "First sends a request to the BlobStore and gets a list of all blob file summaries\nprefixed by the given blobName.", "LLMCandidates": ["The content of this Javadoc comment will reflect the changes on code while retain all the unchanged parts. First sends a request to the BlobStore and gets a list of all blob file summaries prefixed by the given blobName.", "First sends a request to the BlobStore and gets a list of all blob file summaries prefixed by the given blobName.", "@Override public void deleteCore(String blobName) throws BlobException: First sends a request to the BlobStore and gets a list of all blob file summaries prefixed by the given blobName.", "Sends a request to the BlobStore and gets a list of all blob file summaries prefixed by the given blobName.", "First sends a request to the BlobStore and gets a list of all blob file summaries prefixed by the given blobName."]}
{"SampleId": 2624584, "Origin": "Creates a new HTTP authorization {@link Service} decorator using the specified\n{@link Authorizer}s.", "Reference": "Creates a new HTTP authorization {@link HttpService} decorator using the specified\n{@link Authorizer}s.", "LLMCandidates": ["Creates a new HTTP authorization {@link Service} decorator using the specified\n{@link Authorizer}s.", "Creates a new HTTP authorization {@link Service} decorator using the specified\n{@link Authorizer}s.", "Creates a new HTTP authorization {@link Service} decorator using the specified {@link Authorizer}s.", "Creates a new HTTP authorization {@link Service} decorator using the specified {@link Authorizer}s.", "Creates a new HTTP authorization {@link Function} decorator using the specified {@link Authorizer}s."]}
{"SampleId": 2034558, "Origin": "Method that returns code to access a named state parameter.", "Reference": "Method that returns code to access a named prop parameter.", "LLMCandidates": ["Method that returns code to access a named property parameter.", "Method that returns code to access a named property parameter.", "The method returns code to access a named property parameter.", "The method returns code to access a named property parameter.", "Method that returns code to access a named property parameter."]}
{"SampleId": 5433545, "Origin": "Do nothing if\n{@link BaseConfiguration#nocomment} is set to true.", "Reference": "Do nothing if\n{@link BaseOptions#noComment} is set to true.", "LLMCandidates": ["Do nothing if {@link BaseConfiguration#noComment} is set to true.", "Do nothing if {link BaseConfiguration#noComment} is set to true.", "Do nothing if {@link BaseConfiguration#noComment} is set to true.", "Do nothing if {@link BaseConfiguration#noComment} is set to true.", "Do nothing if {link BaseConfiguration#noComment} is set to true."]}
{"SampleId": 2404072, "Origin": "Executes {@link Pems#privateKeySpec(InputSupplier)} on the string which contains an encoded private key in PEM\nformat.", "Reference": "Executes {@link Pems#privateKeySpec(ByteSource)} on the string which contains an encoded private key in PEM\nformat.", "LLMCandidates": ["Executes {@link Pems#privateKeySpec(ByteSource)} on the string which contains an encoded private key in PEM format.", "Executes {@link Pems#privateKeySpec(ByteSupplier)} on the string which contains an encoded private key in PEM format.", "Executes {@link Pems#privateKeySpec(ByteSource)} on the string which contains an encoded private key in PEM format.", "Executes {@link Pems#privateKeySpec(ByteSupplier)} on the string which contains an encoded private key in PEM format.", "Executes {@link Pems#privateKeySpec(ByteSupplier)} on the string which contains an encoded private key in PEM format."]}
{"SampleId": 4233858, "Origin": "Verify that at most {@code maxEntries} per session can be put in the cache", "Reference": "Verify that at most {@code maxEntries} per session can be put in the store", "LLMCandidates": ["Verify that at most {@code maxEntries} per session can be put in the cache with {@link IPageContext}.", "Verify that at most {@code maxEntries} per session can be added to the cache and are retrievable only by their respective keys.", "Verify that only the most recent {@code maxEntries} per session can be added to the cache.", "Verify that at most {@code maxEntries} per session can be put in the cache when using IPageContext and storing pages through addPage method", "Verify that at most {@code maxEntries} per session can be stored in the cache."]}
{"SampleId": 1449477, "Origin": "Creates RedeemData for P2PKH or P2PK input.", "Reference": "Creates RedeemData for P2PKH, P2WPKH or P2PK input.", "LLMCandidates": ["Creates RedeemData for P2PKH or P2WPKH or P2PK input.", "Creates RedeemData for P2PKH, P2WPKH or P2PK input.", "Creates RedeemData for P2PKH, P2WPKH, or P2PK input.", "Creates RedeemData for P2PKH, P2WPKH or P2PK input.", "Creates RedeemData for P2PKH, P2WPKH, or P2PK input."]}
{"SampleId": 1131869, "Origin": "Return a new {@link Terms} in which term of {@code coreNodeName} is removed", "Reference": "Return a new {@link Terms} in which terms for the {@code coreNodeName} are removed", "LLMCandidates": ["Return a new {@link Terms} in which terms of {@code coreNodeName} and its recoveringTerm are removed", "Return a new {@link Terms} in which terms of both {@code coreNodeName} and {@code recoveringTerm(coreNodeName)} are removed", "Return a new {@link Terms} in which terms of {@code coreNodeName} and its recovering term are removed", "Return a new {@link Terms} in which terms of {@code coreNodeName} and {@code recoveringTerm(coreNodeName)} are removed", "Return a new {@link Terms} where terms of {@code coreNodeName} are removed and term of recoveringTerm(coreNodeName) is also removed."]}
{"SampleId": 239880, "Origin": "Typically used for RPCs\nat best efforts (e.g., async cache).", "Reference": "This method is typically used for RPCs\nproviding best efforts (e.g., async cache).", "LLMCandidates": ["Fire and forget a message using NettyRPCContext and ProtoMessage, which typically used for RPCs at best efforts (e.g., async cache).", "Typically used for fire-and-forget RPCs at best efforts (e.g., async cache).", "Fire and forget RPC calls. This method sends a message to a specific channel without waiting for a response or an acknowledgment. It is commonly used for non-blocking async tasks, such as async cache operations.", "Publicly used for fire-and-forget RPCs at best efforts (e.g., async cache).", "Publicly used for fire-and-forget RPCs at best efforts (e.g., async cache)."]}
{"SampleId": 5149993, "Origin": "Create an initial optimistic locking value according the {@link VersionType}\ncontract for the version property if required and inject it into\nthe snapshot state.", "Reference": "Create an initial optimistic locking value according the {@link VersionSupport}\ncontract for the version property if required and inject it into\nthe snapshot state.", "LLMCandidates": ["Set an initial optimistic locking value according to the {@link VersionDescriptor} contract for the version property if required and inject it into the snapshot state.", "Create an initial optimistic locking value according the {@link VersionType} contract for the version property if required and inject it into the snapshot state, using the {@link VersionDescriptor} to specify the position of the version property in the snapshot array.", "Create an initial optimistic locking value according to the {@link VersionDescriptor} contract for the version property if required and inject it into the snapshot state.", "Create an initial optimistic locking value according to the {@link VersionDescriptor} contract for the version property if required and inject it into the snapshot state.", "Create an initial optimistic locking value according to the {@link VersionDescriptor} for the version property if required and inject it into the snapshot state."]}
{"SampleId": 4850223, "Origin": "Returns the number of allowed parallel requests the configured {@link Router} should adhere to.", "Reference": "Returns the currently configured {@link ExchangeStrategies}.", "LLMCandidates": ["The method returns the configured {@link ExchangeStrategies} used by the system to manage and control concurrent requests.", "Gets the current ExchangeStrategies object used for managing exchanges between different strategies.", "Returns the configured ExchangeStrategies object for the Router to follow.", "Returns the configured ExchangeStrategies object for the Router to follow.", "Returns the configured {@link ExchangeStrategies} that will be used by the Router for handling requests."]}
{"SampleId": 5079050, "Origin": "Checks that collection {@param col} doesn't contains string {@param str}.", "Reference": "Checks that collection {@param col} doesn't contains element {@param str}.", "LLMCandidates": ["Checks that collection {@param col} doesn't contains element {@param elem}.", "Checks that collection {@param col} doesn't contain element {@param elem}.", "Checks that collection {@param col} doesn't contain element {@param elem}.", "Checks that collection {@param col} doesn't contains element {@param elem}.", "Checks that collection {@param col} doesn't contains element {@param elem}."]}
{"SampleId": 5442858, "Origin": "Return the initial pixel size used to define initial arrays\n(tile AA chunk, alpha line, buckets)", "Reference": "Return the initial pixel height used to define initial arrays\n(buckets)", "LLMCandidates": ["Return the initial pixel height used to define initial arrays (tile AA chunk, alpha line, buckets)", "Return the initial pixel height used to define initial arrays (tile AA chunk, alpha line, buckets).", "Return the initial pixel height used to define initial arrays (tile AA chunk, alpha line, buckets).", "Return the initial pixel height used to define initial arrays (tile AA chunk, alpha line, buckets).", "Return the initial pixel height used to define initial arrays (tile AA chunk, alpha line, buckets)"]}
{"SampleId": 4117755, "Origin": "It is up to the Authenticator\nimplementation processing this token if an authentication attempt without an inetAddress is valid or not.", "Reference": "It is up to the Authenticator\nimplementation processing this token if an authentication attempt without a host is valid or not.", "LLMCandidates": ["It is up to the Authenticator implementation processing this token if an authentication attempt without a host is valid or not.", "It is up to the Authenticator implementation processing this token if an authentication attempt without a host is valid or not.", "It is up to the Authenticator implementation processing this token if an authentication attempt without a host is valid or not.", "It is up to the Authenticator implementation processing this token if an authentication attempt without a host is valid or not.", "It is up to the Authenticator implementation processing this token if an authentication attempt without a host is valid or not."]}
{"SampleId": 2988281, "Origin": "Useful because the\ngranularity of the clock on some systems is low, so doing a Thread.sleep(10) may not give you\na different clock value, for example.", "Reference": "(Also, useful because the granularity\nof the clock on some systems is low, so doing a Thread.sleep(10) may not give you a different clock value", "LLMCandidates": ["Useful because the granularity of the clock on some systems is low, so doing a Thread.sleep(10) may not give you a different clock value, for example.", "This method is useful because some systems have low granularity clocks, so using Thread.sleep(100) may not give you a different clock value, for example.", "Useful because the granularity of the clock on some systems is low, so doing a Thread.sleep(10) may not give you a different clock value, for example.", "Useful because the granularity of the clock on some systems is low, so doing a Thread.sleep(100) may not give you a different clock value, for example.", "Useful because the granularity of the clock on some systems is low, so doing a Thread.sleep(100) may not give you a different clock value, for example."]}
{"SampleId": 340520, "Origin": "Sets {@link MediaItem2} object to render using VideoView2.", "Reference": "Sets {@link MediaItem} object to render using VideoView2.", "LLMCandidates": ["Sets {@link MediaItem} object to render using VideoView2.", "Sets {@link MediaItem} object to render using VideoView.", "Sets {@link MediaItem} object to render using VideoView2.", "Sets {@link MediaItem} object to render using VideoView2.", "Sets {@link MediaItem} object to render using VideoView."]}
{"SampleId": 3579668, "Origin": "Otherwise,\nthe specified consumer is invoked with the leader index metadata fetched from the remote cluster.", "Reference": "Otherwise, the specified consumer is invoked with the cluster state and leader index metadata\nfetched from the remote cluster.", "LLMCandidates": ["The specified consumer is invoked with the leader index metadata fetched from the remote cluster along with the history UUIDs.", "Fetches leader index metadata from a remote cluster and invokes the specified consumer with this information. If an exception occurs, it is passed to the onFailure handler. Additionally, if required, the remote cluster state includes nodes' data as well.", "The specified consumer is invoked with the leader index metadata fetched from the remote cluster after checking the remote cluster license and fetching the cluster state.", "The specified consumer is invoked with the leader index metadata fetched from the remote cluster, along with the ClusterState of the remote cluster.", "The specified consumer is invoked with the leader index metadata fetched from the remote cluster along with the corresponding ClusterState object."]}
{"SampleId": 368454, "Origin": "Returns true if the currently set key guard matches our minimum quality requirements.", "Reference": "Returns true if the currently set key guard violates our minimum quality requirements.", "LLMCandidates": ["Checks if the currently set key guard quality meets our minimum requirements by comparing it to MIN_PASSWORD_QUALITY.", "Checks if the active password quality meets or exceeds the minimum password quality requirement set for the device.", "Returns true if the currently set key guard meets our minimum quality requirements.", "Returns true if the currently set key guard meets our minimum quality requirements.", "Returns true if the currently set key guard does not meet our minimum quality requirements."]}
{"SampleId": 2939584, "Origin": "It incorporates the zone, bulb type and command\ncategory.", "Reference": "It incorporates the bridge, zone, bulb type and command\ncategory.", "LLMCandidates": ["This method generates a unique identifier based on the bridgeOffset, config.zone, typeOffset, and commandCategory.", "This method incorporates the bridgeOffset, zone, bulb type, and command category.", "This method incorporates the bridgeOffset, zone, bulb type, and command category.", "It incorporates the bridgeOffset, zone, bulb type, and command category.", "The incorporation of the bridgeOffset, zone, bulb type, and command category is applied to form the unique identifier."]}
{"SampleId": 1706012, "Origin": "Restore redundancy with backoff.", "Reference": "Restore redundancy with an exponential backoff.", "LLMCandidates": ["Restore redundancy with exponential backoff by executing the action that tries to restore redundancy and merge segments.", "Restore redundancy with exponential backoff.", "Restore redundancy with backoff using a supplier action.", "Restore redundancy with backoff using a supplier action.", "Restore redundancy with exponential backoff, returning true if successful and false otherwise."]}
{"SampleId": 4479778, "Origin": "Generates a code sample for using {@link FileClient#uploadRangeFromUrl(long, long, long, URI)}", "Reference": "Generates a code sample for using {@link FileClient#uploadRangeFromUrl(long, long, long, String)}", "LLMCandidates": ["Generates a code sample for using {@link FileClient#uploadRangeFromUrl(long, long, long, String)", "Generates a code sample for using {@link FileClient#uploadRangeFromUrl(long, long, long, String)", "Generates a code sample for using {@link FileClient#uploadRangeFromUrl(long, long, long, String)", "Generates a code sample for using {@link FileClient#uploadRangeFromUrl(long, long, long, String)", "Generates a code sample for using {@link FileClient#uploadRangeFromUrl(long, long, long, String)"]}
{"SampleId": 3731150, "Origin": "If typeVar is a captured wildcard, returns that wildcard; otherwise returns null.", "Reference": "If typeVar is a captured wildcard, returns that wildcard; otherwise returns {@code null}.", "LLMCandidates": ["Returns the captured wildcard type if it exists; otherwise, returns null.", "If typeVar is a captured wildcard, returns that wildcard; otherwise returns null.", "If typeVar is a captured wildcard, returns that wildcard; otherwise returns null.", "If typeVar is a captured wildcard, returns that wildcard; otherwise returns null.", "If typeVar is a captured wildcard, returns that wildcard; otherwise returns null."]}
{"SampleId": 2543276, "Origin": "Set this quaternion to be a representation of the supplied axis and\nangle (in radians).", "Reference": "Set this quaternion to be a representation of the supplied axis and\nangle (in degrees).", "LLMCandidates": ["This method sets the quaternion by converting the supplied axis and angle (in degrees) to a quaternion representation.", "Set this quaternion to be a representation of the supplied axis and angle (in degrees).", "Set this quaternion to be a representation of the supplied axis and angle (in degrees).", "Set this quaternion to be a representation of the supplied axis and angle (in degrees).", "Set this quaternion to be a representation of the supplied axis and angle (in degrees)."]}
{"SampleId": 437253, "Origin": "Like {@link #readGenericRecords(Schema)}, but reads each filepattern in the input {@link\nPCollection}.", "Reference": "Like {@link #readGenericRecords(Schema)}, but for a {@link PCollection} of {@link", "LLMCandidates": ["Like {@link #readGenericRecords(Schema)}, but reads each filepattern in the input {@link PCollection}.", "Like #readGenericRecords(Schema)}, but reads each filepattern in the input PCollection.", "Like #readGenericRecords(Schema)}, but reads each filepattern in the input PCollection.", "Like {@link #readGenericRecords(Schema)}, but reads each filepattern in the input {@link PCollection}.", "Like {@link #readGenericRecords(Schema)}, but reads each filepattern in the input {@link PCollection} and sets the desired bundle size to DEFAULT_BUNDLE_SIZE_BYTES."]}
{"SampleId": 6310269, "Origin": "Returns the whitelisted regular expressions.", "Reference": "Returns the white regular expressions.", "LLMCandidates": ["Returns the whitelisted regular expressions list as an array.", "Returns the whitelisted regular expression.", "Returns the whitelisted regular expression.", "Returns a single whitelisted regular expression as an array of Patterns.", "Returns a single whitelisted regular expression as an array of Patterns."]}
{"SampleId": 613054, "Origin": "Used by system internally to merge the other resources of chained operators\nwhen generating the job graph or merge the resource consumed by state backend.", "Reference": "Used by system internally to merge the other resources of chained operators\nwhen generating the job graph.", "LLMCandidates": ["Merges the resource specifications of two objects when generating a job graph or merging the resources consumed by state backend.", "Merges the resources of this instance with another ResourceSpec instance to generate a new resource specification. This method is used internally when merging resources of chained operators or by state backend.", "Merges the resource specification of another operator by adding their respective values together and considering the extended resources when generating job graphs or merging state backend consumption.", "Merges the resource specifications of this object with another ResourceSpec. It considers the heap memory and managed memory separately, while handling off-heap memory as a separate entity. Additionally, it merges extended resources if any are present in either of the two input ResourceSpecs. This method is used internally when generating the job graph or merging resource consumption for state backend purposes.", "Merges the resources of two ResourceSpec objects and updates the extendedResources map by merging resources with the same name. Used by system internally to merge the other resources of chained operators when generating the job graph or merge the resource consumed by state backend."]}
{"SampleId": 2911559, "Origin": "Adds a single sensitivity to the builder using metadata.", "Reference": "Adds a single sensitivity to the builder.", "LLMCandidates": ["Adds a single sensitivity to the builder using metadata and currency.", "Adds a single sensitivity to the builder using metadata.", "Adds a single sensitivity to the builder using metadata.", "Builds a new sensitivity using the given metadata by adding it to the specified curve name and currency.", "Builds a new sensitivity using the given metadata by adding it to the specified curve name and currency."]}
{"SampleId": 3653159, "Origin": "Creates a Course object and an Instructor object for the Course.", "Reference": "Creates a course and an associated instructor for the course.", "LLMCandidates": ["Creates a Course object and an Instructor object for the Course, using the provided CourseAttributes to initialize the Course object, and creating the initial instructor with specific privileges.", "Creates a Course object with specified attributes and an Instructor object for the course.", "Creates a Course object with given attributes and an Instructor object for the Course using the provided Google Id of the instructor.", "Creates a Course object with given attributes and an Instructor object for the Course. The instructor must have instructor privileges.", "Creates a Course object with given attributes and an Instructor object associated with the Course creator."]}
{"SampleId": 5240878, "Origin": "Indicates if the display name of the XRY meta key is a recognized type.", "Reference": "Indicates if the display name of the XRY key is a recognized type.", "LLMCandidates": ["Indicates if the display name of the XRY meta key is a recognized type.", "Indicates if the display name of the XRY meta key is a recognized type.", "Indicates if the display name of the XRY meta key is a recognized type.", "Indicates if the display name of the XRY meta key is a recognized type.", "Indicates if the display name of the XRY meta key is a recognized type."]}
{"SampleId": 2217816, "Origin": "Test of var method, of class BinomialDistribution.", "Reference": "Test of variance method, of class BinomialDistribution.", "LLMCandidates": ["Test of variance method, of class BinomialDistribution.", "Test of variance method, of class BinomialDistribution.", "Test of variance method, of class BinomialDistribution.", "Test of variance method, of class BinomialDistribution.", "Test of variance method, of class BinomialDistribution."]}
{"SampleId": 2133792, "Origin": "bold driver: Gemulla et al., Large-scale matrix factorization with distributed stochastic gradient descent,\nKDD 2011.\nconstant decay: Niu et al, Hogwild!", "Reference": "bold driver: Gemulla et al., Large-times matrix factorization with distributed stochastic gradient descent,\nKDD 2011.\nconstant decay: Niu et al, Hogwild!", "LLMCandidates": ["This method is used for updating the learning rate during training. The initial learnRate should be non-negative. If it's negative, no update occurs. In iterations greater than 1, the learning rate is updated based on bold driver strategy or using a decay factor if specified. The final step is to limit the updated learning rate to max-learn-rate, ensuring that it doesn't exceed the maximum value set. Finally, lastLoss is updated with the current loss value for future iterations.", "bold driver: Gemulla et al., Large-scale matrix factorization with distributed stochastic gradient descent, KDD 2011. constant decay: Niu et al, Hogwild!", "bold driver: Gemulla et al., Large-scale matrix factorization with distributed stochastic gradient descent, KDD 2011. constant decay: Niu et al, Hogwild!", "This method updates the learning rate (learnRate), taking into account whether the algorithm is running with a bold driver or not and using a constant decay factor. If isBoldDriver is true and the current iteration number (iter) is greater than 1, the learnRate is adjusted based on the absolute values of the previous loss (lastLoss) and the current loss (loss). If decay is between 0 and 1, the learnRate is multiplied by the decay value. The learnRate is then limited to a maximum value (maxLearnRate) if it exceeds this limit. Lastly, the current loss value is stored for future use in determining the learning rate update.", "bold driver: Gemulla et al., Large-scale matrix factorization with distributed stochastic gradient descent, KDD 2011. constant decay: Niu et al, Hogwild!"]}
{"SampleId": 2062875, "Origin": "With natural ordering,\n{@link Ordering#natural()} is returned.", "Reference": "Ordering#natural()} is returned.", "LLMCandidates": ["With natural ordering, {@link Ordering#natural()} is returned but deprecated.", "With deprecated natural ordering, {@link Ordering#natural()} is returned.", "With natural ordering, {@link Ordering#natural()} is returned. This method is now deprecated.", "With natural ordering, {@link Ordering#natural()} is returned. This method is now deprecated.", "With natural ordering, {@link Ordering#natural()} is returned."]}
{"SampleId": 2404068, "Origin": "Executes {@link Pems#publicKeySpec(InputSupplier)} on the string which contains an encoded public key in PEM\nformat.", "Reference": "Executes {@link Pems#publicKeySpec(ByteSource)} on the string which contains an encoded public key in PEM\nformat.", "LLMCandidates": ["Executes {@link Pems#publicKeySpec(ByteSource)} on the string which contains an encoded public key in PEM format.", "Executes {@link Pems#publicKeySpec(ByteSupplier)} on the string which contains an encoded public key in PEM format.", "Executes {@link Pems#publicKeySpec(ByteSupplier)} on the string which contains an encoded public key in PEM format.", "Executes {@link Pems#publicKeySpec(ByteSupplier)} on the string which contains an encoded public key in PEM format.", "Executes {@link Pems#publicKeySpec(ByteSupplier)} on the string which contains an encoded public key in PEM format."]}
{"SampleId": 4004239, "Origin": "This method schedules the disablement for asynchronous execution.", "Reference": "This method deactivates and disables the component immediately.", "LLMCandidates": ["Disables the component immediately without scheduling for asynchronous execution.", "Disables the component immediately without scheduling for asynchronous execution.", "This method directly disables the component without scheduling for asynchronous execution.", "This method directly disables the component without scheduling for asynchronous execution.", "Disables the component immediately without any scheduling for asynchronous execution."]}
{"SampleId": 5588757, "Origin": "Switch to the given page, update the highlighted episode.", "Reference": "Switch to the episode at the given position.", "LLMCandidates": ["Set the current page, update the highlighted episode.", "Switch to the given page, update the highlighted episode by changing view state.", "Switch to the given page, update the highlighted episode; if single pane view is enabled, switchView(false).", "Switch to the given page, update the highlighted episode; if it is a single pane view, hide container list and show container pager.", "Switch to the given page, update the highlighted episode by calling switchView(false)."]}
{"SampleId": 1968999, "Origin": "Repairs the metadata table.", "Reference": "Repairs the schema history table.", "LLMCandidates": ["Repairs the metadata table, specifically the schema history table.", "Repairs the schema history table.", "Repairs the schema history table.", "Repairs the schema history table.", "Repairs the schema history table."]}
{"SampleId": 3629275, "Origin": "Returns an immutable list containing three elements.", "Reference": "Returns an unmodifiable list containing three elements.", "LLMCandidates": ["Returns an unmodifiable list containing three elements.", "Returns an unmodifiable list containing three elements.", "Returns an unmodifiable list containing three elements.", "Returns an unmodifiable list containing three elements.", "Returns an unmodifiable list containing three elements."]}
{"SampleId": 3306952, "Origin": "Sets SSLHostConfig infos.", "Reference": "Sets SslHostConfig infos.", "LLMCandidates": ["Sets the SSLHostConfig infos.", "Sets the SSLHostConfig infos.", "Sets SSLHostConfig infos.", "Sets SSLHostConfig infos.", "Sets SSLHostConfig infos."]}
{"SampleId": 3629303, "Origin": "See Immutable Set Static Factory Methods for details.", "Reference": "See Unmodifiable Sets for details.", "LLMCandidates": ["Returns an immutable set containing the specified elements in an unmodifiable set implementation.", "See Unmodifiable Set Static Factory Methods for details.", "This is a factory method for creating an unmodifiable set with up to 9 elements from the given parameters.", "Set the initial value by adding 8 to n.", "Set the initial value by adding 8 to n."]}
{"SampleId": 2404091, "Origin": "Sets the CSS pages for the Static Website.", "Reference": "Sets the listings CSS page for the Static Website.", "LLMCandidates": ["Sets the CSS pages for the Static Website using a specified key (STATIC_WEB_LISTINGS_CSS).", "Sets the CSS pages for the Static Website using the specified listingsCSS value and placing it under STATIC_WEB_LISTINGS_CSS key in the headers.", "Sets the CSS pages for the Static Website using the given listingsCSS.", "Sets the CSS pages for the Static Website using the given listingsCSS.", "Sets the CSS pages for the Static Website using the given listingsCSS."]}
{"SampleId": 4002573, "Origin": "Returns a literal for the {@link Reference} policy.", "Reference": "Returns a literal for the {@link ScrService.Reference} policy.", "LLMCandidates": ["Returns a literal for the {@link ScrService.Reference} policy.", "/** \n * Returns a literal for the {@link ScrService.Reference} policy.\n */", "Returns a literal for the {@link ScrService.Reference} policy.", "Returns a literal for the {@link ScrService.Reference} policy.", "Returns a literal for the ScrService.Reference policy."]}
{"SampleId": 3772633, "Origin": "Expands the given row.", "Reference": "Expands the given item at given index.", "LLMCandidates": ["Expands the given row, considering if it's already expanded or not. If yes, it expands and pushes the rows into view. If no, it refreshes the data of that row.", "Expands the given row if it is not already expanded.", "Expands the given row item and its children.", "Expands the given row item and its children.", "Expands a given row in the tree grid if it is not already expanded."]}
{"SampleId": 340561, "Origin": "Sets playback rate using {@link PlaybackParams2}.", "Reference": "Sets playback rate using {@link PlaybackParams}.", "LLMCandidates": ["Sets playback rate using {@link PlaybackParams}.", "Sets playback rate using {@link PlaybackParams}.", "Sets playback rate using {@link PlaybackParams}.", "Sets playback rate using {@link PlaybackParams}.", "Sets playback rate using {@link PlaybackParams}."]}
{"SampleId": 4617700, "Origin": "Adds the specified argument as XQuery string.", "Reference": "Adds the specified argument unchanged.", "LLMCandidates": ["Adds the specified argument as a string to the command builder.", "Adds the specified argument to the command string.", "Adds the specified argument to the command string.", "Adds the specified argument to the command string.", "Adds the specified argument as a string to the command line builder."]}
{"SampleId": 6043581, "Origin": "Returns an ordered range of all the sync d l objects where companyId = ?", "Reference": "Returns an ordered range of all the sync d l objects where modifiedTime > ?", "LLMCandidates": ["Finds a range of SyncDLObjects with matching modification time, repository ID and parent folder ID.", "Finds a range of SyncDLObjects based on modifiedTime, repositoryId, and parentFolderId.", "Finds a range of SyncDLObjects based on modifiedTime, repositoryId, and parentFolderId.", "Finds a range of sync d l objects by their modification time, repository id, and parent folder id in an ordered list.", "Returns an ordered range of all the sync d l objects where modifiedTime = ?"]}
{"SampleId": 2913863, "Origin": "This is measured from the bottom, that is, the expected shortfall with the level 99% corresponds to\nthe average of the smallest 99% of the observations.", "Reference": "This is measured from the bottom, that is, Thus the expected shortfall with the level 99% corresponds to\nthe smallest 99% observations.", "LLMCandidates": ["This is measured from the bottom, that is, the expected shortfall with the level 99% corresponds to the average of the smallest 99% of the observations.", "This is measured from the bottom, that is, the expected shortfall with the level 99% corresponds to the average of the smallest 99% of the observations.", "This is measured from the bottom, that is, the expected shortfall with the level 99% corresponds to the average of the smallest 99% of the observations. The method now returns the result by calling expectedShortfallResultFromUnsorted and getting its value.", "This is measured from the bottom, that is, the expected shortfall with the level 99% corresponds to the average of the smallest 99% of the observations. The method now calculates the expected shortfall result from unsorted data and returns its value.", "This is measured from the bottom, that is, the expected shortfall with the level 99% corresponds to the average of the smallest 99% of the observations."]}
{"SampleId": 3652786, "Origin": "The base URL will be the application URL.", "Reference": "The base URL will be the application back-end URL.", "LLMCandidates": ["The base URL will be the application URL for backend usage.", "The base URL will be the back end application URL.", "The base URL will be the application URL, specifically for backend purposes.", "The base URL will be the application URL, specifically for backend purposes.", "The base URL will be the backend application URL."]}
{"SampleId": 4863800, "Origin": "Atomically updates the current hi value with the results of\napplying the given delta, returning the updated value.", "Reference": "Atomically adds the given delta to the current hi value, returning the updated hi value.", "LLMCandidates": ["Atomically updates the current hi value with the results of applying the given delta, returning the updated value.", "Atomically updates the current hi value with the results of applying the given delta, returning the updated value.", "Atomically updates the current hi value with the results of applying the given delta, returning the updated value.", "Atomically updates the current hi value with the results of applying the given delta, returning the updated value.", "Atomically updates the current hi value with the results of applying the given delta, returning the updated value."]}
{"SampleId": 3562209, "Origin": "Returns the report builder for the rootmost component that contains any of the duplicate\nbindings.", "Reference": "Returns the report builder for the rootmost component that contains any of the {@code\nbindings}.", "LLMCandidates": ["Finds the report builder for the rootmost component that contains any of the bindings.", "Finds the report builder for the rootmost component that contains any of the specified bindings.", "Finds the report builder for the rootmost component that contains any of the specified bindings.", "Returns the report builder for the rootmost component that contains any of the bindings.", "Returns the report builder for the rootmost component that contains any of the bindings."]}
{"SampleId": 3906717, "Origin": "Centres this dialog on the main fame.", "Reference": "Centres this dialog on the parent window.", "LLMCandidates": ["Centres this dialog on the main fame.", "Centres this dialog on the main fame by setting its location relative to the main frame's ancestor window.", "Centres this dialog on main frame by setting its location relative to the main fame's ancestor.", "Centres this dialog on the main fame by setting its location relative to the window ancestor.", "Centres this dialog on the main fame by setting its location relative to the window ancestor."]}
{"SampleId": 1790907, "Origin": "Gets the value of the source property.", "Reference": "Gets the value of the parameter property.", "LLMCandidates": ["Gets the value of the parameter property.", "Gets the value of the parameter property.", "Gets the value of the parameter property.", "Gets the value of the parameter property.", "Gets the value of the parameter property."]}
{"SampleId": 4465302, "Origin": "If an event\nlistener is assignable to {@link EventListener} it will registered as is.", "Reference": "If an event\nhandler is assignable to {@link EventMessageHandler} it will registered as is.", "LLMCandidates": ["If an event handler is assignable to {@link EventHandler} it will be registered as is.", "If an event handler is assignable to {@link EventHandler} it will be registered as is.", "If an event handler is assignable to {@link EventHandler} it will be registered as is.", "If an event handler is assignable to {@link EventHandler} it will be registered as is.", "If an event handler is assignable to {@link EventHandler} it will be registered as is."]}
{"SampleId": 4239806, "Origin": "use_credentials: Cross-origin CORS requests for the element will have the credentials flag set.", "Reference": "USE_CREDENTIALS: Cross-origin CORS requests for the element will have the credentials flag set.", "LLMCandidates": ["The use of the crossOrigin flag on requests for this element will have credentials set.", "Set cross-origin CORS requests for the element will have the credentials flag set to true when this method is called.", "setCrossOrigin: Cross-origin CORS requests for the element will have the credentials flag set.", "setCrossOrigin: Cross-origin CORS requests for the element will have the credentials flag set.", "Use the credentials flag on Cross-origin CORS requests for the element."]}
{"SampleId": 3081518, "Origin": "Allocates an array of the specified length in unmanaged memory to hold references to objects\non the Java heap.", "Reference": "Allocates an array of the specified length to hold references to objects on the Java heap.", "LLMCandidates": ["Allocates an array of the specified length in unmanaged memory to hold references to objects on the Java heap.", "Allocates an array of the specified length in unmanaged memory to hold references to objects on the Java heap.", "Allocates an array of the specified length in unmanaged memory to hold references to objects on the Java heap.", "Allocates an array of the specified length in unmanaged memory to hold references to objects on the Java heap.", "Allocates an array of the specified length in unmanaged memory to hold references to objects on the Java heap."]}
{"SampleId": 1351493, "Origin": "Nota: the defining points are meant to be the extrema points inside the ribbon.", "Reference": "Nota: the defining points are meant to be the precise extrema Point2D values on the\nborders of the ribbon.", "LLMCandidates": ["Nota: The defining points are meant to be the extrema points inside the ribbon.", "The defining points are meant to be the extrema points inside the ribbon.", "The defining points are meant to be the extrema points inside the ribbon.", "Nota: The defining points are meant to be the extrema points inside the ribbon.", "Nota: the defining points are meant to be the extrema points inside the ribbon."]}
{"SampleId": 2337343, "Origin": "Customer lock status: * `false` - unlocked * `true` - locked  All users of this customer will be blocked and can not login anymore.", "Reference": "Customer is locked: * `false` - unlocked * `true` - locked  All users of this customer will be blocked and can not login anymore.", "LLMCandidates": ["Customer lock status: * `false` - unlocked * `true` - locked  All users of this customer will be blocked and can not login anymore.", "Customer lock status: * `false` - unlocked * `true` - locked  All users of this customer will be blocked and can not login anymore.", "Customer lock status: * `false` - unlocked * `true` - locked  All users of this customer will be blocked and can not login anymore.", "Customer lock status: * `false` - unlocked * `true` - locked  All users of this customer will be blocked and can not login anymore.", "Customer is locked: * `false` - unlocked * `true` - locked  All users of this customer will be blocked and can not login anymore. (default: `false`)\")"]}
{"SampleId": 1878720, "Origin": "A comparison of document clustering techniques\nKDD workshop on text mining, 2000", "Reference": "A Comparison of Document Clustering Techniques\nKDD workshop on text mining.", "LLMCandidates": ["A Comparison of Document Clustering Techniques\nKDD workshop on text mining. Vol. 400. No. 1\n\nThe content of the updated comment is as follows:\n\nA Comparison of Document Clustering Techniques\nKDD workshop on text mining. Vol. 400. No. 1", "A Comparison of Document Clustering Techniques\nKDD workshop on text mining. Vol. 400. No. 1", "A Comparison of Document Clustering Techniques\nKDD workshop on text mining. Vol. 400. No. 1", "A Comparison of Document Clustering Techniques\nKDD workshop on text mining. Vol. 400. No. 1", "A Comparison of Document Clustering Techniques\nKDD workshop on text mining. Vol. 400. No. 1\n\nNote: There are no changes needed in the method signature and variable names."]}
{"SampleId": 437086, "Origin": "Doesn't support date types.", "Reference": "Doesn't support date types or structs.", "LLMCandidates": ["Converts a TableRow into a Beam Row without the need for a TableSchema object. This is because the TableSchema contains redundant information and is not serializable, making it harder to propagate through a pipeline. However, it currently doesn't support date types.", "Converts a TableRow to a Row without using the corresponding TableSchema because it's not necessary and is harder to propagate through a pipeline. Currently, the method doesn't support date types. The intention is to deprecate the older function in favor of this one.", "Converts a TableRow directly without needing a TableSchema object as it can be derived from the Schema object and is easier to propagate through a pipeline. However, this method does not support date types in the conversion process. It is recommended to deprecate the toBeamRow(Schema, TableSchema, TableRow) function in favor of this one.", "Converts a TableRow into a Beam Row without needing access to the corresponding TableSchema, as it is redundant and not serializable. This function attempts to convert TableRows without accessing the corresponding TableSchema because 1) TableSchema contains redundant information already available in Schema, and 2) TableSchema objects are not serializable and are harder to propagate through a pipeline. However, this implementation currently doesn't support date types.", "Converts a TableRow without using a TableSchema object, as it is not serializable and contains redundant information already available in the Schema object. However, this function does not support date types."]}
{"SampleId": 5749488, "Origin": "Test method for {@link org.infinispan.spring.provider.SpringRemoteCacheManager#start()}.", "Reference": "Test method for {@link org.infinispan.spring.remote.provider.SpringRemoteCacheManager#start()}.", "LLMCandidates": ["Test method for {@link org.infinispan.spring.provider.SpringRemoteCacheManager#start()}.", "Test method for {@link org.infinispan.spring.provider.SpringRemoteCacheManager#start()}.", "Test method for {@link org.infinispan.spring.provider.SpringRemoteCacheManager#start()}.", "Test method for {@link org.infinispan.spring.provider.SpringRemoteCacheManager#start()}. The content of the updated code is as follows:\n\n@Test\n   public final void startShouldStartTheNativeRemoteCacheManager() throws IOException {\n      final RemoteCacheManager nativeCacheManager = new RemoteCacheManager(false);\n      objectUnderTest = new SpringRemoteCacheManager(nativeCacheManager);\n\n      objectUnderTest.start();\n\n      assertTrue(\"Calling start() on SpringRemoteCacheManager should start the enclosed \"\n                       + \"Infinispan RemoteCacheManager. However, it is still not running.\",\n                 nativeCacheManager.isStarted());", "Test method for {@link org.infinispan.spring.provider.SpringRemoteCacheManager#start()}."]}
{"SampleId": 3270305, "Origin": "Returns the expression node to the left of the \"::\" if it exists.", "Reference": "Returns the expression to the left of the \"::\" if it exists and is\nunambiguous.", "LLMCandidates": ["Returns the expression node to the left of the \"::\" if it exists and is not an ambiguous name.", "Returns the expression node to the left of the \"::\" if it exists and is not an ambiguous name.", "Returns the expression node to the left of the \"::\" if it's not an ambiguous name.", "Returns the expression node to the left of the \"::\" if it's not an ambiguous name.", "Returns the expression node to the left of the \"::\" if it is not an ASTAmbiguousName expression."]}
{"SampleId": 1678724, "Origin": "Execute function for each chunk of arguments.", "Reference": "Execute function for each chunk of arguments and collect the result.", "LLMCandidates": ["Execute function for each chunk of arguments by using the given processor.", "Execute function for each chunk of arguments using a lambda expression.", "Execute function for each chunk of arguments using a lambda expression.", "Execute function for each chunk of arguments, using a provided processor to handle the chunks.", "Execute function for each chunk of arguments using a lambda expression."]}
{"SampleId": 5241596, "Origin": "Runs a process using a custom timeout and a process terminator.", "Reference": "Runs a process using a custom termination check interval and a process\nterminator.", "LLMCandidates": ["Runs a process using a custom termination check interval and a process terminator.", "Runs a process using a custom termination check interval and a process terminator.", "Runs a process using a custom termination check interval and a process terminator.", "Runs a process using a custom timeout and a process terminator with the option to periodically check for termination instead of waiting for an exact timeout.", "Runs a process using a custom termination check interval and a process terminator."]}
{"SampleId": 4117756, "Origin": "(Shiro's default Authenticator\nallows null IPs to support localhost and proxy server environments).", "Reference": "(Shiro's default Authenticator allows null hosts to support localhost and proxy server environments).", "LLMCandidates": ["Supports null IPs for localhost and proxy server environments.", "The Authenticator now returns the hostname associated with a given InetAddress, allowing for better support of localhost and proxy server environments.", "This method returns the host of the InetAddress object. Shiro's default Authenticator allows null IPs to support localhost and proxy server environments.", "This method returns the hostname associated with this InetAddress object.", "Shiro's default Authenticator allows null IPs to support localhost and proxy server environments using host instead of inetAddress."]}
{"SampleId": 2615599, "Origin": "Adds an actor as a child of this group, immediately after another child actor.", "Reference": "If the\nactor is already a child of this group, no changes are made.", "LLMCandidates": ["Adds an actor as a child of this group, immediately after another child actor. If the actor has a parent, it is first removed from its current parent. The actor's stage and parent are then updated to the new parent (this group). This method also triggers a childrenChanged event.", "Adds an actor as a child of this group, immediately after another child actor, unless it is the same parent; in that case, no action will be taken.", "Adds an actor as a child of this group, immediately after another child actor. If the actor is already added to the parent group, it will not be removed.", "Adds an actor after another child actor within the same parent group if it exists, or adds the actor to the parent group if none is present.", "Adds an actor as a child of this group, immediately after another child actor, ensuring that the actor's parent is different from the current object before adding."]}
{"SampleId": 616737, "Origin": "TODO: If an input result partition of an involved region is not available, i.e.", "Reference": "If an input result partition of an involved region is not available, i.e.", "LLMCandidates": ["If an input result partition of an involved region is not available or its producer region is not visited yet, it will be visited and added to the list of regions to restart. The backtracking logic also considers consumer regions of an involved region, making sure they are included in the list if necessary.", "Implement backtracking logic to find all involved regions when an input result partition of a region is not available.", "If an input result partition of an involved region is not available, i.e., visit its producer region and all consumer regions of the involved region to determine if they should be restarted.", "If an input result partition of an involved region is not available, i.e., visit its producer region to check if it is also required for restart. Similarly, visit the consumer regions of the involved region as well, as they should be involved in the restart process as well.", "If an input result partition of an involved region is not available or its producer region is not already visited, i.e., all consumer regions of a restarted region should also be considered."]}
{"SampleId": 1880564, "Origin": "Use {@link #destroyToNaiveMatrix()} if you do not need further\nupdates.", "Reference": "Use {@link #destroyToPopulationMatrix()} if you do not need further\nupdates.", "LLMCandidates": ["Use {@link #destroyToPopulationMatrix()} if you do not need further updates.", "Create a population matrix using the makePopulationMatrix() method.", "Create a population matrix by scaling the elements with their corresponding weights. Use {@link #destroyPopulationMatrix()} if you do not need further updates.", "Use {@link #destroyToPopulationMatrix()} if you do not need further updates.", "Use {@link #destroyToPopulationMatrix()} if you do not need further updates."]}
{"SampleId": 1095693, "Origin": "This method currently handles\nevents for the classname combo box.", "Reference": "This method currently handles\nevents for the classname JLabeledChoice", "LLMCandidates": ["This method currently handles events for the classname combo box.", "This method currently handles events for the classname labeled choice component.", "This method currently handles events for the classNameLabeledChoice combo box.", "This method currently handles events for the classNameLabeledChoice component.", "This method currently handles events for the classNameLabeledChoice component."]}
{"SampleId": 4622144, "Origin": "Waits until the query with the specified id has been started.", "Reference": "Waits until a very slow query has been started.", "LLMCandidates": ["Waits until the query with the specified id has been started.", "Waits until the very slow query has been started.", "Waits until the very slow query has been started.", "Waits for a query with the specified id to become active.", "Waits for a query with the specified id to become active."]}
{"SampleId": 3566648, "Origin": "{@code handshake} will be null and {@code throwable} will be non-null in the case of a\nfailed TLS connection attempt.", "Reference": "{@code handshake} will be null and {@code ioe} will be non-null in the case of a\nfailed TLS connection attempt.", "LLMCandidates": ["@code handshake} will be null and {@code ioe} will be non-null in the case of a failed TLS connection attempt.", "@code handshake} will be null and {@code ioe} will be non-null in the case of a failed TLS connection attempt.", "@code handshake} will be null and {@code ioe} will be non-null in the case of a failed TLS connection attempt.", "@code handshake} will be null and {@code ioe} will be non-null in the case of a failed TLS connection attempt.", "@code handshake} will be null and {@code ioe} will be non-null in the case of a failed TLS connection attempt."]}
{"SampleId": 1314713, "Origin": "Creates an audit entry when a service definition is deleted.", "Reference": "Creates an audit entry when a API definition is deleted.", "LLMCandidates": ["Creates an audit entry when an API definition is deleted.", "Creates an audit entry when an API definition is deleted.", "Creates an audit entry when an API definition is deleted.", "Creates an audit entry when a service definition is deleted.", "Creates an audit entry when a service definition is deleted."]}
{"SampleId": 3493342, "Origin": "Schedules package actions differentiating their type among Linux and Solaris\nservers.", "Reference": "Schedules package actions.", "LLMCandidates": ["Schedules package actions for Linux servers only, differentiating their type from Solaris servers.", "Schedules package actions differentiating their type among Linux servers only.", "Schedules package actions on Linux servers, differentiating their type from Solaris systems if necessary.", "Schedules package actions differentiating their type among Linux servers only.", "Schedules package actions differentiating their type among Linux servers only."]}
{"SampleId": 1327230, "Origin": "Returns the partition ID for the given key.", "Reference": "Returns the service ID for the given primitive ID.", "LLMCandidates": ["Returns the service ID for the given key.", "Returns the partition ID for the given key and service identifier.", "Returns the partition ID for the given key and service identifier.", "Returns the service ID for the given identifier.", "Returns the service ID for the given identifier."]}
{"SampleId": 2480730, "Origin": "Return the formatted string.", "Reference": "Return the formatted string in its current state.", "LLMCandidates": ["Return the formatted string by invoking toString() on this.text.", "Return the formatted string using the text.", "Return the formatted string of this.text object.", "Return the formatted string of this.text object.", "Return the string representation of the text."]}
{"SampleId": 5367566, "Origin": "If --all is specified, --interface won't be visible", "Reference": "If --all is specified, --entity won't be visible", "LLMCandidates": ["If --all is specified, --entity won't be visible", "If --all is specified, --entity won't be visible", "The --entity parameter will not be visible if --all is specified.", "If --all is specified, --entity won't be visible", "If --all is specified, --entity won't be visible"]}
{"SampleId": 1836978, "Origin": "Returns the raw binary representation of the handshake header.", "Reference": "Returns the raw binary representation of the handshake message.", "LLMCandidates": ["Returns the raw binary representation of the handshake header including a fragmented message, if available, or simply returns null otherwise.", "Converts the current object to a byte array representation of its handshake message. This method checks if the rawMessage is already available and returns it if it exists. Otherwise, it encodes the message into a byte array using a DatagramWriter object, considering fragment length, header, sequence number, and offset.", "Encodes the message data into a byte array, returning it if it has not been generated before. If rawMessage is null and byteArray is also null, the method creates a DatagramWriter with the appropriate size, writes the fixed-size handshake message header, writes the fragmentByteArray, and returns the writer's byte array in byteArray for future use.", "Returns the raw binary representation of the handshake header based on the given message and fragment information.", "Encodes the handshake message into a binary format using DatagramWriter and returns the byte array representation."]}
{"SampleId": 4386708, "Origin": "Access Control Using AWS Identity and Access Management (IAM) \n.", "Reference": "For more information, see Access Control Using AWS Identity and Access Management (IAM).", "LLMCandidates": ["Performs a complete multipart upload operation on Amazon S3 by using AWS Identity and Access Management (IAM).", "Complete a multipart upload using AWS Identity and Access Management (IAM).", "Complete multipart uploads using AWS Identity and Access Management (IAM).", "Complete multipart uploads using AWS Identity and Access Management (IAM).", "This method completes a multipart upload operation using an existing uploaded parts list from the client. It receives a CompleteMultipartUploadRequest and returns a CompleteMultipartUploadResult."]}
{"SampleId": 125265, "Origin": "Sets the console script.", "Reference": "Sets the web server script.", "LLMCandidates": ["Sets the web server script.", "Sets the web server script.", "Sets the web server script.", "Sets the web server script.", "Sets the web server script."]}
{"SampleId": 2824496, "Origin": "Should return {@code null} for values that cannot be compared\nunder Comparability semantics.", "Reference": "Should return {@code Comparison.UNDEFINED} for values that cannot be compared\nunder Comparability semantics.", "LLMCandidates": ["Should return {@code Comparison} for values that can be compared under Comparability semantics.", "Should return {@code null} for values that cannot be compared under Comparability semantics if both values are undefined.", "Should return {@code null} for values that cannot be compared under Comparability semantics if both values are undefined.", "The method should return {@code null} if both values are undefined or can't be compared under Comparability semantics.", "Should return {@code null} for values that cannot be compared under Comparability semantics if either value is undefined or both are undefined."]}
{"SampleId": 4479746, "Origin": "{@codesnippet com.azure.storage.blob.specialized.PageBlobClient.copyIncremental#URL-String}", "Reference": "{@codesnippet com.azure.storage.blob.specialized.PageBlobClient.copyIncremental#String-String}", "LLMCandidates": ["@codesnippet com.azure.storage.blob.specialized.PageBlobClient.copyIncremental#String-String", "@codesnippet com.azure.storage.blob.specialized.PageBlobClient.copyIncremental#String-String", "@codesnippet com.azure.storage.blob.specialized.PageBlobClient.copyIncremental#String-String", "@codesnippet com.azure.storage.blob.specialized.PageBlobClient.copyIncremental#String-String", "@codesnippet com.azure.storage.blob.specialized.PageBlobClient.copyIncremental#String-String"]}
{"SampleId": 3325967, "Origin": "Backs up the subscriptions and bookmarks databases to external storage.", "Reference": "Backs up the databases to external storage.", "LLMCandidates": ["Backs up all database files (SubscriptionsDb, BookmarksDb, PlaybackStatusDb, ChannelFilteringDb, and SearchHistoryDb) to external storage.", "Backs up the subscriptions, bookmarks, playback status, channel filtering, and search history databases to external storage.", "Backs up the subscriptions, bookmarks, playback status, channel filtering, and search history databases to external storage.", "Backs up the subscriptions, bookmarks, playback statuses, channel filterings and search history databases to external storage.", "Backs up subscriptions, bookmarks, playback status, channel filtering, and search history databases to external storage."]}
{"SampleId": 234012, "Origin": "If the lock list is write locked, returns LockMode.WRITE.", "Reference": "If mode is read but the lock list is write locked, returns LockMode.WRITE.", "LLMCandidates": ["If the lock list is write locked, returns LockMode.WRITE.", "Returns LockMode.WRITE if the lock list is write locked, otherwise returns the same mode.", "If the lock list is write locked, returns LockMode.WRITE; else returns mode.", "If the lock list is write locked, returns LockMode.WRITE; else returns mode.", "If the lock list is write locked, returns LockMode.WRITE."]}
{"SampleId": 6188983, "Origin": "Custom logic to only enable the configuration element as this is immutable and once the MuleContext is started we cannot change\nvalues.", "Reference": "MuleConfiguration for instance is immutable and once the MuleContext is started we cannot change its values.", "LLMCandidates": ["This method enables MuleObjects in a specific configuration by checking if they have the CONFIGURATION_IDENTIFIER identifier. It uses ConfigurationDependencyResolver and MinimalApplicationModelGenerator to generate minimal models based on the given conditions.", "Enables MuleObjects by checking if the configuration element is present and only allowing it to be enabled as an immutable component after the MuleContext has started. The method also uses a transaction factory type visitor for further verification.", "Enable Mule Objects configuration by returning true if the component identifier is CONFIGURATION_IDENTIFIER and checking if transaction factory type is used in the component.", "Enables MuleObjects by checking if a component's identifier is CONFIGURATION_IDENTIFIER and if it's not, it checks if the component is a TransactionManagerFactory. If it is, the method returns true, otherwise false.", "Enables MuleObjects and checks if the configuration element is being used. If so, it only enables that specific configuration element to prevent values from changing after the MuleContext has started. The method also checks for transaction factory types."]}
{"SampleId": 3775230, "Origin": "If the new value is not equal to\n{@code getValue()}, fires a value change event.", "Reference": "If the new value is not equal to\n{@code getValue()}, fires a {@link ValueChangeEvent}.", "LLMCandidates": ["Set the new value by checking if it's not equal to {@code getValue()}, and fires a value change event if necessary.", "Fires a value change event if the new value is not equal to {@code getValue()}.", "Fires a value change event if the new value is not equal to {@code getValue()}.", "If the new value is not equal to {@code getValue()}, fires a value change event.", "If the new value is not equal to {@code getValue()}, fires a value change event."]}
{"SampleId": 5763909, "Origin": "Gets a collection of bibentries and sets an ID for every entry.", "Reference": "Gets a collection of entries and sets an ID for every entry.", "LLMCandidates": ["Gets a collection of entries and sets an ID for every entry, then inserts them into a BibDatabase.", "Gets a collection of entries and sets an ID for every entry, then inserts them into the database.", "Gets a collection of entries and sets an ID for every entry, then inserts them into the database.", "Creates a BibDatabase from a Collection of BibEntries by setting an ID for each entry and inserting them into the database.", "Gets a collection of entries, sets an ID for every entry, and inserts them into the database."]}
{"SampleId": 3678294, "Origin": "Obtains an instance of {@code ZonedDateTime} from an {@code OffsetDateTime}.", "Reference": "Obtains an instance of {@code ZonedDateTime} from the instant formed by combining\nthe local date-time and offset.", "LLMCandidates": ["Obtains an instance of {@code ZonedDateTime} from a {@code LocalDateTime}, considering the provided {@code ZoneOffset} and {@code ZoneId}.", "Obtains an instance of {@code ZonedDateTime} from a {@code LocalDateTime}, considering {@code ZoneOffset} and {@code ZoneId}.", "Obtains an instance of ZonedDateTime from a LocalDateTime and ZoneOffset.", "Obtains an instance of ZonedDateTime from a LocalDateTime and ZoneOffset.", "Obtains an instance of {@code ZonedDateTime} from a {@code LocalDateTime} and {@code ZoneOffset}."]}
{"SampleId": 336223, "Origin": "Called when a track info is deselected.", "Reference": "Called when a track is deselected.", "LLMCandidates": ["Called when a track info is deselected with non-nullable parameters.", "Called when a track info is deselected, with additional parameters now marked as non-null.", "Called when a track info is deselected with non-null arguments for controller and trackInfo.", "Called when a track info is deselected with non-null arguments for controller and trackInfo.", "Called when a track info is deselected with an additional restriction on parameters being non-null."]}
{"SampleId": 340563, "Origin": "Gets current playback position as a {@link MediaTimestamp2}.", "Reference": "Gets current playback position as a {@link MediaTimestamp}.", "LLMCandidates": ["Gets current playback position as a {@link MediaTimestamp}.", "Gets current playback position as a {@link MediaTimestamp}.", "Gets current playback position as a {@link MediaTimestamp}.", "Gets current playback position as a {@link MediaTimestamp}.", "Gets current playback position as a {@link MediaTimestamp}."]}
{"SampleId": 1765423, "Origin": "Internal mapper to remember and add all types for the RecyclerView.", "Reference": "Internal mapper to remember and add all view types for the items.", "LLMCandidates": ["Internal mapper to remember and add all types for the RecyclerView.", "Internal mapper to remember and add all types for the RecyclerView.", "Internal mapper to remember and add all types for the RecyclerView.", "Internal mapper to remember and add all types for the RecyclerView.", "Internal mapper to remember and add all types for the RecyclerView."]}
{"SampleId": 3355672, "Origin": "They are not accessible in the handler provided as parameter.", "Reference": "They are NOT accessible in the handler provided as parameter.", "LLMCandidates": ["Creates an HTTP server route for WebSockets, using the provided path and handler function to handle incoming and outgoing messages. The protocols can be specified optionally.", "This method creates an HttpServerRoutes instance for a WebSocket endpoint by providing a path, handler, and optional protocols. The handler is invoked with WebsocketInbound and WebsocketOutbound parameters.", "The comment is already clear and accurate. No changes needed.", "The comment is already clear and accurate. No changes needed.", "The WebSocket server routes can be configured using a handler to handle incoming and outgoing WebSocket connections. The provided handler should return a Publisher<Void> for each WebSocket session. This method also allows specifying the allowed protocols as an optional parameter, defaulting to null."]}
{"SampleId": 5456947, "Origin": "XML Catalogs, OASIS Standard V1.1, invalid path entries will be ignored.", "Reference": "XML Catalogs, OASIS Standard V1.1, if a catalog entry is invalid, it\nis ignored.", "LLMCandidates": ["XML Catalogs, OASIS Standard V1.1, invalid URI entries will be ignored.", "XML Catalogs, OASIS Standard V1.1, invalid URI entries will be ignored.", "XML Catalogs, OASIS Standard V1.1, invalid URI entries will be ignored.", "Catalog constructor takes URI instead of string path entries for catalog items; validation for syntax errors in provided URIs is performed before creating the catalog instance.", "Catalog features are used with URI paths instead of raw Strings. Invalid URIs will be ignored."]}
{"SampleId": 2544523, "Origin": "In order to apply the rotation transformation to an existing transformation,\nuse {@link #rotate(Quaterniond) rotate()} instead.", "Reference": "In order to apply the rotation transformation to an existing transformation,\nuse {@link #rotate(Quaterniondc) rotate()} instead.", "LLMCandidates": ["In order to apply the rotation transformation to an existing Matrix3d object, use {@link #rotation(Quaterniond) rotation()} instead.", "In order to apply the rotation transformation to an existing transformation, use {@link #rotate(Quaterniondc) rotate()} instead.", "This method applies a rotation transformation based on a Quaterniond input.", "To apply the rotation transformation to an existing transformation using a Quaterniond instance, use {@link #rotation(Quaterniondc)} instead.", "In order to apply the rotation transformation to an existing transformation with a double precision quaternion, use {@link #rotate(Quaterniondc) rotate()} instead."]}
{"SampleId": 4622194, "Origin": "Returns the servlet request instance.", "Reference": "Returns the current HTTP connection.", "LLMCandidates": ["Returns the HTTP connection instance.", "Returns the HTTP connection instance.", "Returns the HTTP connection instance.", "Returns the HTTP connection instance.", "Returns the HTTP connection instance."]}
{"SampleId": 431986, "Origin": "Varargs version of {@link #addState(Closure, Object, java.util.Set)}.", "Reference": "Varargs version of {@link #addState(Consumer, Object, java.util.Set)}.", "LLMCandidates": ["Varargs version of {@link #addState(Consumer, Object, java.util.Set)}.", "Varargs version of {@link #addState(Consumer, Object, java.util.Set)}.", "Varargs version of {@link #addState(Consumer, Object, java.util.Set)}.", "Varargs version of {@link #addState(Consumer, Object, java.util.Set)", "Varargs version of {@link #addState(Consumer, Object, java.util.Set)}."]}
{"SampleId": 4374184, "Origin": "This completes the switch.", "Reference": "This completes the change.", "LLMCandidates": ["This method enables all features by executing them after preparing the request with beforeClientExecution().", "This enables all features based on the provided request.", "This enables all features based on the provided request.", "Enable full control by switching to enable all features instead.", "Enable full control by switching to enable all features instead."]}
{"SampleId": 2312555, "Origin": "Creates a command that can be run later which will restore a display to its\ncurrent state.", "Reference": "Creates a module that can be run later which will restore a display to its\ncurrent state.", "LLMCandidates": ["Creates a module that can be restored later which will set a display to its current state using the given display and its current state, along with the memory usage required for the restoration.", "Creates a module containing a command that can be run later which will restore a display to its current state.", "Creates a module that can be run later which will restore a display to its current state.", "Creates a command that can be run later which will restore a module's state to its current value.", "Creates a command that can be run later which will restore a module's state to its current value."]}
{"SampleId": 2427472, "Origin": "Return the underlying expression tree.", "Reference": "Return the math expression as operation tree.", "LLMCandidates": ["Return the underlying expression tree as a Tree.", "Return the underlying expression tree.", "Return the underlying expression tree.", "Return the underlying expression tree.", "Return the underlying expression tree."]}
{"SampleId": 3080392, "Origin": "A guarded transition from native to Java.", "Reference": "An unguarded transition to Java.", "LLMCandidates": ["Set the status to Java unguarded.", "A guarded transition from native to Java is not supported anymore. Instead, use setStatusJavaUnguarded() for setting the status to Java directly without guards.", "Set the status to Java without any guards.", "Set the volatile status to Java unguarded.", "Set the volatile status to Java unguarded."]}
{"SampleId": 115634, "Origin": "Setter for the auto-pull flag.", "Reference": "Setter for the pull-after flag.", "LLMCandidates": ["Setter for the pull-after flag.", "Setter for the pull after flag.", "Setter for the pull after flag.", "Setter for the pull after flag.", "Setter for the pull after flag."]}
{"SampleId": 3084134, "Origin": "Calls {@link #arrayAllocationSize(int, int, int, GraalHotSpotVMConfig)} using an injected VM\nconfiguration object.", "Reference": "Calls {@link #arrayAllocationSize(int, int, int, int)} using an injected VM configuration\nobject.", "LLMCandidates": ["Calls {@link #arrayAllocationSize(int, int, int, GraalHotSpotVMConfig)} using an injected VM configuration object.", "Calls {@link #arrayAllocationSize(int, int, int, GraalHotSpotVMConfig)} using an injected VM configuration object with alignment calculated from the provided INJECTED_VMCONFIG.", "Calls {@link #arrayAllocationSize(int, int, int, GraalHotSpotVMConfig)} using an injected VM configuration object with the objectAlignment() method.", "Calls {@link #arrayAllocationSize(int, int, int, GraalHotSpotVMConfig)} using an injected VM configuration object with the alignment value.", "Calls {@link #arrayAllocationSize(int, int, int, GraalHotSpotVMConfig)} using an injected VM configuration object with objectAlignment."]}
{"SampleId": 232605, "Origin": "Get a table object based on the identifier.", "Reference": "Get a table object by name.", "LLMCandidates": ["Get a table object based on the given database and table names.", "Retrieve a table based on the given database and table names.", "Get a table object based on the database and table names provided.", "Get a table object based on the database and table names provided.", "Get a table object based on the provided database and table names."]}
{"SampleId": 3861954, "Origin": "reverts local changes for this post, replacing it with the latest version from the server", "Reference": "discard local changes for this post, replacing it with the latest version from the server", "LLMCandidates": ["discards local changes for this post, replacing it with the latest version from the server.", "Discards local changes for this post, replacing it with the latest version from the server", "Discards local changes for this post, replacing it with the latest version from the server if a connection is available.", "discards any local changes made to this post, reloading the most recent version from the server", "discards any local changes made to this post, reloading the most recent version from the server"]}
{"SampleId": 2706458, "Origin": "Get Multiply Rate.", "Reference": "Get Faktor.", "LLMCandidates": ["Get Multiply Rate for current record", "Get Multiply Rate (Override)", "Get Multiply Rate (Override)", "Get Multiply Rate (Return BigDecimal from column COLUMNNAME_MultiplyRate or default to 0 if not available).", "Get multiply rate from the column named MultiplyRate, return it if available, otherwise return 0."]}
{"SampleId": 2312346, "Origin": "By design the return value is not a {@link WithinRangeCondition}.", "Reference": "By design the return value is not a speciailized version of a Condition.", "LLMCandidates": ["By design the return value is not a {@link WithinRangeCondition}.", "By design the return value is not a {@link WithinRangeCondition}.", "By design, the return value is not a {@link WithinRangeCondition}.", "By design, the return value is not a {@link WithinRangeCondition}.", "By design the return value is not a {@link WithinRangeCondition}."]}
{"SampleId": 2794170, "Origin": "This method sets the value of the database column m_prj_risk.dateraised", "Reference": "This method sets the value of the database column m_prj_risk.raisedDate", "LLMCandidates": ["This method sets the value of the database column m_prj_risk.raiseddate", "This method sets the value of the database column m_prj_risk.raiseddate.", "This method sets the value of the database column m_prj_risk.raiseddate.", "This method sets the value of the database column m_prj_risk.raiseddate", "This method sets the value of the database column m_prj_risk.raiseddate"]}
{"SampleId": 3366652, "Origin": "Returns the Realm Type, in the described table, of the named column.", "Reference": "Returns the {@link ColumnDetails}, in the described table, of the named column.", "LLMCandidates": ["Returns the details of the named column in the described table.", "Returns the details of a column with the specified name from the indicesMap.", "Returns the details of the named column in the specified table.", "Returns the details of the named column in the specified table.", "Returns the ColumnDetails object from the indicesMap for the specified columnName."]}
{"SampleId": 611958, "Origin": "Finds the table schema that can be used for a format schema (without time attributes).", "Reference": "Finds the table schema that can be used for a format schema (without time attributes and generated columns).", "LLMCandidates": ["Derives a table schema with physical fields based on a given format schema and additional properties.", "Finds the table schema that can be used for a format schema, considering time attributes and generated columns.", "Finds the table schema that can be used for a format schema (with or without time attributes), based on the given properties.", "Finds the table schema that can be used for a format schema (with or without time attributes). If the field is a generated column, it will not be added to the TableSchema.", "Finds the table schema that can be used for a format schema (without time attributes), considering the presence of generated columns and the reference fields."]}
{"SampleId": 5471048, "Origin": "Note: This API uses {@link Class} instead of {@link Module} to provide backwards\ncompatibility for JVMCI clients compiled against a JDK release earlier than 9.", "Reference": "Note: This API uses {@link Class} instead of {@code Module} to provide backwards\ncompatibility for JVMCI clients compiled against a JDK release earlier than 9.", "LLMCandidates": ["Note: This API uses {@link Class} instead of {@link Module} to provide backwards compatibility for JVMCI clients compiled against a JDK release earlier than 9.", "Note: This API uses {@link Class} instead of {@link Module} to provide backwards compatibility for JVMCI clients compiled against a JDK release earlier than 9. In newer releases (JAVA_SPECIFICATION_VERSION >= 9), it utilizes {@link Module} and checks for package exports using methods like {@link Module#getPackages(Object)}, {@link Module#isExported(String, Object)} and {@link Module#addExports(String, Object)}.", "This API uses {@link Class} instead of {@link Module} to provide backwards compatibility for JVMCI clients compiled against a JDK release earlier than 9. It now supports additional checks and exports using the new features introduced in Java specification version 9.", "This API uses {@link Class} instead of {@link Module} to provide backwards compatibility for JVMCI clients compiled against a JDK release earlier than 9. In the updated code, JAVA_SPECIFICATION_VERSION is used to check if the current version is 9 or later. If it's 9 or later, {@link Module} is used directly; otherwise, {@link Class} is still used for compatibility with older releases.", "Note: This API uses {@link Class} instead of {@link Module} to provide backwards compatibility for JVMCI clients compiled against a JDK release earlier than 9. If the JAVA_SPECIFICATION_VERSION is greater or equal to 9, this method directly utilizes {@link Module}."]}
{"SampleId": 3677398, "Origin": "Obtains an instance of {@code OffsetDateTime} from a date-time object.", "Reference": "Obtains an instance of {@code OffsetDateTime} from a temporal object.", "LLMCandidates": ["Obtains an instance of {@code OffsetDateTime} from a temporal object.", "Obtains an instance of OffsetDateTime from a date-time object.", "Obtains an instance of {@code OffsetDateTime} from a date-time object, attempting to handle different input types and exceptions.", "Obtains an instance of {@code OffsetDateTime} from a date-time object. The method first checks if the input is already an {@code OffsetDateTime}, and returns it if so. If not, it determines the {@code ZoneOffset} and converts either a {@code LocalDateTime} or {@code Instant} object to an {@code OffsetDateTime} using the determined offset.", "Obtains an instance of OffsetDateTime from a date-time object."]}
{"SampleId": 84978, "Origin": "Primitive operation which inserts the node at the tail of the frontier.", "Reference": "Inserts the node at the tail of the frontier.", "LLMCandidates": ["Primitive operation which inserts the node at the head of the frontier.", "Inserts the node at the end of the frontier list, updating metrics accordingly.", "Inserts the node at the tail of the frontier.", "Inserts the node at the tail of the frontier.", "Primitive operation which inserts the node at the head of the frontier."]}
{"SampleId": 4476355, "Origin": "{@codesnippet com.azure.data.applicationconfig.configurationclient.listSettingRevisions#settingSelector}", "Reference": "{@codesnippet com.azure.data.applicationconfig.configurationclient.listRevisions#settingSelector}", "LLMCandidates": ["@codesnippet com.azure.data.applicationconfig.configurationclient.listRevisions#settingSelector", "@codesnippet com.azure.data.applicationconfig.configurationclient.listRevisions#settingSelector", "@codesnippet com.azure.data.applicationconfig.configurationclient.listRevisions#settingSelector", "listSettingRevisions has been renamed to listRevisions. The method now accepts a SettingSelector and returns PagedIterable of ConfigurationSettings.", "@codesnippet com.azure.data.applicationconfig.configurationclient.listRevisions#settingSelector"]}
{"SampleId": 2913757, "Origin": "Obtains an instance from the specified unique name.", "Reference": "Obtains an instance from the specified name.", "LLMCandidates": ["Obtains an instance from the specified unique name.", "Creates an instance of FxResetFixingRelativeTo from the given unique name.", "Obtains an instance from the specified name.", "Obtains an instance from the specified name.", "Obtains an instance from the specified name by parsing it."]}
{"SampleId": 4396564, "Origin": "Returns a string representation of this object; useful for testing and debugging.", "Reference": "Returns a string representation of this object.", "LLMCandidates": ["Returns a string representation of this object; useful for testing and debugging; sensitive data is redacted.", "Returns a string representation of this object; useful for testing and debugging, with sensitive data redacted.", "Returns a string representation of this object; useful for testing and debugging; ***Sensitive Data Redacted*** is replaced in the output.", "Returns a string representation of this object, with sensitive data redacted; useful for testing and debugging.", "Returns a string representation of this object; useful for testing and debugging, with sensitive information redacted."]}
{"SampleId": 6320778, "Origin": "Create a new detached JDOQuery instance with the given projection", "Reference": "Create a new detached {@link JDOQuery} instance with the given projection", "LLMCandidates": ["Create a new detached JDOQuery instance with the given projection", "Create a new detached JDOQuery instance with the given projection and apply the distinct constraint.", "Create a new detached JDOQuery instance with the given projection and apply the distinct constraint.", "Create a new detached JDOQuery instance with the given projection and apply distinct() operation to it.", "Create a new detached JDOQuery instance using the given projection and apply distinct() operation."]}
{"SampleId": 237391, "Origin": "Tests the {@link FileSystemMaster#checkConsistency(AlluxioURI, CheckConsistencyOptions)} method\nwhen some files are consistent in a larger inode tree.", "Reference": "Tests the {@link FileSystemMaster#checkConsistency(AlluxioURI, CheckConsistencyContext)} method\nwhen some files are consistent in a larger inode tree.", "LLMCandidates": ["Tests the {@link FileSystemMaster#checkConsistency(AlluxioURI, CheckConsistencyContext)} method when some files are consistent in a larger inode tree.", "Tests the FileSystemMaster#checkConsistency(AlluxioURI, CheckConsistencyContext) method when some files are consistent in a larger inode tree.", "Tests the {@link FileSystemMaster#checkConsistency(AlluxioURI, CheckConsistencyContext)} method when some files are consistent in a larger inode tree.", "Tests the {@link FileSystemMaster#checkConsistency(AlluxioURI, CheckConsistencyOptions)} method when some files are consistent in a larger inode tree.\n\n Tests the {@link FileSystemMaster#checkConsistency(AlluxioURI, CheckConsistencyContext)} method when some files are consistent in a larger inode tree.", "Tests the FileSystemMaster#checkConsistency(AlluxioURI, CheckConsistencyContext)} method when some files are consistent in a larger inode tree."]}
{"SampleId": 4591717, "Origin": "Add init return statments.", "Reference": "Add nil return statement.", "LLMCandidates": ["Add nil return statements.", "Add nil return statement to a block stmt.", "Add a nil return statement to the given block statement.", "Add a nil return statement to the given block statement.", "Add a nil return statement to the given block statement."]}
{"SampleId": 4476809, "Origin": "The {@link RsaKeyCreateOptions#isEnabled() enabled}\nfield is set to true by Azure Key Vault, if not specified.", "Reference": "The {@link CreateRsaKeyOptions#isEnabled() enabled}\nfield is set to true by Azure Key Vault, if not specified.", "LLMCandidates": ["The {@link CreateRsaKeyOptions#isEnabled() enabled} field is set to true by Azure Key Vault, if not specified.", "The {@link CreateRsaKeyOptions#isEnabled() enabled} field is set to true by Azure Key Vault, if not specified.", "The {@link CreateRsaKeyOptions#isEnabled() enabled} field is set to true by Azure Key Vault, if not specified.", "The {@link CreateRsaKeyOptions#isEnabled() enabled} field is set to true by Azure Key Vault, if not specified.", "The {@link CreateRsaKeyOptions#isEnabled() enabled} field is set to true by Azure Key Vault, if not specified."]}
{"SampleId": 2049948, "Origin": "Asserts that the cache contains the given data for {@code uriString}.", "Reference": "Asserts that the cache contains necessary data for the {@code requestSet}.", "LLMCandidates": ["Asserts that the cache contains the given data for each RequestSet item specified by {@code requestSet}.", "Asserts that the cache contains the given data for each element in {@code requestSet}.", "Asserts that the cache contains the given data for a set of {@code RequestSet} items.", "Asserts that the cache contains the given data for a set of {@code RequestSet} items.", "Asserts that the cache contains the given data for all items in {@code requestSet}."]}
{"SampleId": 232736, "Origin": "Creates a new leader {@link FileSystemMaster} from journal along with its dependencies, and\nreturns the master registry containing that master.", "Reference": "Creates a new leader {@link FileSystemMaster} from journal along with its dependencies, and\nreturns the master registry and the journal system.", "LLMCandidates": ["Creates a new leader {@link FileSystemMaster} from journal along with its dependencies, and returns the master registry containing that master.", "Creates a new leader {@link FsMasterResource} from journal along with its dependencies, and returns the master registry containing that master.", "Creates a new leader {@link FsMasterResource} from journal along with its dependencies, and returns the master registry containing that master.", "Creates a new leader {@link FileSystemMaster} from journal along with its dependencies, and returns the master registry containing that master.", "Creates a new leader {@link FsMasterResource} from journal along with its dependencies, and returns the master registry containing that master."]}
{"SampleId": 4856970, "Origin": "{@link net.dv8tion.jda.api.requests.ErrorResponse#UNKNOWN_EMOJI}", "Reference": "{@link net.dv8tion.jda.api.requests.ErrorResponse#UNKNOWN_EMOJI UNKNOWN_EMOJI}", "LLMCandidates": ["Adds a reaction by Unicode or U+ codepoints to a specific message. This method uses EncodingUtil to encode the provided unicode string. If the string starts with \"U+\", it encodes using the codepointUTF8, otherwise it encodes using the regular UTF-8 encoding. Then, it compiles the Route.Messages.ADD_REACTION route and returns a RestActionImpl object for this operation.", "Adds a reaction to a message identified by its ID with the provided Unicode string.", "Adds a reaction to a message identified by its ID with the provided Unicode string.", "@link net.dv8tion.jda.api.requests.ErrorResponse#UNKNOWN_EMOJI", "Adds a reaction to the specified message by given Unicode. If the Unicode string starts with \"U+\", it is encoded using UTF-8 code points. Otherwise, it is encoded using standard UTF-8 encoding. The resultant encoded string is used to compile a route for the Messages.ADD_REACTION endpoint, and a RestAction object is returned."]}
{"SampleId": 2289333, "Origin": "The provided {@link XMPPError XMPPError}.", "Reference": "The provided {@link StanzaError XMPPError}.", "LLMCandidates": ["Create an error response IQ based on the given {@link StanzaError StanzaError}.", "The provided {@link StanzaError StanzaError}.", "The provided {@link StanzaError StanzaError}.", "The provided {@link StanzaError StanzaError}.", "The provided {@link StanzaError StanzaError}."]}
{"SampleId": 1837081, "Origin": "The executor will shutdown\non {@link #shutdown()}, if not detached.", "Reference": "The executors will shutdown\non {@link #shutdown()}, if not detached.", "LLMCandidates": ["The executor will shutdown on {@link #shutdown()}, if not detached, with secondaryExecutor being used.", "The executor will shutdown on {@link #shutdown()}, if not detached, and secondaryExecutor will shutdown on {@link #shutdownSecondary()}, if not detached.", "Sets the primary executor, secondary executor, and detach state when called. The primary executor will shutdown on {@link #shutdown()}, if not detached.", "The executor will shutdown on {@link #shutdown()}, if not detached, and sets a secondaryExecutor for additional concurrent tasks.", "The executor will shutdown on {@link #shutdown()}, if not detached, and the secondaryExecutor will shutdown on {@link #secondaryShutdown()} if not detached."]}
{"SampleId": 339145, "Origin": "The ParcelFileDescriptor will be closed when the list\nbecomes empty.", "Reference": "The ParcelFileDescriptor will\nbe closed when the count becomes zero.", "LLMCandidates": ["The ParcelFileDescriptor will be closed when the ref count becomes zero.", "The ParcelFileDescriptor will be closed when the ref count becomes zero.", "The ParcelFileDescriptor will be closed when the ref count becomes 0.", "The ParcelFileDescriptor will be closed when the ref count reaches 0.", "The ParcelFileDescriptor will be closed when the reference count reaches zero."]}
{"SampleId": 5179168, "Origin": "Returns the client preferences.", "Reference": "Returns the request including client preferences.", "LLMCandidates": ["Gets the current request object.", "Returns the current request information.", "Returns the current request information.", "Retrieves the current request object.", "Retrieves the current request object."]}
{"SampleId": 2700190, "Origin": "Get UPC/EAN.", "Reference": "Get TU-UPC.", "LLMCandidates": ["Get UPC-TU.", "Get UPC/TU.", "Get UPC/TU.", "Get UPC/TU.", "Get UPC/TU."]}
{"SampleId": 6104684, "Origin": "Returns the value of the {@code bitfield} field.", "Reference": "Returns the value of the {@code direction} field.", "LLMCandidates": ["Returns the value of the {@code direction} field.", "Returns the value of the {@code direction} field.", "Returns the value of the {@code direction} field.", "Returns the value of the {@code direction} field.", "Returns the value of the {@code direction} field."]}
{"SampleId": 4132857, "Origin": "Get the last time this object was used in ms.", "Reference": "Gets the last time this object was used in milliseconds.", "LLMCandidates": ["Get the last time this object was used in ms.", "Get the last time this object was used in ms, considering the change from \"lastUsed\" to \"lastUsedMillis\".", "Get the last time this object was used in ms.", "Get the last time this object was used in ms.", "Get the last time this object was used in ms."]}
{"SampleId": 5724509, "Origin": "Convenience method for getScheme(host.getSchemeName())", "Reference": "Convenience method for {@code getScheme(host.getSchemeName())}", "LLMCandidates": ["Convenience method for getScheme(host.getSchemeName()) with Args.notNull check on input host.", "Convenience method for getScheme(host.getSchemeName()), withArgs check on host variable.", "Convenience method for getScheme(host.getSchemeName()) with Args.notNull check on host parameter.", "Convenience method for getScheme(host.getSchemeName()). Args.notNull(host, \"Host\") is used to validate the non-null input.", "GetScheme(host.getSchemeName()). Convenience method for getScheme."]}
{"SampleId": 2916600, "Origin": "The meta-property for the {@code expiryDateTime} property.", "Reference": "The meta-property for the {@code expiry} property.", "LLMCandidates": ["The meta-property for the {@code expiry} property.", "The meta-property for the {@code expiry} property.", "The meta-property for the {@code expiry} property.", "The meta-property for the {@code expiry} property.", "The meta-property for the {@code expiry} property."]}
{"SampleId": 2783358, "Origin": "If this happens, a configuration {@link ConfigurationEvent event} will\nbe sent to all registered listeners.", "Reference": "If this happens, a CONFIGURATION {@link ConfigurationEvent event} will\nbe sent to all registered listeners.", "LLMCandidates": ["If this happens, a configuration {@link ConfigurationEvent event} will be sent to all registered listeners.", "If a configuration {@link ConfigurationEvent event} occurs, it will be sent to all registered listeners.", "If this happens, a configuration {@link ConfigurationEvent event} will be sent to all registered listeners.", "If this happens, a configuration {@link ConfigurationEvent event} will be sent to all registered listeners.", "If this happens, a configuration {@link ConfigurationEvent event} will be sent to all registered listeners."]}
{"SampleId": 4245592, "Origin": "Convert to primitive types, returning default value if text is null.", "Reference": "Convert to duration, returning default value if text is inconvertible.", "LLMCandidates": ["Convert to Duration type if text is not null, otherwise return default value.", "Convert to Duration with given default value if text is null. If an error occurs while converting, log a debug message and return the default value.", "Convert a given text into a Duration object using the default value if the text is not provided. If an error occurs while converting, it will log the error and return the default value.", "Convert the text value to Duration, returning defaultValue if an error occurs while converting.", "Convert a string representation of Duration, if present, otherwise return the default value."]}
{"SampleId": 4320983, "Origin": "Gets policy for resource set.", "Reference": "Delete policy for resource set.", "LLMCandidates": ["Deletes policy for resource set.", "Deletes policies for resource set.", "The method deletes policies for a resource set.", "The method deletes policies for a resource set.", "@DeleteMapping(value = '/' + OAuth20Constants.BASE_OAUTH20_URL + \"/{resourceId}/\" + OAuth20Constants.UMA_POLICY_URL + \"/{policyId}\", consumes = MediaType.APPLICATION_JSON_VALUE, produces = MediaType.APPLICATION_JSON_VALUE) public ResponseEntity deletePoliciesForResourceSet(@PathVariable(value = \"resourceId\") final long resourceId, @PathVariable(value = \"policyId\") final long policyId, final HttpServletRequest request, final HttpServletResponse response)}\nDeletes policies for a given resource set."]}
{"SampleId": 3506149, "Origin": "The alias is a boolean value located\nunder the {@link #ENABLED} key.", "Reference": "The alias is a boolean value located\nunder the {@link HasEnableUtil#ENABLED} key.", "LLMCandidates": ["The alias is a boolean value located under the {@link #HasEnableUtil.ENABLED} key.", "The alias is a boolean value located under the {@link #HasEnableUtil.ENABLED} key.", "The alias is a boolean value located under the {@link HasEnableUtil#ENABLED} key.", "The alias is a boolean value located under the {@link #HasEnableUtil.ENABLED} key.", "The alias is a boolean value located under the {@link #HasEnableUtil.ENABLED} key."]}
{"SampleId": 337258, "Origin": "Returns the {@link CaptureRequestConfiguration} for the {@link CaptureStage} object.", "Reference": "Returns the {@link CaptureRequestConfig} for the {@link CaptureStage} object.", "LLMCandidates": ["Returns the {@link CaptureRequestConfig} for the {@link CaptureStage} object.", "Returns the {@link CaptureRequestConfig} for the {@link CaptureStage} object.", "Returns the {@link CaptureRequestConfig} for the {@link CaptureStage} object.", "Returns the {@link CaptureRequestConfig} for the {@link CaptureStage} object.", "Returns the {@link CaptureRequestConfig} for the {@link CaptureStage} object."]}
{"SampleId": 4781139, "Origin": "Simple names for a given type.", "Reference": "Return the descriptor class for a given type.", "LLMCandidates": ["Extracts the fully qualified names for a given type using BindableDescriptorUtils.", "Retrieves a simple name for a given type element, converting it to the descriptor class name using BindableDescriptorUtils.", "Extracts the descriptor class name for a given type using BindableDescriptorUtils and elementUtils.", "Extracts the descriptor class name for a given type using BindableDescriptorUtils and elementUtils.", "Retrieves the fully qualified class name of a given type using BindableDescriptorUtils."]}
{"SampleId": 4470234, "Origin": "Get the preventEncryptionScopeOverride property: Optional.", "Reference": "Get the encryptionScopeOverridePrevented property: Optional.", "LLMCandidates": ["Get the encryptionScopeOverridePrevented property: Optional.", "Get the encryptionScopeOverridePrevented property: Optional", "Get the encryptionScopeOverridePrevented property: Optional", "Get the encryptionScopeOverridePrevented property: Optional.", "Get the encryptionScopeOverridePrevented property: Optional."]}
{"SampleId": 4986646, "Origin": "Get the FCPClient if it exists.", "Reference": "Get the PersistentRequestClient if it exists.", "LLMCandidates": ["Get the PersistentRequestClient if it exists.", "Get the PersistentRequestClient if it exists.", "Get the PersistentRequestClient if it exists.", "Get the PersistentRequestClient if it exists.", "Get the PersistentRequestClient if it exists."]}
{"SampleId": 4891063, "Origin": "Set the connection, this is usually called by subclasses when the channel is added to the pipeline.", "Reference": "Set the connection, this is called when the channel is added to the pipeline.", "LLMCandidates": ["Set the connection, this is usually called by subclasses when the channel is added to the pipeline.", "Set the connection, this is usually called by subclasses when the channel is added to the pipeline.", "Set the connection, this is usually called by subclasses when the channel is added to the pipeline.", "Set the connection, this is usually called by subclasses when the channel is added to the pipeline.", "Set the connection, this is usually called by subclasses when the channel is added to the pipeline."]}
{"SampleId": 4807132, "Origin": "Get the classloader and module finder.", "Reference": "Get the callstack.", "LLMCandidates": ["Get the call stack from the class loader finder.", "Get the call stack from class loader finder.", "Get the call stack from class loader finder.", "Get the call stack.", "Get the call stack."]}
{"SampleId": 1730901, "Origin": "Validation type is responsible for whether entity bean validation will be applied on {@link DataManager} level.", "Reference": "Validation mode affects whether entity bean validation will be applied on {@link DataManager} level.", "LLMCandidates": ["Validation mode is responsible for whether entity bean validation will be applied on {@link DataManager} level.", "Validation mode is responsible for whether entity bean validation will be applied on {@link DataManager} level.", "Validation mode is responsible for whether entity bean validation will be applied on {@link DataManager} level.", "Validation mode is responsible for whether entity bean validation will be applied on {@link DataManager} level.", "Validation mode is responsible for whether entity bean validation will be applied on {@link DataManager} level."]}
{"SampleId": 1042205, "Origin": "Delete persisted {@link WorkUnit}s upon job completion.", "Reference": "Delete persisted {@link WorkUnit}s and {@link JobState} upon job completion.", "LLMCandidates": ["Delete persisted WorkUnit records upon job completion.", "Cleanup working directory after job completion.", "Clean up working directory after job completion by deleting persisted work units and job state file.", "Clean up working directory after job completion by deleting persisted work units and job state file.", "Cleanup working directory after job completion, including deleting persisted WorkUnit and job state file."]}
{"SampleId": 4797744, "Origin": "A return value of {@code -1} necessarily\nindicate that the map contains no mapping for the key.", "Reference": "A return value of {@code #FREE} necessarily\nindicate that the map contains no mapping for the key.", "LLMCandidates": ["A return value of {@code FREE} necessarily indicate that the map contains no mapping for the key.", "A return value of {@code FREE} necessarily indicate that the map contains no mapping for the key.", "A return value of {@code FREE} necessarily indicate that the map contains no mapping for the key.", "A return value of {@code FREE} necessarily indicates that the map contains no mapping for the key.", "A return value of {@code FREE} indicates that the map contains no mapping for the key."]}
{"SampleId": 4473555, "Origin": "Create Subject Alternative names with dns names.", "Reference": "Set the dns names.", "LLMCandidates": ["Set Subject Alternative names with dns names.", "Set Subject Alternative names with dns names.", "Set Subject Alternative names with dns names.", "Set Subject Alternative names with dns names.", "Set Subject Alternative names with dns names."]}
{"SampleId": 3758708, "Origin": "So when we got block and all is ok - call this method.", "Reference": "So when we got packet and all is ok - call this method.", "LLMCandidates": ["Send an ACK packet to the specified session reader.", "Sends an acknowledgement for a specific block to a remote node by creating and sending a Packet object containing the block ID.", "Send an acknowledgement (ACK) packet for a specific block to a remote node using a provided sessionReader object and packetId. The ACK packet is encrypted with the given sessionKey before sending it.", "Send an acknowledgement packet to the specified session reader with the given packet ID. This method reports the action using a specific log label and sends the packet encrypted by the session key.", "Sends an ACK message for a specified packetId."]}
{"SampleId": 431798, "Origin": "Creates execution sequence for pending task groups by interleaving their unique occurrences.", "Reference": "Creates execution sequence for pending task groups by interleaving batches of requested size of\ntheir occurrences.", "LLMCandidates": ["Creates execution sequence for pending task groups by interleaving their unique occurrences, considering a specific batch size for each iteration.", "Creates execution sequence for pending task groups by interleaving their unique occurrences, considering a given batch size to limit the number of elements processed at once.", "Creates execution sequence for pending task groups by interleaving their unique occurrences, with a specified batch size to process at each iteration.", "Creates execution sequence for pending task groups by interleaving their occurrences, with the option to process a specific batch size at a time.", "Creates execution sequence for pending task groups by interleaving their unique occurrences, while considering a batchSize parameter to limit the number of items added in each iteration."]}
{"SampleId": 3990800, "Origin": "Wait for this task to meet the expected number of records as defined by {@code\nexpectedRecords}.", "Reference": "Wait up to the specified timeout for this task to meet the expected number of records as\ndefined by {@code expectedRecords}.", "LLMCandidates": ["Wait for this task to meet the expected number of records as defined by {@code\nexpectedRecords} using a timeout specified by {@code timeout} in the {@link TimeUnit}.", "Wait for this task to meet the expected number of records as defined by expectedRecords.", "Wait for this task to meet the expected number of records as defined by {@code expectedRecords}, using the specified timeout and time unit.", "Wait for this task to meet the expected number of records as defined by {@code expectedRecords} using a specified timeout and TimeUnit.", "Wait for this task to meet the expected number of records as defined by {@code expectedRecords} within the given time frame using a specified {@code TimeUnit}."]}
{"SampleId": 5441293, "Origin": "Therefore this is very convinient place to register\nscaler with Disposer as well as trigger deregistring bad font\nin case when scaler reports this.", "Reference": "Therefore this is very convinient place to register\nscaler with Disposer as well as trigger deregistering a bad font\nwhen the scaler reports this.", "LLMCandidates": ["This is a convenient place to register scaler with Disposer and trigger deregistering bad font in case when scaler reports this.", "This is a convenient place to register scaler with Disposer as well as trigger deregistering bad font in case when scaler reports this.", "This is a convenient place to register scaler with Disposer and deregister bad font if necessary.", "This method returns a FontScaler instance based on the given parameters. If an error occurs during instantiation, the scaler is set to null and the bad font is deregistered in the FontManager. This ensures proper handling of any exceptions while maintaining the integrity of the overall system.", "This is a convenient place to register scaler with Disposer, as well as deregister a bad font if the scaler reports this issue."]}
{"SampleId": 5003417, "Origin": "gets all tv show episodes from database", "Reference": "SYNCHRONOUSLY gets all tv show episodes from database", "LLMCandidates": ["Retrieves all TV show episodes from the database", "gets all tv show episodes from database", "gets all tv show episodes from database", "Retrieves all episodes from TV shows database", "Retrieves all episodes from TV shows database"]}
{"SampleId": 2913765, "Origin": "Obtains an instance from the specified unique name.", "Reference": "Obtains an instance from the specified name.", "LLMCandidates": ["Obtains an instance from the specified unique name by parsing it from a predefined list of names.", "Obtains an instance from the specified name.", "Obtains an instance from the specified name.", "Obtains an instance from the specified name.", "Obtains an instance from the specified name."]}
{"SampleId": 3358024, "Origin": "Value of the code encoded.", "Reference": "Value of the errorCode encoded.", "LLMCandidates": ["Error code value retrieval.", "Value of the error code encoded.", "Updated Javadoc comment: errorCodeValue of the code encoded.", "Updated Javadoc comment: errorCodeValue of the code encoded.", "Value of the error code encoded."]}
{"SampleId": 1346741, "Origin": "Closes the session.", "Reference": "Updates the session state.", "LLMCandidates": ["Sets the session state based on the given value and triggers notifications to listeners.", "Sets the session state based on the provided value.", "Sets the session state based on the provided value.", "Set the state of the session to the specified value.", "Set the state of the session to the specified value."]}
{"SampleId": 5724390, "Origin": "This function implements a subset of quoted-printable encoding specification (rule REF and rule REF) as defined in\nRFC 1521.", "Reference": "This function fully implements the quoted-printable encoding specification (rule REF through rule REF) as\ndefined in RFC 1521.", "LLMCandidates": ["This function implements a subset of quoted-printable encoding specification (rule REF and rule REF) as defined in RFC 1521.", "This function implements a subset of quoted-printable encoding specification (rule REF and rule REF) as defined in RFC 1521.", "This function implements a subset of quoted-printable encoding specification (rule REF and rule REF) as defined in RFC 1521. This method is now marked as @Override to indicate it overrides the method from its superclass.", "This function implements a subset of quoted-printable encoding specification (rule REF and rule REF) as defined in RFC 1521. Note: This method has been marked as @Override, indicating it overrides the method from its superclass.", "This function implements a subset of quoted-printable encoding specification (rule REF and rule REF) as defined in RFC 1521."]}
{"SampleId": 6130393, "Origin": "Method to get the configuration knowning the set", "Reference": "Method to get the first configuration knowning the set", "LLMCandidates": ["Method to get the configuration knowning the set using a default value of 0", "Method to get the configuration knowning the set with an additional parameter 0", "Method to get the configuration knowning the set with an additional parameter 0", "Get the configuration knowning the set and a default index of 0.", "Get the configuration knowning the set and an additional parameter, 0"]}
{"SampleId": 4617953, "Origin": "Binds the HTTP connection.", "Reference": "Assigns an external property.", "LLMCandidates": ["Set the property by putting key and value.", "Set the property with key \"http\" and value \"value\".", "Set the property with key \"http\" and value \"value\".", "Sets a property with the given key and value.", "Sets a property with the given key and value."]}
{"SampleId": 5324303, "Origin": "Note that the writing process does not start until the returned {@code Mono} is subscribed\nto.", "Reference": "Note that the writing process does not start until the returned {@code Flux} is subscribed\nto.", "LLMCandidates": ["The writing process starts when the returned {@code Flux} is subscribed to.", "The writing process starts when the returned {@code Flux} is subscribed to.", "Note that the writing process does not start until the returned {@code Flux} is subscribed to.", "The writing process starts when the returned {@code Flux} is subscribed to.", "The writing process starts as soon as the returned Flux is subscribed to."]}
{"SampleId": 3037775, "Origin": "Tests resilency when D2 device availability is changed.", "Reference": "Tests resiliency when D2 device availability is changed.", "LLMCandidates": ["Tests resilency when D2 device availability is changed, but now path cost is checked instead of path weight.", "Tests resilency when D2 device connectivity is changed due to topology modifications.", "Tests resilency when D2 device availability is changed, considering the changes in topology and link removal.", "Tests resilency when D2 device availability is changed, path weight is calculated using 180, and link removal events trigger topology changes.", "Tests resilency when D2 device availability is changed. Topology change occurs by removing device2 , link1 and link2; verifies path weight."]}
{"SampleId": 2443922, "Origin": "Start building a new factory class-based service binding.", "Reference": "Start building a new supplier class-based service binding.", "LLMCandidates": ["Start building a new supplier class-based service binding.", "Start building a new supplier class-based service binding.", "Start building a new supplier class-based service binding.", "Build a new factory class-based service binding using the specified supplier type.", "Build a new factory class-based service binding using the specified supplier type."]}
{"SampleId": 1314730, "Origin": "Creates an exception from an service name.", "Reference": "Creates an exception from an API name.", "LLMCandidates": ["Creates an exception from an API name.", "Creates an exception from an API name.", "Creates an exception from an API name.", "Creates an exception from an API name.", "Creates an exception from an API name."]}
{"SampleId": 2913760, "Origin": "Obtains an instance from the specified unique name.", "Reference": "Obtains an instance from the specified name.", "LLMCandidates": ["Obtains an instance from the specified unique name using a predefined set of names.", "Obtains an instance from the specified unique name.", "Obtains an instance from the specified unique name.", "Obtains an instance from the specified name.", "Obtains an instance from the specified name."]}
{"SampleId": 5840707, "Origin": "Removes the source location value from this list of elements.", "Reference": "Removes the source location value from this map of elements.", "LLMCandidates": ["Removes the source location value from this list of elements.", "Removes source locations from all elements of the given list if they are present, without affecting other elements not contained in this list.", "Removes the source location value from the list of elements if the map is not null.", "Removes the source location value from the list of elements if the map is not null.", "Removes source locations from this list of elements."]}
{"SampleId": 3074824, "Origin": "Make you have enabled the NA check properly using\n{@link #enable(RAbstractVector, RAbstractVector)} before relying on this method.", "Reference": "Make sure you have enabled the NA check properly using\n{@link #enable(RAbstractVector, RAbstractVector)} before relying on this method.", "LLMCandidates": ["Make sure you have enabled the NA check properly using {@link #enable(RAbstractVector, RAbstractVector)} before relying on this method.", "Make sure you have enabled the NA check properly using {@link #enable(RAbstractVector, RAbstractVector)} before relying on this method.", "Make sure you have enabled the NA check properly using {@link #enable(RAbstractVector, RAbstractVector)} before relying on this method.", "Make sure that you have enabled the NA check correctly by using {@link #enable(RAbstractVector, RAbstractVector)} before relying on this method.", "Make sure you have enabled the NA check properly using {@link #enable(RAbstractVector, RAbstractVector)} before relying on this method."]}
{"SampleId": 4124110, "Origin": "Make sure to\n{@link #releaseParser(SAXParser)} in\na  block every time you call this.", "Reference": "Make sure to\n{@link #releaseParser(PoolSAXParser)} in\na  block every time you call this.", "LLMCandidates": ["Make sure to {@link #releaseParser(PoolSAXParser)} in a block every time you call this.", "Make sure to {@link #releaseParser(PoolSAXParser)} in a block every time you call this.", "Make sure to {@link #releaseParser(PoolSAXParser)} in a block every time you call this.", "Make sure to {@link #releaseParser(PoolSAXParser)} in a block every time you call this.", "Make sure to {@link #releaseParser(PoolSAXParser)} in a block every time you call this."]}
{"SampleId": 2603540, "Origin": "Send a non-mutation message to a given endpoint.", "Reference": "Send a non-mutation message to a given node.", "LLMCandidates": ["Send a non-mutation message to a given node.", "Send a non-mutation message to a given NetNode.", "Send a non-mutation message to a given NetNode.", "Send a non-mutation message to a given NetNode.", "Send a non-mutation message to a given NetNode."]}
{"SampleId": 1753706, "Origin": "Whether this codec is capable of encoding the given Java type.", "Reference": "Whether this codec is capable of processing the given Java type.", "LLMCandidates": ["Whether this codec is capable of accepting the given Java type.", "Whether this codec is capable of accepting the given Java type.", "Whether this codec is capable of handling the given Java type.", "Whether this codec is capable of handling the given Java type.", "Determine if this codec is compatible with the given Java type."]}
{"SampleId": 2603544, "Origin": "unlike excise we just need this endpoint gone without going through any notifications *", "Reference": "unlike excise we just need this node gone without going through any notifications *", "LLMCandidates": ["Removes a node from both Gossiper and ClusterMetaData by providing the specified NetNode instance.", "Removes a specified node from Gossiper.instance and ClusterMetaData by calling their respective remove methods. No notifications are needed for this operation.", "remove a node from Gossiper.instance and ClusterMetaData without notifications.", "remove a node from Gossiper.instance and ClusterMetaData without notifications.", "Removes the specified node from Gossiper.instance and ClusterMetaData without going through any notifications."]}
{"SampleId": 2017647, "Origin": "When a class B inherits from A and A is annotated as a struct, then B automatically gets the\nannotation, even if B's constructor is not explicitly annotated.", "Reference": "When a class B inherits from A and A is annotated as a struct, then B automatically gets the\nannotation, if B's constructor is not explicitly annotated.", "LLMCandidates": ["When a class B inherits from A and A is annotated as a struct, then B automatically gets the annotation, even if B's constructor is not explicitly annotated. However, for anything EXPLICITLY marked as @unresticted do not look to the super type.", "When a class B inherits from A and A is annotated as a struct, then B automatically gets the annotation, even if B's constructor is not explicitly annotated. However, if B is explicitly marked with @unresticted, it will not look to the super type for its struct annotation.", "When a class B inherits from A and A is annotated as a struct, then B automatically gets the annotation, even if B's constructor is not explicitly annotated. However, if B has been EXPLICITLY marked as @unresticted, it will not look to its super type for determining if it should be considered a struct.", "When a class B inherits from A and A is annotated as a struct or if B is explicitly marked as @unresticted do not look to the super type, then B automatically gets the annotation, even if B's constructor is not explicitly annotated.", "When a class B inherits from A and A is annotated as a struct, then B automatically gets the annotation, even if B's constructor is not explicitly annotated. However, for anything EXPLICITLY marked as @unrestricted do not look to the super type."]}
{"SampleId": 4396425, "Origin": "Returns a string representation of this object; useful for testing and debugging.", "Reference": "Returns a string representation of this object.", "LLMCandidates": ["Returns a string representation of this object; useful for testing and debugging; sensitive data is redacted with ***Sensitive Data Redacted*** placeholder.", "Returns a string representation of this object; useful for testing and debugging, with sensitive data redacted where necessary.", "Returns a string representation of this object; useful for testing and debugging. The sensitive AuthorizationResult data is redacted with ***Sensitive Data Redacted*** in the toString output.", "Returns a string representation of this object; useful for testing and debugging. If the AuthorizationResult is not null, it will be displayed with the text \"AuthorizationResult\", followed by the redacted data \"***Sensitive Data Redacted***\" and a comma. If SkillId is not null, it will also be displayed with the text \"SkillId\", followed by the value and a comma. Finally, if RoomArn is not null, it will be displayed with the text \"RoomArn\", followed by its value. The result is enclosed in curly braces { } and separated by commas.", "Returns a string representation of this object; useful for testing and debugging. If sensitive data is present, it will be redacted with \"***Sensitive Data Redacted***\"."]}
{"SampleId": 1406605, "Origin": "Overrides previous instances of the exact\nsame subclass of FragmentOptions.", "Reference": "Overrides previous instances of the exact same subclass of {@code FragmentOptions}.", "LLMCandidates": ["Overrides previous instances of the exact subclass of FragmentOptions, but with an additional step of normalizing options.", "Overrides previous instances of the exact subclass of FragmentOptions by passing the normalized options.", "Overrides previous instances of the exact subclass of FragmentOptions by adding its normalized version to the list.", "Overrides previous instances of the exact same subclass of FragmentOptions by using its normalized version instead.", "Overrides previous instances of the exact subclass of FragmentOptions, using the normalized options."]}
{"SampleId": 4386708, "Origin": "List Multipart Uploads response, even if idempotent complete is\npossible.", "Reference": "Uploads response, even if idempotent complete is possible.", "LLMCandidates": ["Completed a Multipart Upload Request for Amazon S3. This method is responsible for completing a multipart upload request in Amazon Simple Storage Service (S3). It creates an ExecutionContext and AWSRequestMetrics, starts the ClientExecuteTime event, and marshalls the request using CompleteMultipartUploadRequestMarshaller before invoking it with a JsonResponseHandler. The response is then unmarshalled using a specific JsonUnmarshaller to return the result.", "List Multipart Uploads response even if idempotent complete is possible.", "This method is used to complete a multipart upload request, starting the client execution time event and setting up the AWSRequestMetrics for monitoring. It marshalls the given CompleteMultipartUploadRequest into an appropriate Request object, invoking the API call with a JsonResponseHandler. Upon receiving the response, it returns the AwsResponse contained within. The method also takes care of ending the client execution by binding the AWS request metrics to the request and the response.", "Completes a multipart upload operation, returning a response that contains information about the completed upload.", "List Multipart Uploads result even if idempotent complete is possible."]}
{"SampleId": 3710575, "Origin": "Load a {@link android.graphics.drawable.Drawable} asynchronously", "Reference": "Load a {@link android.graphics.drawable.Drawable} asynchronously (convenience method)", "LLMCandidates": ["Load a {@link android.graphics.drawable.Drawable} asynchronously into an ImageView with the specified drawable resource id and optionally set error image.", "Load a Drawable asynchronously with optional error handling", "Load a Drawable asynchronously with optional error handling", "Load a {@link android.graphics.drawable.Drawable} asynchronously with an option to enable or disable error handling.", "Load a {@link android.graphics.drawable.Drawable} asynchronously with customizable error image option"]}
{"SampleId": 2700191, "Origin": "Set UPC/EAN.", "Reference": "Set TU-UPC.", "LLMCandidates": ["Set UPC/TU.", "Set UPC/EAN code identifier.", "Set UPC/EAN_TU.", "Set UPC/EAN_TU.", "Set UPC/EAN_TU."]}
{"SampleId": 2680294, "Origin": "Returns the opening {@link Month} within this set of bounds.", "Reference": "Returns the openAt {@link Month} within this set of bounds.", "LLMCandidates": ["Returns the opening {@link Month} within this set of bounds.", "Returns the opening {@link Month} at a specified point within this set of bounds.", "Returns the opening {@link Month} at a specified point within this set of bounds.", "Returns the opening {@link Month} within this set of bounds.", "Returns the opening {@link Month} within this set of bounds."]}
{"SampleId": 2272830, "Origin": "The KeyStore type (jks, jceks, pkcs12, etc) for the identity and trust store for connections created by this\nlistener.", "Reference": "The KeyStore type (jks, jceks, pkcs12, etc) for the identity and trust store for connections of a particular type.", "LLMCandidates": ["The KeyStore type (jks, jceks, pkcs12, etc) for the identity and trust store for connections created by this listener. This method is deprecated.", "The KeyStore type (jks, jceks, pkcs12, etc) for the identity and trust store for connections created by this deprecated listener.", "The KeyStore type for connections created by this listener.", "The KeyStore type (jks, jceks, pkcs12, etc) for the identity and trust store for connections created by this listener. This method is deprecated now.", "The KeyStore type (jks, jceks, pkcs12, etc) for the identity and trust store for connections created by this deprecated listener."]}
{"SampleId": 3678449, "Origin": "Returns a copy of this date-time with the zone ID locked to the offset.", "Reference": "Returns a copy of this date-time with the zone ID set to the offset.", "LLMCandidates": ["Returns a copy of this date-time with the zone ID locked to the offset.", "Returns a copy of this date-time with the zone ID fixed to the offset.", "Returns a copy of this date-time with the zone ID fixed to the offset.", "Returns a copy of this date-time with the zone ID fixed to the offset.", "Returns a copy of this date-time with the zone ID fixed to the offset."]}
{"SampleId": 1310050, "Origin": "Generates a valid document ID for a service, used to index the service in ES.", "Reference": "Generates a valid document ID for a api, used to index the api in ES.", "LLMCandidates": ["Generates a valid document ID for an API, used to index the API in ES.", "Generates a valid document ID for an API, used to index the API in ES.", "Generates a valid document ID for an API, used to index the API in ES.", "Generates a valid document ID for an API, used to index the API in ES.", "Generates a valid document ID for an API, used to index the API in ES."]}
{"SampleId": 5447042, "Origin": "If the range of the variable has not been set yet, it will be set to be\nval id from the start to the end of the instruction list.", "Reference": "If the range of the variable has not been set yet, it will be set to be\nvalid from the start to the end of the instruction list.", "LLMCandidates": ["Returns an array of LocalVariableGen objects representing the local variables or types used in the instruction list. If the range of a variable has not been set yet, it will be set to the start and end of the instruction list.", "The comment is empty as the new method does not seem to need any specific Javadoc comment.", "Returns an array of LocalVariableGen objects representing local variables or types based on the given input", "Returns an array of LocalVariableGen objects representing local variables or types based on the given input", "Returns an array of LocalVariableGen objects representing the local variables or type names found within the given code."]}
{"SampleId": 6247256, "Origin": "Deletes the elements in the mValues list and notifies the Adapter", "Reference": "Deletes the elements in the values list and notifies the Adapter", "LLMCandidates": ["Deletes the elements in the values list and notifies the Adapter", "Deletes the elements in the values list and notifies the Adapter", "Deletes the elements in the values list and notifies the Adapter", "Deletes the elements in the values list and notifies the Adapter", "Deletes the elements in the values list and notifies the Adapter"]}
{"SampleId": 2382765, "Origin": "The version of this Titan graph database", "Reference": "The version of this JanusGraph graph database", "LLMCandidates": ["The version of this JanusGraph graph database", "The version of this JanusGraph graph database", "The version of this JanusGraph graph database", "The version of this JanusGraph database", "The version of this JanusGraph database"]}
{"SampleId": 4386726, "Origin": "Uploading Large Archives in Parts (Multipart Upload)  and  Upload Part \nin the Amazon Glacier Developer Guide .", "Reference": "For conceptual information and underlying REST API, go to Uploading Large Archives in Parts (Multipart Upload) and Upload Part  in the Amazon Glacier Developer Guide.", "LLMCandidates": ["Uploading Large Archives in Parts (Multipart Upload)  and  Upload Part in the Amazon Glacier Developer Guide.", "Uploading Large Archives in Parts (Multipart Upload)  and  Upload Part  in the Amazon Glacier Developer Guide .", "Uploads a multipart archive in Amazon Glacier using multipart upload and part upload operations.", "Uploading Multipart Uploads and Upload Part in the Amazon Glacier Developer Guide", "Uploading Large Archives in Parts (Multipart Upload) and Upload Part in the Amazon Glacier Developer Guide."]}
{"SampleId": 3772938, "Origin": "Creates a column instance from a value provider and a renderer.", "Reference": "Creates a column instance from a value provider, presentation provider\nand a renderer.", "LLMCandidates": ["Creates a column instance from a value provider, a presentation provider, and a renderer.", "Creates a column instance from a value provider, a presentation provider, and a renderer.", "Creates a column instance from a value provider, a presentation provider, and a renderer.", "Creates a column instance from a value provider, a presentation provider, and a renderer.", "Creates a column instance from a value provider, a presentation provider, and a renderer."]}
{"SampleId": 2912413, "Origin": "This maps either the security ID or the legal entity ID to a group.", "Reference": "This maps the legal entity ID to a group.", "LLMCandidates": ["This maps either the security ID or the legal entity ID to a group.", "This maps either the security ID or the legal entity ID to a group.", "This maps either the security ID or the legal entity ID to a group.", "This maps either the security ID or the legal entity ID to a group.", "This maps either the security ID or the legal entity ID to a group."]}
{"SampleId": 367453, "Origin": "Returns the singleton instance of the {@link SliceBackgroundWorker} for specified {@link Uri}\nif exists", "Reference": "Returns the singleton instance of {@link SliceBackgroundWorker} for specified {@link Uri} if\nexists", "LLMCandidates": ["Returns the singleton instance of the {@link SliceBackgroundWorker} for specified {@link Uri} if exists, but also added a @SuppressWarnings annotation to suppress a type parameter unused in formals warning.", "Returns the singleton instance of the {@link SliceBackgroundWorker} for specified {@link Uri} if exists.", "Returns the singleton instance of the {@link SliceBackgroundWorker} for specified {@link Uri} if exists with a type parameter <T extends SliceBackgroundWorker>.", "Returns the singleton instance of the {@link SliceBackgroundWorker} for specified {@link Uri} if exists. The type of the instance is now generic ({@code <T extends SliceBackgroundWorker>}).", "Returns the singleton instance of {@code T extends SliceBackgroundWorker}} for specified {@link Uri} if exists"]}
{"SampleId": 2783671, "Origin": "A {@link FileTransferException} if the operation was attempted but failed for any of the following reasons:", "Reference": "This method throws an {@link IOException} if the operation failed, for any of the following reasons:", "LLMCandidates": ["A {@link FileTransferException} if the operation was attempted but failed for any of the following reasons:", "Moves the file to a new location by renaming it if supported, or copies the file and deletes the source after copying. Throws an IOException if there is an error during the operation. This method is useful for moving a file while retaining its contents.", "This method attempts to rename the source file to the destination file's name if the operation is supported; if not, it falls back to copying the file to the destination and then deleting the original. Throws an IOException if any step fails.", "A {@link FileTransferException} if the operation was attempted but failed for any of the following reasons:", "Throws a {@link FileTransferException} if the operation was attempted but failed for any of the following reasons:"]}
{"SampleId": 3366327, "Origin": "Sets the schema version to the given {@link SharedRealm}.", "Reference": "Sets the schema version to the given {@link OsSharedRealm}.", "LLMCandidates": ["Sets the schema version to the given {@link OsSharedRealm}.", "Sets the schema version to the given {@link OsSharedRealm}.", "Sets the schema version to the given {@link OsSharedRealm}.", "Sets the schema version to the given {@link OsSharedRealm}.", "Sets the schema version to the given {@link OsSharedRealm}."]}
{"SampleId": 5243388, "Origin": "Compare two groups based on the grouping attribute.", "Reference": "Compare two groups based on the group key", "LLMCandidates": ["Compare two groups based on their group keys.", "Compare two groups based on their group keys.", "Compare two groups based on their group keys.", "Compare two groups based on their group keys.", "Compare two groups based on their group keys."]}
{"SampleId": 2526359, "Origin": "Adds a handle to the constant pool of the class being built.", "Reference": "Adds a method handle to the constant pool of the class being built.", "LLMCandidates": ["Adds a handle to the constant pool of the class being built.", "Adds a handle to the constant pool of the class being built by using a method handle instead of a regular handle item.", "Adds a MethodHandleItem to the constant pool of the class being built.", "Adds a MethodHandleItem to the constant pool of the class being built.", "Adds a MethodHandleItem to the constant pool of the class being built."]}
{"SampleId": 2443738, "Origin": "Bind contract provider model to a provider class using the supplied instance manager.", "Reference": "Bind contract provider model to a provider class using the supplied injection manager.", "LLMCandidates": ["Bind contract provider model to a provider class using the supplied injection manager.", "Bind contract provider model to a provider class using the supplied injection manager.", "Bind contract provider model to a provider class using the supplied injection manager.", "Bind contract provider model to a provider class using the supplied injection manager.", "Bind contract provider model to a provider class using the supplied injection manager."]}
{"SampleId": 2848845, "Origin": "The manifest produced by this service do not include checksum for each entry.", "Reference": "The manifest produced by this service do not include checksum for entries and caches manifests recently created.", "LLMCandidates": ["The manifest produced by this service does not include checksum for each entry, and it is annotated with @Bean and @ConditionalOnMissingBean(JobDirectoryManifestService.class).", "The manifest produced by this service does not include checksum for each entry.", "The manifest produced by this service do not include checksum for each entry. This service is now a Bean and returns a manifest without checksums when called with a jobDirectoryPath.", "The manifest produced by this service do not include checksum for each entry when using the default configuration.", "The manifest produced by this service do not include checksum for each entry."]}
{"SampleId": 4780345, "Origin": "Returns all documents contained in this cluster.", "Reference": "Returns all documents contained in this cluster or an empty list if none.", "LLMCandidates": ["Returns all documents contained in this cluster, or an empty list if none are present.", "Returns all documents contained in this cluster, or an empty list if none are present.", "Returns all documents contained in this cluster or an empty list if none found.", "Returns all documents contained in this cluster or an empty list if none found.", "Returns a list of all documents contained in this cluster."]}
{"SampleId": 1067852, "Origin": "Return the {@code StreamManager} in a context, or the global one if the context is\nnull or does not contain an entry for a {@code StreamManager}.", "Reference": "Return the {@code StreamManager} in a context, or the global one if the context is\nnull or does not contain a valid entry for a {@code StreamManager}.", "LLMCandidates": ["Return the {@code StreamManager} in a context, or the global one if the context is null or does not contain an entry for a {@code StreamManager}.", "Return the StreamManager in a context, or the global one if the context is null or does not contain an entry for a StreamManager.", "Return the StreamManager in a context, or the global one if the context is null or does not contain an entry for a StreamManager, checking if the context has a defined entry for SysRIOT.sysStreamManager before attempting to cast it.", "Return the StreamManager in a context, or the global one if the context is null or does not contain an entry for a StreamManager.", "Return the StreamManager in a context, or the global one if the context is null or does not contain an entry for a StreamManager; use a defined symbol within the context to retrieve it."]}
{"SampleId": 2230476, "Origin": "Sets the quorum name for lock operations.", "Reference": "Sets the split brain protection name for lock operations.", "LLMCandidates": ["Sets the split brain protection name for lock operations.", "Sets the split brain protection name for lock operations.", "Sets the split brain protection name for lock operations.", "Sets the split brain protection name for lock operations.", "Sets the split brain protection name for lock operations."]}
{"SampleId": 1855232, "Origin": "[IF Sidecar19-SE]", "Reference": "[IF Java14]", "LLMCandidates": ["Deprecated(forRemoval=true, since=\"1.2\")", "This method is deprecated since version 1.2. It is not applicable to this VM and is a no-op. This feature is removed in Java 14 but remains deprecated in Java 11 and below.", "@Deprecated(forRemoval=true, since=\"1.2\") /*[ELSE] Java14 */ @Deprecated(forRemoval=false, since=\"1.2\") /*[ENDIF] Java14 */ /*[ELSE] Java11 */ @Deprecated /*[ENDIF] Java11 */ public boolean allowThreadSuspension(boolean b) { // Does not apply to this VM, no-op /*[PR 1PR4U1E]*/ return true;", "[IF Sidecar19-SE] Deprecated(forRemoval=true, since=\"1.2\") [ELSE] Java14 [Deprecated(forRemoval=false, since=\"1.2\") [ENDIF] Java14] [ELSE] Java11 [Deprecated] [ENDIF] Java11] public boolean allowThreadSuspension(boolean b) { // Does not apply to this VM, no-op /*[PR 1PR4U1E]*/ return true;", "@Deprecated(forRemoval=true, since=\"1.2\") [ELSE] Java14 @Deprecated(forRemoval=false, since=\"1.2\") [ENDIF] Java14 [ELSE] Java11 [END] Java11 public boolean allowThreadSuspension(boolean b) { // Does not apply to this VM, no-op /*[PR 1PR4U1E]*/ return true;"]}
{"SampleId": 1464613, "Origin": "Obtain a {@link RemoteRepository} for the data set having the specified\nSPARQL end point.", "Reference": "Obtain a flyweight {@link RemoteRepository} for the data set having the specified\nSPARQL end point.", "LLMCandidates": ["Obtain a {@link RemoteRepository} for the data set having the specified SPARQL end point.", "Obtain a {@link RemoteRepository} for the data set having the specified SPARQL end point URL.", "Obtain a {@link RemoteRepository} for the data set having the specified SPARQL end point from this class.", "Obtain a {@link RemoteRepository} for the data set having the specified SPARQL end point by passing this instance and sparqlEndpointURL.", "Obtain a {@link RemoteRepository} for the data set having the specified SPARQL end point using the given instance of the class."]}
{"SampleId": 6247260, "Origin": "Returns an AccountListItem from the specified position in the mValues list", "Reference": "Returns an AccountListItem from the specified position in the values list", "LLMCandidates": ["Returns an AccountListItem from the specified position in the values list", "Returns an AccountListItem from the specified position in the values list", "Returns an AccountListItem from the specified position in the values list", "Returns an AccountListItem from the specified position in the values list", "Returns an AccountListItem from the specified position in the values list"]}
{"SampleId": 340561, "Origin": "PlaybackParams2 to the given input.", "Reference": "PlaybackParams to the given input.", "LLMCandidates": ["Set playback parameters based on the given input.", "Set playback params to the given input.", "Set playback params to the given input.", "Set the initial value by adding 8 to n.", "Set the initial value by adding 8 to n."]}
{"SampleId": 5176607, "Origin": "Setter for {@link #allowCredentials}", "Reference": "Setter for {@link #allowedCredentials}", "LLMCandidates": ["Setter for {@link #allowedCredentials", "Setter for {@link #allowedCredentials", "Setter for {@link #allowedCredentials", "Setter for {@link #allowedCredentials", "Setter for #allowedCredentials"]}
{"SampleId": 5299668, "Origin": "Obtain the {@link MongoDatabase database} with given name form the given {@link MongoDbFactory factory}.", "Reference": "Obtain the {@link MongoDatabase database} with given name form the given {@link MongoDatabaseFactory factory}.", "LLMCandidates": ["Obtain the {@link MongoDatabase database} with given name from the given {@link MongoDatabaseFactory factory}.", "Obtain the {@link MongoDatabase database} with given name form the given {@link MongoDatabaseFactory factory}.", "Obtain the {@link MongoDatabase database} with given name from the given {@link MongoDatabaseFactory factory}.", "Obtain the {@link MongoDatabase database} with given name form the given {@link MongoDatabaseFactory factory}.", "Obtain the {@link MongoDatabase database} with given name form the given {@link MongoDatabaseFactory factory}."]}
{"SampleId": 4396605, "Origin": "Returns a string representation of this object; useful for testing and debugging.", "Reference": "Returns a string representation of this object.", "LLMCandidates": ["Returns a string representation of this object; useful for testing and debugging with sensitive data redacted.", "Returns a string representation of this object; useful for testing and debugging, with sensitive data redacted.", "Returns a string representation of this object; useful for testing and debugging, with sensitive data redacted.", "Returns a string representation of this object; useful for testing and debugging; sensitive data is redacted by displaying ***Sensitive Data Redacted*** where appropriate.", "Returns a string representation of this object; useful for testing and debugging."]}
{"SampleId": 4620051, "Origin": "Copies this expression's return type and size to the given expression.", "Reference": "Copies this expression's type to the specified expression.", "LLMCandidates": ["Copies this expression's return type to the given expression.", "Copies this expression's type information from the current expression to the given expression.", "Copies this expression's return type to the given expression's return type.", "Copies this expression's return type to the given expression's return type.", "Copies this expression's type information by assigning it from the current object to the given expression."]}
{"SampleId": 1578100, "Origin": "The returned {@link MetadataEntity} is of the same type.", "Reference": "The returned {@link MetadataEntity.Builder} is of the same type.", "LLMCandidates": ["The returned {@link Builder} is of the same type.", "The returned {@link Builder} is of the same type.", "The returned {@link Builder} is of the same type.", "The returned {@link Builder} allows for chaining additional operations.", "The returned {@link Builder} allows for chaining additional operations."]}
{"SampleId": 3629288, "Origin": "Returns an immutable map containing a single mapping.", "Reference": "Returns an unmodifiable map containing a single mapping.", "LLMCandidates": ["Returns an unmodifiable map containing a single mapping.", "Returns a map containing a single mapping from key k1 to value v1 that cannot be modified.", "Returns an unmodifiable map containing a single mapping.", "Returns an unmodifiable map containing a single mapping.", "Returns a map containing a single mapping which is unmodifiable."]}
{"SampleId": 4474528, "Origin": "Generates a code sample for using {@link ShareDirectoryClient#deleteSubDirectoryWithResponse(String, Duration,", "Reference": "Generates a code sample for using {@link ShareDirectoryClient#deleteSubdirectoryWithResponse(String, Duration,", "LLMCandidates": ["Generates a code sample for using {@link ShareDirectoryClient#deleteSubdirectoryWithResponse(String, Duration, Context)} to delete a subdirectory in the file share with response.", "Generates a code sample for using {@link ShareDirectoryClient#deleteSubdirectoryWithResponse(String, Duration,", "Generates a code sample for using {@link ShareDirectoryClient#deleteSubdirectoryWithResponse(String, Duration, Context)", "Generates a code sample for using {@link ShareDirectoryClient#deleteSubdirectoryWithResponse(String, Duration,", "Generates a code sample for using {@link ShareDirectoryClient#deleteSubdirectoryWithResponse(String, Duration,"]}
{"SampleId": 1611738, "Origin": "The expected indentation should be the same as the indentation of the node\nwhich is the parent of the target modifier node.", "Reference": "The expected indentation should be the same as the indentation of the target node.", "LLMCandidates": ["The expected indentation should be the same as the indentation of the node which is the parent of the target modifier node.", "The expected indentation should be the same as the indentation of the node which is the parent of the target node.", "Calculate the expected indentation by considering the column number of the given node.", "The expected indentation should be the same as the indentation of the node which is the parent of the target modifier node.", "The expected indentation should be the same as the node which is the parent of the target modifier node."]}
{"SampleId": 1356230, "Origin": "Check if the last item in key signature has some trailing space (before any head).", "Reference": "Check if last item in key signature has some trailing space (before any head).", "LLMCandidates": ["Check if the last item in key signature has some trailing space (before any head).", "Checks if the last element of the key signature has any trailing space before any head.", "Check if the last item in key signature has some trailing space before any head.", "Check if the last item in key signature has some trailing space before any head.", "Check if the last item in key signature has some trailing space (before any head)."]}
{"SampleId": 1405621, "Origin": "Marks the action as analyzing.", "Reference": "Marks the action as scanning.", "LLMCandidates": ["Marks the action as scanning.", "Marks the action as scanning.", "Marks the action as scanning.", "Marks the action as scanning.", "Marks the action as scanning."]}
{"SampleId": 4396654, "Origin": "Returns a string representation of this object; useful for testing and debugging.", "Reference": "Returns a string representation of this object.", "LLMCandidates": ["Returns a string representation of this object; useful for testing and debugging, with sensitive data redacted.", "Returns a string representation of this object, useful for testing and debugging; sensitive data is redacted.", "Returns a string representation of this object; useful for testing and debugging, but hides sensitive data (Output: ***Sensitive Data Redacted*** )", "Returns a string representation of this object; useful for testing and debugging, where sensitive data is redacted.", "Returns a string representation of this object; useful for testing and debugging; handles sensitive data by redacting Output."]}
{"SampleId": 2527768, "Origin": "Get or create a storage block by the name.", "Reference": "Gets or creates a buffer block by the name.", "LLMCandidates": ["Get or create a buffer block by the name.", "Get or create a buffer block by the name.", "Get or create a buffer block by the name.", "Get or create a buffer block by the name.", "Get or create a buffer block by the name."]}
{"SampleId": 1760055, "Origin": "Calculates Minimum - Nulls are handled as zeros.", "Reference": "Calculates Minimum - Nulls are ignored.", "LLMCandidates": ["Calculates Minimum - Nulls are handled as zeros by checking if v is not null and comparing it to the current minimum value min.", "Calculates Minimum - Nulls are treated as zeros.", "Calculates Minimum - Nulls are treated as zeros.", "Calculates Minimum - Nulls are handled by treating them as zeros during comparison and calculation.", "Calculates Minimum - Nulls are handled as zeros, with an additional check for null values before updating the minimum value."]}
{"SampleId": 6043566, "Origin": "and repositoryId = ?.", "Reference": "and parentFolderId = ?.", "LLMCandidates": ["Finds SyncDLObjects by repositoryId and parentFolderId.", "Find all SyncDLObjects where repositoryId is equal to ? and parentFolderId is also equal to ?.", "Finds SyncDLObjects where repositoryId = ? and parentFolderId = ?.", "Find SyncDLObjects by repositoryId = ? and parentFolderId=?", "Find SyncDLObjects by repositoryId = ? and parentFolderId=?"]}
{"SampleId": 2217819, "Origin": "Test of var method, of class Exponential.", "Reference": "Test of variance method, of class Exponential.", "LLMCandidates": ["Test of variance method, of class ExponentialDistribution.", "Test of variance method, of class ExponentialDistribution.", "Test of variance method, of class Exponential.", "Test of variance method, of class Exponential.", "Test of variance method, of class ExponentialDistribution."]}
{"SampleId": 4003565, "Origin": "If you want to extend a value (e.g.", "Reference": "If you like to extend an option (e.g.", "LLMCandidates": ["The purpose of this method is to set a value in a configuration file using a ConfigurationPointer and a String value.", "Set the value by adding 8 to n.", "Set the value by adding 8 to n.", "Set the value by adding 8 to n.", "Edit a configuration file's value at a specified path using this option."]}
{"SampleId": 1841602, "Origin": "Returns the ssh configuration entry which includes host and identity file location", "Reference": "Returns the ssh configuration entry which includes host, identity file location and Host Key\nchecking policy", "LLMCandidates": ["Returns the ssh configuration entry which includes host, identity file location and StrictHostKeyChecking is set to no.", "Returns the ssh configuration entry which includes host, identity file location, and StrictHostKeyChecking set to no.", "Returns the ssh configuration entry which includes host, identity file location and StrictHostKeyChecking = no", "Returns the SSH configuration entry which includes host, identity file location and disables StrictHostKeyChecking.", "The method builds an SSH configuration entry which includes host and identity file location, with an additional option for disabling strict host key checking."]}
{"SampleId": 2912364, "Origin": "Extracts the underlying quotes from the {@link CurveInputs} instances and returns them in a map.", "Reference": "Extracts the underlying quotes from the {@link RatesCurveInputs} instances and returns them in a map.", "LLMCandidates": ["Extracts the underlying quotes from the {@link RatesCurveInputs} instances and returns them in a map.", "Extracts the underlying market data from the {@link RatesCurveInputs} instances and returns them in a map.", "Extracts the underlying market data from {@link RatesCurveInputs} instances and returns them in a map.", "Extracts the underlying quotes from the {@link RatesCurveInputs} instances and returns them in a map.", "Extracts the underlying quotes from the {@link RatesCurveInputs} instances and returns them in a map."]}
{"SampleId": 1327233, "Origin": "Sets the minimum session timeout.", "Reference": "Sets the session timeout.", "LLMCandidates": ["Sets the session timeout.", "Sets the session timeout.", "Sets the session timeout.", "Sets the session timeout.", "Sets the session timeout."]}
{"SampleId": 3512228, "Origin": "Gets the {@link Value.Mutable} for the {@link CatType} of this\n{@link CatData}.", "Reference": "Gets the {@link Value.Mutable} for the {@link CatType} of this\n{@link Cat}.", "LLMCandidates": ["Gets the {@link Value.Mutable} for the {@link CatType} of this\n{@link CatData}.", "Gets the {@link Value.Mutable} for the {@link CatType} of this\n{@link CatData}.", "Gets the {@link Value.Mutable} for the {@link CatType} of this {@link CatData}.", "Gets the {@link Value.Mutable} for the {@link CatType} of this {@link CatData}.", "Gets the {@link Value.Mutable} for the {@link CatType} of this {@link CatData}."]}
{"SampleId": 4986032, "Origin": "Copy the contents of a Bucket to a RandomAccessThing at a specific offset.", "Reference": "Copy the contents of a Bucket to a RandomAccessBuffer at a specific offset.", "LLMCandidates": ["Copy the contents of a Bucket to a RandomAccessBuffer at a specific offset.", "Copy the contents of a Bucket to a RandomAccessBuffer at a specific offset.", "Copy the contents of a Bucket to a RandomAccessBuffer at a specific offset.", "Copy the contents of a Bucket to a RandomAccessBuffer at a specific offset.", "Copy the contents of a Bucket to a RandomAccessBuffer at a specific offset."]}
{"SampleId": 5177780, "Origin": "This method is used\nonly to initialize the acceptReplacers field.", "Reference": "This method is used\nonly to initialize the headerReplacers field.", "LLMCandidates": ["This method is used to initialize the acceptReplacers field by reading from the \"org/restlet/service/accept.properties\" file and returning a list of HeaderReplacers based on the \"acceptOld\" and \"acceptNew\" keys.", "This method is used only to initialize the acceptReplacers field by parsing the accept.properties file and setting specific values for \"acceptOld\" and \"acceptNew\".", "Initializes the acceptReplacers field by loading values from the accept.properties file.", "This method is used only to initialize the acceptReplacers field.", "This method is used only to initialize the acceptReplacers field by parsing a properties file and extracting relevant data for creating HeaderReplacer objects."]}
{"SampleId": 4388460, "Origin": "To add or remove access for an AWS account to copy or restore a\nmanual DB snapshot, or to make the manual DB snapshot public or\nprivate, use the ModifyDBSnapshotAttribute API.", "Reference": "To add or remove access for an AWS account to copy or restore a manual DB\nsnapshot, or to make the manual DB snapshot public or private, use the", "LLMCandidates": ["To modify the DBSnapshotAttributes API to allow or deny access for an AWS account to copy or restore a manual DB snapshot, or make it public or private, use the ModifyDBSnapshotAttribute API.", "To add or remove access for an AWS account to copy or restore a manual DB snapshot, or to make the manual DB snapshot public or private, use the ModifyDBSnapshotAttribute API. The updated method now uses a StaxResponseHandler instead of DBSnapshotAttributesResultStaxUnmarshaller directly.", "To use this service to add or remove access for an AWS account to copy or restore a manual DB snapshot, or to make the manual DB snapshot public or private, utilize the ModifyDBSnapshotAttribute API.", "Use this API to modify an existing manual DB snapshot's access permissions for copying or restoring, or make it public or private by using the ModifyDBSnapshotAttribute API.", "To modify the access control settings for a manual DB snapshot, such as granting or revoking access to an AWS account to copy or restore a manual DB snapshot, use the ModifyDBSnapshotAttribute API."]}
{"SampleId": 6018371, "Origin": "Computes the average for each pixel across all bands in the {@link Planar} image.", "Reference": "Computes the minimum for each pixel across all bands in the {@link Planar} image.", "LLMCandidates": ["Computes the minimum value for each pixel across all bands in the {@link Planar} image.", "Finds the minimum value for each pixel across all bands in the {@link Planar} image. The method calls an implementation-specific minimum function to perform this operation.", "Computes the minimum value across all bands in the {@link Planar} image.", "Computes the minimum value for each pixel across all bands in the {@link Planar} image, starting from the specified startBand to lastBand inclusive.", "Computes the minimum value for each pixel across all bands in the {@link Planar} image, using the specified start and end bands. The result is stored in the output {@link GrayS32} image."]}
{"SampleId": 3992810, "Origin": "{@code timeDifferenceMs} can be negative but it's absolute value must not be larger than current window \"before\"\nvalue (which would result in a negative window size).", "Reference": "{@code timeDifferenceMs} can be negative but its absolute value must not be larger than current window \"before\"\nvalue (which would result in a negative window size).", "LLMCandidates": ["@code timeDifferenceMs} can be negative but its absolute value must not exceed the current window \"before\" value (which would result in a negative window size).", "@code timeDifferenceMs} can be negative but its absolute value must not be larger than current window \"before\" value (which would result in a negative window size).", "@code timeDifferenceMs} can be negative but it's absolute value must not be larger than current window \"before\" value (which would result in a negative window size).", "@code timeDifferenceMs} can be negative but it's absolute value must not be larger than current window \"before\" value (which would result in a negative window size).", "@code timeDifferenceMs} can be negative but it's absolute value must not be larger than current window \"before\" value (which would result in a negative window size)."]}
{"SampleId": 4788914, "Origin": "If they are not\nthe same an AssertionFailedError is thrown.", "Reference": "AssertionFailedError is thrown.", "LLMCandidates": ["The assertion compares two objects for sameness; if they are not the same, an AssertionFailedError is thrown.", "Asserts that the two objects are equal by comparing their references. If they are not the same, an AssertionFailedError is thrown.", "Compares the given expected and actual objects by calling the method assertSame(null, expected, actual). If they are not the same, an AssertionFailedError is thrown.", "The assertion fails if they are not the same object.", "Compare if expected and actual objects are the same. If not, throw an AssertionFailedError."]}
{"SampleId": 1310037, "Origin": "Asynchronously gets a service.", "Reference": "Asynchronously gets a api.", "LLMCandidates": ["Asynchronously gets an API.", "Asynchronously gets an Api.", "Asynchronously gets an Api.", "Asynchronously gets an Api.", "Asynchronously gets an API."]}
{"SampleId": 4850245, "Origin": "Tests this matcher against the given {@link DiscordRequest}.", "Reference": "Tests this matcher against the given {@link DiscordWebRequest}.", "LLMCandidates": ["Tests this matcher against the given {@link DiscordWebRequest}.", "Tests this matcher against the given {@link DiscordWebRequest}.", "Tests this matcher against the given {@link DiscordWebRequest}.", "Tests this matcher against the given {@link DiscordWebRequest}.", "Tests this matcher against the given {@link DiscordWebRequest}."]}
{"SampleId": 5218913, "Origin": "Add optimized insert value.", "Reference": "Add insert value.", "LLMCandidates": ["Add insert value with given column names and assignments.", "Add insert value.", "Add insert value.", "Adds an insert value using the given derived column names, assignments, and parameters.", "Adds an insert value using the given derived column names, assignments, and parameters."]}
{"SampleId": 5177561, "Origin": "Creates a new internal Jetty connector.", "Reference": "Creates a new Jetty connection factory.", "LLMCandidates": ["Creates a new internal Jetty HTTP connection factory based on the given configuration.", "Creates a new internal Jetty HTTP connection factory with the specified configuration.", "Creates a new internal Jetty HTTP connection factory with the given configuration.", "Creates a new internal Jetty HTTP connection factory with the given configuration.", "Creates a new internal Jetty HTTP connection factory with the given HttpConfiguration."]}
{"SampleId": 3588530, "Origin": "See\n{@link GlobalCheckpointTracker#updateAllocationIdsFromMaster(long, Set, Set)} for details.", "Reference": "See\n{@link GlobalCheckpointTracker#updateFromMaster(long, Set, Set, Set)} for details.", "LLMCandidates": ["See {@link GlobalCheckpointTracker#updateAllocationIdsFromMaster(long, Set, Set, Set)} for details.", "See {@link GlobalCheckpointTracker#updateAllocationIdsFromMaster(long, Set, Set, Set)} for details.", "See {@link GlobalCheckpointTracker#updateAllocationIdsFromMaster(long, Set, Set, Set)} for details.", "See {@link GlobalCheckpointTracker#updateFromMaster(long, Set, Set, Set)} for details.", "@link GlobalCheckpointTracker#updateAllocationIdsFromMaster(long, Set, Set, Set)} for details."]}
{"SampleId": 1725851, "Origin": "This test asserts that only one\nstate is added to the stateflowgraph.", "Reference": "This test asserts that only one state is added to the state-flow graph.", "LLMCandidates": ["This test asserts that only one state is added to the state flow graph, and the runner exits due to exhaustion.", "This test asserts that only one state is added to the state flow graph when the StateVertexFactory is defined and used for comparison purposes.", "This test asserts that only one state is added to the stateflowgraph with a StateVertexFactory defined, and checks that the session reaches an exhausted state after traversing up to maximum depth.", "This test asserts that only one state is added to the stateflowgraph when a StateVertexFactory is provided and used to compare states.", "This test asserts that only one state is added to the state flow graph when a custom StateVertexFactory is used."]}
{"SampleId": 5595783, "Origin": "Update the metadata version for the given key (cluster or store).", "Reference": "Update the metadata versions for the given keys (cluster or store).", "LLMCandidates": ["Update the metadata version for the given key (cluster or store), using a Collection of nodeIds and a String versionKey.", "Update the metadata version for the given key (cluster or store), considering a collection of nodeIds and a String versionKey.", "Update the metadata version for the given key (cluster or store), using the provided nodeIds.", "Update the metadata version for the given key (cluster or store), using the provided nodeIds.", "Update the metadata version for the given nodeIds and key (cluster or store)."]}
{"SampleId": 3344327, "Origin": "{@code\nimport ratpack.rx2.RxRatpack;\nimport ratpack.test.exec.ExecHarness;\nimport io.reactivex.Observable;", "Reference": "{@code\nimport ratpack.rx2.RxRatpack;\nimport ratpack.test.exec.ExecHarness;\nimport io.reactivex.Single;", "LLMCandidates": ["@code\nimport ratpack.rx2.RxRatpack;\nimport ratpack.test.exec.ExecHarness;\nimport io.reactivex.Single;\n\nConvert an {@link Observable} to a {@link Promise}. This method takes an {@link ObservableOnSubscribe} and returns a new instance of {@link Promise}.\n\nParameters:\n- onSubscribe - The {@link ObservableOnSubscribe} that will be used to create the Observable instance.\n\nReturns:\nA {@link Promise} created from the provided {@link Observable}.", "public static <T> Promise<T> promise(SingleOnSubscribe<T> onSubscribe) throws UnmanagedThreadException {\n    return promise(Single.create(onSubscribe));\n  }", "Converts a SingleOnSubscribe into a Promise, using the provided onSubscribe function and its corresponding Observable or Single method. Throws an UnmanagedThreadException if unable to create the promise due to unmanaged thread issues.", "Converts a SingleOnSubscribe instance into a Promise, using the Single.create method. Throws UnmanagedThreadException if an error occurs while creating the promise.", "Converts a SingleOnSubscribe into a Promise for asynchronous processing on a single item. Throws an exception if the thread is unmanaged."]}
{"SampleId": 3080416, "Origin": "We include all flags that enable CPU instructions as we want best possible performance for\nthe code.", "Reference": "We include all flags that enable AMD64 CPU instructions as we want best possible performance\nfor the code.", "LLMCandidates": ["We include all flags that enable CPU instructions as we want best possible performance for the code.", "We include all flags that enable CPU instructions as we want best possible performance for the code.", "We include all flags that enable CPU instructions as we want best possible performance for", "We include all flags that enable CPU instructions as we want best possible performance for", "We include all flags that enable CPU instructions as we want best possible performance for the code."]}
{"SampleId": 2568439, "Origin": "Sets the value of the 'ValueType' field.", "Reference": "Sets the value of the 'valueType' field.", "LLMCandidates": ["Sets the value of the 'valueType' field.", "Sets the value of the 'valueType' field.", "Sets the value of the 'valueType' field.", "Sets the value of the 'valueType' field.", "Sets the value of the 'valueType' field."]}
{"SampleId": 3921113, "Origin": "The LOCATION on Ontario Lake should not be overwritten since Ontario (STATE_OR_PROVINCE)\ndoes not span Ontario Lake.", "Reference": "The ORGANIZATION on Ontario Bank should not ve overrwritten since Ontario (STATE_OR_PROVINCE)\ndoes not span Ontario Bank.", "LLMCandidates": ["The LOCATION on Ontario Lake should not be overwritten since Ontario (STATE_OR_PROVINCE) does not span Ontario Bank.", "The LOCATION on Ontario Lake should not be overwritten since Ontario Bank does not span Ontario Lake.", "The LOCATION on Ontario Lake should not be overwritten since Ontario (STATE_OR_PROVINCE) does not span Ontario Lake.", "The LOCATION on Ontario Lake should not be overwritten since Ontario does not span Ontario Lake and Bank is an ORGANIZATION.", "The LOCATION on Ontario Lake should not be overwritten since Ontario (STATE_OR_PROVINCE) does not span Ontario Lake."]}
{"SampleId": 5440225, "Origin": "This method should only be used for steps whose value is\n{@link #TYPE_ARGUMENT TYPE_ARGUMENT}.", "Reference": "This method should\nonly be used for steps whose value is {@link #TYPE_ARGUMENT}.", "LLMCandidates": ["This method should only be used for steps whose value is {#TYPE_ARGUMENT TYPE_ARGUMENT}.", "This method should only be used for steps whose value is {@link #TYPE_ARGUMENT TYPE_ARGUMENT}.", "This method should only be used for steps whose value is {@link #TYPE_ARGUMENT TYPE_ARGUMENT}.", "Returns the type_argument_index of the path element of the given index. This method should only be used for steps whose value is {@link #TYPE_ARGUMENT TYPE_ARGUMENT}.", "This method should only be used for steps whose value is {#TYPE_ARGUMENT TYPE_ARGUMENT}."]}
{"SampleId": 3805026, "Origin": "Registers a new content observer for the media library", "Reference": "Registers a new library observer for the media library", "LLMCandidates": ["Registers a new library observer for the media library", "Registers a new library observer for the media library", "Registers a new library observer for the media library", "Registers a new library observer for the media library", "Registers a new library observer for the media library"]}
{"SampleId": 2615521, "Origin": "Returns the height of the specified row, or 0 if the table layout has not been validated.", "Reference": "Returns the height of the specified row.", "LLMCandidates": ["Returns the height of the specified row.", "Returns the height of the specified row.", "Returns the height of the specified row.", "Returns the height of the specified row.", "Returns the height of the specified row."]}
{"SampleId": 2774802, "Origin": "Specifies the component's horizontal width, measured in pixels.", "Reference": "Specifies the horizontal width of the %type%, measured in pixels.", "LLMCandidates": ["Specifies the horizontal width of the %type%, measured in pixels.", "Specifies the horizontal width of the %type%, measured in pixels.", "Specifies the horizontal width of the %type%, measured in pixels.", "Specifies the horizontal width of the %type%, measured in pixels.", "Specifies the horizontal width of the %type%, measured in pixels."]}
{"SampleId": 3399007, "Origin": "Test of parse method, of class FinishedMessageParser.", "Reference": "Test of parse method, of class FinishedParser.", "LLMCandidates": ["Test of parse method, of class FinishedParser.", "Test of parse method, of class FinishedParser.", "Test of parse method, of class FinishedParser.", "Test of parse method, of class FinishedParser.", "Test of parse method, of class FinishedParser."]}
{"SampleId": 4473556, "Origin": "Create Subject Alternative names with emails.", "Reference": "Set the emails.", "LLMCandidates": ["Set emails for Subject Alternative Names.", "Set Subject Alternative Names emails.", "Set Subject Alternative Names emails.", "Set Subject Alternative names emails.", "Set Subject Alternative names emails."]}
{"SampleId": 4615496, "Origin": "If nodes returned are to be further used, they must be finalized via {@link ANode#finish()}.", "Reference": "Before nodes are added to the result, they must be finalized via {@link ANode#finish()}.", "LLMCandidates": ["If nodes returned are to be further used, they must be finalized via {@link ANode#finish()}.", "If nodes returned are to be further used, they must be finalized via {@link ANode#finish()}.", "If nodes returned are to be further used, they must be finalized via {@link ANode#finish()}.", "If nodes returned are to be further used, they must be finalized via {@link ANode#finish()}.", "The content of the updated code reflects a change from {@link ANode#children()} to {@link ANode#childIter()}. If nodes returned are to be further used, they must be finalized via {@link ANode#finish()}."]}
{"SampleId": 2081521, "Origin": "We make sure that\ntrying to update the field works if the user has the \"correct\" role, but failes if it doesn't.", "Reference": "We make sure that\ntrying to update the field works if the user has the \"correct\" role, but fails if it doesn't.", "LLMCandidates": ["We make sure that trying to update the field works if the user has the \"correct\" role, but fails if it doesn't.", "We make sure that trying to update the field works if the user has the \"correct\" role, but fails if it doesn't.", "We ensure that updating the field succeeds if the user has the \"correct\" role, but fails if it doesn't.", "We make sure that trying to update the field works if the user has the \"correct\" role, but failses if it doesn't.", "We make sure that trying to update the field works if the user has the \"correct\" role, but failses if it doesn't."]}
{"SampleId": 6192516, "Origin": "Create new {@link Builder} based on an existing {@link BaseEvent} instance and and {@link EventContext}.", "Reference": "Create new {@link Builder} based on an existing {@link CoreEvent} instance and and {@link EventContext}.", "LLMCandidates": ["Create new {@link Builder} based on an existing {@link CoreEvent} instance and {@link EventContext}.", "Create new {@link Builder} based on an existing {@link CoreEvent} instance and {@link EventContext}.", "Create new {@link Builder} based on an existing {@link CoreEvent} instance and {@link EventContext}.", "Create new {@link Builder} based on an existing {@link CoreEvent} instance and {@link EventContext}.", "Create new {@link Builder} based on an existing {@link CoreEvent} instance and {@link EventContext}."]}
{"SampleId": 2217848, "Origin": "Test of npara method, of class MultivariateGaussian.", "Reference": "Test of length method, of class MultivariateGaussian.", "LLMCandidates": ["Test of length method, of class MultivariateGaussian.", "Test of length method, of class MultivariateGaussian.", "Test of length method, of class MultivariateGaussian.", "Test of length method, of class MultivariateGaussian.", "Test of length method, of class MultivariateGaussian."]}
{"SampleId": 3552099, "Origin": "Create a {@link Jwt} Validator that contains all standard validators as well as\nany supplied in the parameter list.", "Reference": "Create a {@link Jwt} Validator that contains all standard validators when an issuer is known.", "LLMCandidates": ["Create a {@link Jwt} Validator that contains all standard validators, including a {@link JwtTimestampValidator} and an optional {@link JwtIssuerValidator}, specified by the issuer string.", "Create a {@link Jwt} Validator that contains all standard validators as well as an optional Issuer Validator with the specified issuer value from the parameter list.", "Create a {@link Jwt} Validator that contains all standard validators along with an additional {@link JwtIssuerValidator}.", "Create a {@link Jwt} Validator that contains all standard validators and a validator for a specified issuer from the parameter.", "Create a {@link Jwt} Validator that includes all standard validators and adds an optional JwtIssuerValidator with the specified issuer."]}
{"SampleId": 373027, "Origin": "Gets a property of type {@link PropertyType#PATH}, interpreting the value properly, replacing\nsupported environment variables.", "Reference": "Gets a property of type {@link PropertyType#PATH}.", "LLMCandidates": ["Gets a property of type {@link PropertyType#PATH}, interpreting the value properly, replacing supported environment variables if they exist. However, if the path starts with an unsupported environment variable ($ACCUMULO_), it will throw an IllegalArgumentException.", "Gets a property of type {@link PropertyType#PATH}, interpreting the value properly, replacing supported environment variables and checking for unsupported variable interpolation.", "Gets a property of type {@link PropertyType#PATH}, interpreting the value properly, replacing supported environment variables if not containing any unsupported variable like '${ACCUMULO_'} and throwing an exception in such case.", "Gets a property of type {@link PropertyType#PATH}, interpreting the value properly, replacing supported environment variables and checking if it contains unsupported environment variable interpolation.", "Gets a property of type {@link PropertyType#PATH}, interpreting the value properly, replacing supported environment variables. However, it does not support interpolation using \"$ACCUMULO_\" variables. If such a variable is found in the input string, an IllegalArgumentException will be thrown with a warning to use '${env:ACCUMULO_HOME}' or similar."]}
{"SampleId": 2732049, "Origin": "Returns whether or not specified {@link SVGElement} fits this {@link SvgSelector} conditions.", "Reference": "Returns whether or not specified {@link SVGElement} matches this {@link SvgSelector} conditions.", "LLMCandidates": ["Returns whether or not specified {@link SVGElement} fits this {@link SvgSelector}'s conditions when using {@code @NotNull} annotation on input parameters.", "Returns whether or not specified {@link SVGElement} fits this {@link SvgSelector}'s conditions with non-null parameters.", "Returns whether or not specified {@link SVGElement} fits this {@link SvgSelector} conditions if the given {@link SvgIcon} and {@link SVGElement} are not null.", "Returns whether or not specified {@link SVGElement} fits this {@link SvgSelector} conditions with {@link NotNull} annotations added to the input parameters.", "Returns whether or not specified {@link SVGElement} fits this {@link SvgSelector}'s conditions, considering both the selector and attributes checks."]}
{"SampleId": 5062115, "Origin": "Parent will have\nmodified time to set to {@link LayerConfiguration#DEFAULT_MODIFIED_TIME}.", "Reference": "Parent will have\nmodification time set to {@link LayerConfiguration#DEFAULT_MODIFICATION_TIME}.", "LLMCandidates": ["Sets the modified time of parent directories to {@link LayerConfiguration#DEFAULT_MODIFICATION_TIME}.", "Sets the modified time for directories along extraction paths to {@link LayerConfiguration#DEFAULT_MODIFICATION_TIME}.", "Sets the modified time for the parent directory to {@link LayerConfiguration#DEFAULT_MODIFICATION_TIME}.", "Adds all directories along extraction paths to explicitly set permissions for those directories. The parent directory will have its modification time set to {@link LayerConfiguration#DEFAULT_MODIFICATION_TIME}.", "Adds all directories along extraction paths to explicitly set permissions for those directories by setting their modification time to {@link LayerConfiguration#DEFAULT_MODIFICATION_TIME}."]}
{"SampleId": 3406829, "Origin": "Returns true if the method m is visible from code in the class from.", "Reference": "Returns true if the classmember m is visible from code in the class from.", "LLMCandidates": ["Returns true if the method m is visible from code in the class from, considering its access modifiers and the relationship between classes.", "Returns true if the method m is visible from code in the class from.", "Returns true if the member m is visible from code in the class from.", "Returns true if the method m is visible from code in the class from.", "Returns true if the method m is visible from code in the class from."]}
{"SampleId": 2706894, "Origin": "Set Balancing.", "Reference": "Set Saldierung.", "LLMCandidates": ["Sets whether the record is currently being balanced.", "Set IsBalancing in the given boolean value.", "Set IsBalancing in the given boolean value.", "Set IsBalancing in the given boolean value.", "Set IsBalancing."]}
{"SampleId": 471489, "Origin": "The option will be converted to a  type.", "Reference": "The option is a:  type.", "LLMCandidates": ["The option will be converted to a boolean type.", "Set the property by disabling stream cache if disabled is true.", "Set the property by disabling stream cache if disabled is true.", "The option will be converted to a type.", "The option will be converted to a type."]}
{"SampleId": 2915665, "Origin": "Returns a curve node for a CDS quoted in points upfront.", "Reference": "Returns a curve node with points upfront convention.", "LLMCandidates": ["Returns a curve node for a CDS quoted in points upfront using given template, observableId, legalEntityId, and fixedRate.", "Returns a curve node for a CDS quoted with points upfront.", "Returns a curve node for a CDS quoted with points upfront.", "Returns a curve node for a CDS with points upfront quoting convention.", "Returns a curve node for a CDS with points upfront quoting convention."]}
{"SampleId": 733850, "Origin": "Recursively find all operators under root, that are of class clazz, and\nput them in result.", "Reference": "Recursively find all operators under root, that are of class clazz or are the sub-class of clazz, and\nput them in result.", "LLMCandidates": ["Collect operators of class clazz from root and store them in result by recursively calling this method on child operators.", "Recursively find all operators under root, that are of class clazz or a subclass of it, and put them in result.", "Recursively find all operators under root, that are of class clazz or a subclass, and put them in result.", "Recursively find all operators under root that are of class clazz and add them to result.", "Recursively find all operators under root, that are of class or subclass clazz, and put them in result."]}
{"SampleId": 4245998, "Origin": "Convert to object types, returning null if text is null.", "Reference": "Convert to object types, returning null if text is null or empty.", "LLMCandidates": ["Convert to object types, returning null if text is empty.", "Convert to object types, returning null if text is empty.", "Convert to object types, returning null if text is empty.", "Convert to object types, returning null if text is empty.", "Convert to object types, returning null if text is empty."]}
{"SampleId": 230839, "Origin": "Sets the transformed layout.", "Reference": "Transform the partition.", "LLMCandidates": ["Transforms a layout based on the given definition and layout.", "Apply transformation with the given definition and layout.", "Apply transformation with the given definition and layout.", "Apply a transformation using a definition and layout.", "Apply a transformation using a definition and layout."]}
{"SampleId": 6174108, "Origin": "Creates an entity and populates its state based on the dbObject given.", "Reference": "Creates an entity and populates its state based on the document given.", "LLMCandidates": ["Creates an entity and populates its state based on the document given.", "Creates an entity and populates its state based on the document given.", "Creates an entity and populates its state based on the Document given.", "Creates an entity and populates its state based on the Document given.", "Creates an entity and populates its state based on the Document given."]}
{"SampleId": 5629969, "Origin": "Sets the entity.", "Reference": "Set the entity.", "LLMCandidates": ["Sets the entity when building an object.", "Sets the entity using a Builder pattern.", "Sets the entity using a builder pattern.", "Sets the entity using a builder pattern.", "Sets the entity using a builder pattern."]}
{"SampleId": 1150835, "Origin": "An empty NumericDocValues which returns zero for every document", "Reference": "An empty NumericDocValues which returns no documents", "LLMCandidates": ["An empty NumericDocValues which returns zero for every document and exhausted state is managed with advanced and nextDoc methods.", "An empty NumericDocValues which returns zero for every document and exhausted flag is set when there are no more documents to return.", "An empty NumericDocValues which returns zero for every document when advancing and has an exhausted flag to indicate end of result set.", "An empty NumericDocValues which only returns zero for the first document, then throws NO_MORE_DOCS when advancing or accessing other documents.", "A static final NumericDocValues implementation providing an empty numeric doc values object with zero value for all documents, also supporting methods to advance, get document ID, and return no more documents or cost."]}
{"SampleId": 3427796, "Origin": "Setter for the URL of the content review icon associated with this item", "Reference": "Setter for the css class of the content review icon associated with this item", "LLMCandidates": ["Setter for the CSS class of the content review icon associated with this item", "Setter for the CSS class of the content review icon associated with this item", "Setter for the CSS class of the content review icon associated with this item", "Setter for the CSS class of the content review icon associated with this item", "Setter for the CSS class of the review icon associated with this item."]}
{"SampleId": 3196536, "Origin": "Returns\n {@link RolapConnectionProperties#UseContentChecksum}\nis set to false.", "Reference": "Returns\n if {@link RolapConnectionProperties#UseContentChecksum}\nis set to false.", "LLMCandidates": ["Returns {@link RolapConnectionProperties#UseContentChecksum} is set to false.", "Returns {@link RolapConnectionProperties#UseContentChecksum} is set to false.", "Returns {@link RolapConnectionProperties#UseContentChecksum} is set to false; gets a ByteString representation of an MD5 checksum.", "Returns the checksum represented as a ByteString", "Returns the checksum represented as a ByteString"]}
{"SampleId": 1576617, "Origin": "Returns an {@link InputSupplier} for a given entry.", "Reference": "Gets the {@link Manifest} inside the given jar.", "LLMCandidates": ["Returns an {@link InputSupplier} for a given entry based on a URL location.", "This method returns an {@link InputSupplier} for a given entry from a location specified by URI.", "This method returns an {@link InputSupplier} for a given entry from a location specified by URI.", "Get an {@link InputSupplier} for a given entry based on the URL provided.", "Returns an {@link InputSupplier} for a given entry based on a specific URI and entry name."]}
{"SampleId": 2732050, "Origin": "Returns whether or not specified {@link SVGElement} fits this {@link SvgSelector} selector conditions.", "Reference": "Returns whether or not specified {@link SVGElement} matches this {@link SvgSelector} conditions.", "LLMCandidates": ["Returns whether or not specified {@link SVGElement} fits this {@link SvgSelector} selector conditions.", "Returns whether or not specified {@link SVGElement} fits this {@link SvgSelector} selector conditions, taking into account the changes in method signature and variable name.", "Returns whether or not specified {@link SVGElement} fits this {@link SvgSelector} selector conditions. The method signature has been changed from \"private\" to \"protected\" and the parameters are now annotated with \"@NotNull\". Additionally, the code has been updated to use StyleAttributes for checking attribute values in the else if statements.", "Returns whether or not specified {@link SVGElement} fits this {@link SvgSelector} selector conditions.", "Returns whether or not specified {@link SVGElement} fits this {@link SvgSelector} selector conditions."]}
{"SampleId": 2134051, "Origin": "bounded predict\n* predict the rating given a sparse appender vector", "Reference": "Predict the rating given a sparse appender vector.", "LLMCandidates": ["Bounded predict for a specific user-item pair, given a sparse vector\n* Predict the rating for a specific user-item interaction using the sparse vector", "bounded predict\n* predict the rating given a sparse appender vector and user id and item id", "bounded predict\n* predict the rating given a sparse appender vector and specific user id and item", "bounded predict\n* predict the rating given a sparse appender vector and userId, itemId", "bounded predict\n* predict the rating given a sparse appender vector and userId, itemId"]}
{"SampleId": 5440405, "Origin": "One way to ensure this is to always call\n{@link #declareLabel declared} before calling this method.", "Reference": "One way to ensure this is to always call {@link #declareLabel} before\ncalling this method.", "LLMCandidates": ["One way to ensure this is to always call {@link #appendLabel declared} before calling this method.", "One way to ensure this is to always call {@link #declareLabel declared} before calling this method.", "One way to ensure this is to always call {@link #declareLabel declared} before calling this method.", "To ensure that the labels are added correctly, call {@link #declareLabel declared} before calling this method.", "To ensure that the labels are added correctly, call {@link #declareLabel declared} before calling this method."]}
{"SampleId": 4003873, "Origin": "Felix constructor documentation for more information on\nframework configuration options.", "Reference": "Refer to the  Felix\n constructor documentation for more information on framework\nconfiguration options.", "LLMCandidates": ["Launch and manage the karaf framework within a loop, checking for restart conditions and exiting with appropriate codes upon shutdown or errors.", "This method is responsible for continuously running a program while handling restarts and shutdowns. The main method creates an instance of the Main class with arguments provided and calls its launch() method to initialize the framework. It then awaits the shutdown of the framework, destroys it if necessary, and checks for a restart condition. If no restart is needed, the program exits with the specified exit code.", "Felix constructor documentation for more information on framework configuration options.", "Felix constructor documentation for more information on framework configuration options.", "Launch the framework and await its shutdown. If shutdown is not successful, print an error message and exit with a non-zero code. Otherwise, restart the process if specified by command line options or exit the VM."]}
{"SampleId": 2775452, "Origin": "The choices are: 1 = top, 2 = vertically centered, 3 = aligned at the bottom.", "Reference": "The choices are: 1 = aligned at the top, 2 = vertically centered, 3 = aligned at the bottom.", "LLMCandidates": ["A number that encodes how the contents of the arrangement are aligned vertically. The choices are: 1 = top, 2 = vertically centered, 3 = bottom. Alignment has no effect if the arrangement's height is automatic.", "A number that encodes how the contents of the arrangement are aligned vertically. The choices are: 1 = top, 2 = vertically centered, 3 = aligned at the bottom. Alignment has no effect if the arrangement's height is automatic.", "A number that encodes how the contents of the arrangement are aligned vertically. The choices are: 1 = top, 2 = vertically centered, 3 = bottom. Alignment has no effect if the arrangement's height is automatic.", "A number that encodes how the contents of the arrangement are aligned vertically. The choices are: 1 = top, 2 = vertically centered, 3 = bottom. Alignment has no effect if the arrangement's height is automatic.", "A number that encodes how the contents of the arrangement are aligned vertically. The choices are: 1 = top, 2 = vertically centered, 3 = aligned at the bottom. Alignment has no effect if the arrangement's height is automatic."]}
{"SampleId": 3652423, "Origin": "Verifies that the given {@code emailContent} is the same as\nthe content given in the file at {@code filePathParam}.", "Reference": "Verifies that the given {@code emailContent} is the same as\nthe content given in the file at {@code fileName}.", "LLMCandidates": ["Verifies that the given {@code emailContent} is the same as the content given in the file with the specified {@code fileName}.", "Verifies that the given {@code emailContent} is the same as the content given in the file at {@code fileName}.", "Verifies that the given {@code emailContent} is the same as the content given in the file at {@code fileName}.", "Verifies that the given {@code emailContent} is the same as the content given in the file at {@code fileName}.", "Verifies that the given {@code emailContent} is the same as the content given in the file at {@code fileName}."]}
{"SampleId": 2732074, "Origin": "Returns a better disabled icon than BasicLookAndFeel offers.", "Reference": "Returns better disabled icon than {@link BasicLookAndFeel} offers.", "LLMCandidates": ["Returns a disabled icon for the given input icon by either returning an existing disabled version or creating a new one if needed.", "Generates an optional disabled icon based on the given icon.", "Generates an optional disabled icon based on the given icon.", "Returns a disabled icon for the given input icon by using ImageUtils.getDisabledCopy().", "Returns a disabled icon for the given input icon by using ImageUtils.getDisabledCopy()."]}
{"SampleId": 4048110, "Origin": "This will set the margin between the annotations \"outer\" rectangle defined by\n/Rect and the border.", "Reference": "This will set the difference between the annotations \"outer\" rectangle defined by\n/Rect and the border.", "LLMCandidates": ["This will set the margin between the annotations \"outer\" rectangle defined by /Rect and the border using the difference between their respective sides.", "This will set the margin between the annotations \"outer\" rectangle defined by /RectDifferences and the border.", "This will set the margin between the annotations \"outer\" rectangle defined by /Rect and the border.", "This will set the margin between the annotations \"outer\" rectangle defined by /Rect and the border using differences instead of margins.", "This will set the margin between the annotations \"outer\" rectangle defined by /Rect and the border using difference values instead of margin values."]}
{"SampleId": 1703350, "Origin": "Compute the total number of transferred addresses.", "Reference": "Get the total number of addresses in range.", "LLMCandidates": ["Calculate the total number of transferred addresses.", "Calculate the total number of transferred addresses.", "Get the total number of addresses transferred by calculating the difference between endAddress and startAddress, then add 1L.", "Return the total difference between endAddress and startAddress, including 1L.", "Return the total difference between endAddress and startAddress, including 1L."]}
{"SampleId": 664505, "Origin": "Convenience method for calling {@link #newGenericExecuteException(TemplateCallableModel, boolean, String)}.", "Reference": "Convenience method for calling\n{@link #newGenericExecuteException(String, TemplateCallableModel, boolean, Throwable)}", "LLMCandidates": ["Convenience method for calling {@link #newGenericExecuteException(boolean, String, TemplateFunctionModel, Throwable)}.", "The convenience method for calling {@link #newGenericExecuteException(String, TemplateFunctionModel, Throwable)} with optional boolean flag to indicate whether the exception is retryable or not.", "Convenience method for calling {@link #newGenericExecuteException(boolean, String, TemplateFunctionModel)}.", "Convenience method for calling {@link #newGenericExecuteException(boolean, String, TemplateFunctionModel, Throwable)}.", "Convenience method for calling {@link #newGenericExecuteException(boolean, String, Throwable)} with a reversed order of arguments (callable, errorDescription, cause)."]}
{"SampleId": 3035868, "Origin": "Backs up all buckets for the device to the given node.", "Reference": "Backs up the given flow bucket.", "LLMCandidates": ["Backs up a specific bucket for the device to the given node.", "Backs up all buckets for the device using a multi-threaded approach to replicate the bucket to each backup node in parallel if the bucket's term matches the local node's current term. If there are no matching terms or the local node is not the master, it will return without performing any backups.", "This method backs up all buckets for the device to the given node if the bucket's term matches the replica term and the local node is the current master.", "Backs up all buckets for the device, only if their term matches the replica term and the local node is the current master. The backup operation runs concurrently on each of the backup nodes.", "This method backs up a FlowBucket for all buckets of a device to the specified node if the bucket's term matches the replica term and the local node is the current master. It returns a CompletableFuture for the backup operation."]}
{"SampleId": 2848848, "Origin": "Make JobDirectoryManifestService beans are configured as expected.", "Reference": "Make JobDirectoryManifestService beans is configured as expected.", "LLMCandidates": ["Check that JobDirectoryManifestService beans are configured as expected.", "Confirm the correct configuration of JobDirectoryManifestService beans.", "Confirm the correct configuration of JobDirectoryManifestService beans.", "Confirm that there is a single bean of type JobDirectoryManifestService.", "Tests if JobDirectoryManifestService beans are configured correctly with a single bean present."]}
{"SampleId": 2577115, "Origin": "Runs the given {@code runnable} at most {@code retryCount} times until it passes,\nleaving {@code intervalMillis} milliseconds between the invocations.", "Reference": "Runs the given {@code runnable} at most {@code attemptsCount} times until it passes,\nleaving {@code intervalMillis} milliseconds between the invocations.", "LLMCandidates": ["Runs the given {@code supplier} at most {@code attemptsCount} times until it passes, leaving {@code intervalMillis} milliseconds between the invocations.", "Runs the given {@code supplier} at most {@code attemptsCount} times until it doesn't throw a {@code RuntimeException} or {@code AssertionError}, leaving {@code intervalMillis} milliseconds between the invocations.", "Runs the given {@code supplier} at most {@code attemptsCount} times until it passes, leaving {@code intervalMillis} milliseconds between the invocations.", "Runs the given {@code supplier} at most {@code attemptsCount} times until it successfully returns a non-empty result, leaving {@code intervalMillis} milliseconds between the invocations.", "Runs the given {@code supplier} at most {@code attemptsCount} times until it passes, leaving {@code intervalMillis} milliseconds between the invocations."]}
{"SampleId": 4618280, "Origin": "Removes a query focus from the stack.", "Reference": "Removes the current query focus from the stack.", "LLMCandidates": ["Removes a query focus from the top of the stack.", "Removes a query focus from the stack.", "Removes a query focus from the stack.", "Removes a query focus from the stack.", "Removes a query focus from the stack."]}
{"SampleId": 5458245, "Origin": "It\nsatisfies the general contract of the {@link Object#hashCode", "Reference": "It satisfies the general\ncontract of the {@link Object#hashCode Object.hashCode} method.", "LLMCandidates": ["Overrides the method of Object#hashCode. Calculates the hash value by combining name and mods' hash codes, and includes compiledVersion's hash code if it is not null.", "Overrides Object#hashCode and calculates the hash code by combining the hashes of name, mods, and compiledVersion. The result is returned as the final hash value.", "Returns a hash code value for this object. The general contract of {@link Object#hashCode} is: hashCode() == obj.hashCode() must be true for the same object. This method computes a hash", "Override\n        public int hashCode() {\n            int hash = name.hashCode() * 43 + mods.hashCode();\n            if (compiledVersion != null)\n                hash = hash * 43 + compiledVersion.hashCode();\n            return hash;\n        }\n\nThis method implements the {@link Object#hashCode} contract by calculating a hash value based on the name, mods, and compiledVersion of an object. The hash value is initially created by mixing the hashes of the name and mods variables using a specific multiplier (43). If the compiledVersion variable is not null, its hash code is also incorporated into the result by multiplying the previous hash value by 43 and adding the new hash code. This method provides a unique identifier for the object, useful in various contexts like caching or synchronization.", "Calculates a hash code based on the values of name and mods, with an additional multiplier for compiledVersion if it is not null."]}
{"SampleId": 1922860, "Origin": "NativeLinkable}.", "Reference": "NativeLinkableGroup}.", "LLMCandidates": ["getNativeLinkableDeps(BuildRuleResolver ruleResolver).Returns anIterable of NativeLinkableGroup objects which represent the native dependencies of the build rule.", "getNativeLinkableDeps of NativeLinkableGroup class.", "getNativeLinkableDeps of NativeLinkableGroup class.", "Return an Iterable of NativeLinkableGroup dependencies given a BuildRuleResolver.", "Return an Iterable of NativeLinkableGroup dependencies given a BuildRuleResolver."]}
{"SampleId": 3830101, "Origin": "Returns a new Run with the new status, and with the status of the given, completed step set accordingly.", "Reference": "Returns a new Run with the status of the given completed step set accordingly.", "LLMCandidates": ["Sets the new status of the Run, and modifies the completed step's status accordingly.", "Returns a new Run with the new status, and with the status of the given completed step set accordingly.", "Returns a new Run with the new status, and with the status of the given completed step set accordingly.", "Returns a new Run with the new status, and sets the status of the given completed step accordingly by updating its information from the EnumMap.", "Returns a new Run with the new status, and with the status of the given, completed step set accordingly by updating the step's EnumMap value."]}
{"SampleId": 2912437, "Origin": "Sets the groups used to find an issuer curve.", "Reference": "Sets the groups used to find an issuer curve by legal entity.", "LLMCandidates": ["Sets the groups used to find an issuer curve based on a map of LegalEntityIds and LegalEntityGroups.", "Sets the groups used to find an issuer curve with a LegalEntityId key instead of StandardId.", "Sets the groups used to find an issuer curve with a LegalEntityId key instead of StandardId.", "Sets the groups used to find an issuer curve with a map of LegalEntityId to LegalEntityGroup.", "Sets the groups used to find an issuer curve with a change in the key type from StandardId to LegalEntityId."]}
{"SampleId": 4776185, "Origin": "Sets the amount of damage caused by the event", "Reference": "Sets the raw amount of damage caused by the event", "LLMCandidates": ["Sets the base damage amount using DamageModifier.BASE.", "Sets the base amount of damage caused by the event", "Sets the base amount of damage caused by the event", "Sets the base amount of damage caused by the event", "Sets the damage by modifying it with a base value using DamageModifier."]}
{"SampleId": 2544522, "Origin": "Apply the rotation transformation of the given {@link Quaterniond} to this matrix and store\nthe result in .", "Reference": "Apply the rotation transformation of the given {@link Quaterniondc} to this matrix and store\nthe result in .", "LLMCandidates": ["Apply the rotation transformation of the given {@link Quaterniondc} to this matrix and store the result in .", "Apply the rotation transformation of the given {@link Quaterniondc} to this matrix and store the result in .", "Apply the rotation transformation of the given {@link Quaterniondc} to this matrix and store the result in .", "Apply the rotation transformation of the given {@link Quaterniondc} to this matrix and store the result in .", "Apply the rotation transformation of the given {@link Quaterniond} to this matrix and store the result in ."]}
{"SampleId": 4470238, "Origin": "Gets the {@link EncryptionScope} used to encrypt this blob's content on the server.", "Reference": "Gets the {@code encryption scope} used to encrypt this blob's content on the server.", "LLMCandidates": ["Gets the {@link String} used to encrypt this blob's content on the server.", "Gets the {@link String} used to encrypt this blob's content on the server.", "Gets the EncryptionScope} used to encrypt this blob's content on the server.", "Gets a string representing the {@link EncryptionScope} used to encrypt this blob's content on the server.", "Gets a string representing the {@link EncryptionScope} used to encrypt this blob's content on the server."]}
{"SampleId": 1131683, "Origin": "If version is null, \"latest\" or \"$LATEST\",\nthen it returns the highest version available in the system for the package.", "Reference": "If version is null, PackageUtils.LATEST or PackagePluginHolder.LATEST,\nthen it returns the highest version available in the system for the package.", "LLMCandidates": ["If version is null, \"latest\" or PackageUtils.LATEST, then it returns the highest version available in the system for the package.", "If version is null, \"latest\" or PackageUtils.LATEST, then it returns the highest version available in the system for the package.", "If version is null, \"latest\", \"$LATEST\", PackageUtils.LATEST or PackagePluginHolder.LATEST, then it returns the highest version available in the system for the package.", "If version is null, \"latest\" or PackageUtils.LATEST, then it returns the highest version available in the system for the package.", "If version is null, \"latest\", or PackageUtils.LATEST or PackagePluginHolder.LATEST, then it returns the highest version available in the system for the package."]}
{"SampleId": 5175625, "Origin": "Configuration)", "Reference": "Dynamic Configuration)", "LLMCandidates": ["If multiple redirection URIs have been registered, if only part of the redirection URI has been registered, or if no redirection URI has been registered, the client MUST include a redirection URI with the authorization request using the \"redirect_uri\" request parameter. (See 3.1.2.3. Dynamic Configuration)", "If multiple redirection URIs have been registered, if only part of the redirection URI has been registered, or if no redirection URI has been registered, the client MUST include a redirection URI with the authorization request using the \"redirect_uri\" request parameter. (See 3.1.2.3. Dynamic Configuration)", "If multiple redirection URIs have been registered, if only part of the redirection URI has been registered, or if no redirection URI has been registered, the client MUST include a redirection URI with the authorization request using the \"redirect_uri\" request parameter. (See 3.1.2.3. Dynamic Configuration)", "If multiple redirection URIs have been registered, if only part of the redirection URI has been registered, or if no redirection URI has been registered, the client MUST include a redirection URI with the authorization request using the 'redirect_uri' request parameter. (See 3.1.2.3. Dynamic Configuration)", "If no redirection URI has been registered, the client MUST include a redirection URI with the authorization request using the \"redirect_uri\" request parameter. If multiple redirection URIs have been registered or only part of the redirection URI has been registered, the server MUST compare and match the value received against at least one of the registered redirection URIs as defined in [RFC3986] Section 6, if any redirection URIs were registered."]}
{"SampleId": 803642, "Origin": "Gets the threshold parameter value.", "Reference": "Get the threshold parameter value.", "LLMCandidates": ["Gets the threshold parameter value.", "Gets the threshold parameter value.", "Gets the threshold parameter value.", "Gets the threshold parameter value.", "Gets the threshold parameter value."]}
{"SampleId": 237395, "Origin": "Tests the {@link FileSystemMaster#checkConsistency(AlluxioURI, CheckConsistencyOptions)} method\nwhen a file is not the correct size.", "Reference": "Tests the {@link FileSystemMaster#checkConsistency(AlluxioURI, CheckConsistencyContext)} method\nwhen a file is not the correct size.", "LLMCandidates": ["Tests the {@link FileSystemMaster#checkConsistency(AlluxioURI, CheckConsistencyContext)} method when a file is not the correct size.", "Tests the {@link FileSystemMaster#checkConsistency(AlluxioURI, CheckConsistencyContext)} method when a file is not the correct size.", "Tests the {@link FileSystemMaster#checkConsistency(AlluxioURI, CheckConsistencyContext)} method when a file is not the correct size.", "Tests the {@link FileSystemMaster#checkConsistency(AlluxioURI, CheckConsistencyContext)} method when a file is not the correct size.", "Tests the {@link FileSystemMaster#checkConsistency(AlluxioURI, CheckConsistencyContext)} method when a file is not the correct size."]}
{"SampleId": 1612089, "Origin": "Returns list of nodes matching defined line and column number.", "Reference": "Returns list of nodes matching defined line number, column number and token type.", "LLMCandidates": ["Returns list of nodes matching defined line and column number and their token type.", "Returns list of nodes matching defined line and column number with tokenType consideration.", "Returns list of nodes matching defined line and column number, considering token type while searching.", "Returns list of nodes matching defined line and column number based on token type.", "Returns list of nodes matching defined line and column number based on token type."]}
{"SampleId": 1992986, "Origin": "Deletes an external ID.", "Reference": "Inserts or updates an external ID.", "LLMCandidates": ["Upserts an external ID.", "Upserts an external ID.", "Upserts an external ID.", "Upserts an external ID.", "Upserts an external ID."]}
{"SampleId": 6330486, "Origin": "Calls the specified converter function with the current Maybe instance\nduring assembly time and returns its result.", "Reference": "Calls the specified converter function during assembly time and returns its resulting value.", "LLMCandidates": ["Calls the specified converter function with the current Maybe instance during assembly time and returns its result.", "Calls the specified converter function with the current Maybe instance during assembly time and returns its result.", "Converts the current Maybe instance with the specified converter function and returns its result.", "Converts the current Maybe instance using the specified converter function during assembly time and returns its result.", "Converts the current Maybe instance using the specified converter function during assembly time and returns its result."]}
{"SampleId": 2337101, "Origin": "Get OpenID IDP configurations\n### Functional Description:   Retrieve a list of configured OpenID Connect IDPs.", "Reference": "Get list of OpenID Connect IDP configurations\n### Functional Description:   Retrieve a list of configured OpenID Connect IDPs.", "LLMCandidates": ["Retrieve a list of configured OpenID Connect IDPs using the given XSdsAuthToken.", "Retrieve a list of configured OpenID Connect IDPs using the specified authentication token.", "Get OpenID IDP configurations", "Get OpenID IDP configurations", "Get OpenID IDP configurations"]}
{"SampleId": 431814, "Origin": "Reports the percentile value from the given list ordered in a non-descending order.", "Reference": "Reports the percentile value from the continuous distribution described by a given list of\nsamples.", "LLMCandidates": ["Calculates the percentile value from the given list ordered in a non-descending order using a quantile scale and reports it as a number.", "Reports the percentile value from the given list ordered in a non-descending order using a quantile scale to allow reporting of percentile values such as p99.9.", "Reports the percentile value from the given list ordered in a non-descending order using a quantile scale to allow reporting of percentile values such as p99.9.", "Reports the percentile value from the given list ordered in a non-descending order using quantile scale and allows reporting of percentile values such as p99.9.", "Calculates the percentile value from the given list ordered in a non-descending order by using the quantile scale and reports the value according to the provided percentile."]}
{"SampleId": 3571800, "Origin": "Marks {@code protoMember}, throwing if it is explicitly excluded, or if its enclosing type is\nalso specifically included.", "Reference": "Marks {@code protoMember}, throwing if it is explicitly excluded.", "LLMCandidates": ["Marks {@code protoMember}, throwing if it is explicitly excluded, or if its enclosing type is also specifically included.", "Marks protoMember, throwing if it is explicitly excluded, or if its enclosing type is also specifically included.", "Marks {@code protoMember}, throwing if it is explicitly excluded, or if its enclosing type is not yet included in the collection of types.", "Marks {@code protoMember}, throwing if it is explicitly excluded, or if its enclosing type is also specifically included.", "Marks {@code protoMember}, throwing if it is explicitly excluded, or if its enclosing type is already specifically included."]}
{"SampleId": 4003565, "Origin": "This option allows to configure each configuration file based on the  location.", "Reference": "This option allows to configure each configuration fille based on the karaf.home location.", "LLMCandidates": ["This option allows to configure each configuration file based on the location.", "This option allows to configure each configuration file based on the location of the ConfigurationPointer parameter.", "This option allows to configure each configuration file based on the location.", "This option allows to configure each configuration file based on the location using the given ConfigurationPointer and value.", "This option allows to configure each configuration file based on the location using the given ConfigurationPointer and value."]}
{"SampleId": 6364977, "Origin": "Get all the jobs present in the wiki.", "Reference": "Get all the intervals/jobs present in the wiki.", "LLMCandidates": ["Initialize the intervals cache using REALTIME_INTERVAL_ID and sort them by cron expression before adding to the list of intervals.", "Get all the intervals present in the wiki.", "Initialize the intervals cache. Get all the watchlist job documents from the main wiki. Sort them by cron expression. Add them to the list of intervals. Initialize the subscribers cache for each interval.", "Initialize all the watchlist intervals present in the wiki.", "Get all the intervals present in the wiki."]}
{"SampleId": 5322278, "Origin": "Return a single {@link ReflectiveMethodResolver}.", "Reference": "Return the specified {@link MethodResolver} delegates, if any.", "LLMCandidates": ["Return a list of {@link MethodResolver} objects.", "Return a list of {@link MethodResolver}s.", "Return a list of {@link MethodResolver}s.", "Return a list of {@link MethodResolver}s.", "Return a list of {@link MethodResolver}s."]}
{"SampleId": 5360748, "Origin": "This is useful for typical \nblocks in manual JavaMail code.", "Reference": "blocks in manual JavaMail code.", "LLMCandidates": ["This is useful for typical blocks in manual JavaMail code.", "This is useful for typical blocks in manual JavaMail code, especially when using the LOGGER.debug() method to handle exceptions during service closure.", "This is useful for typical blocks in manual JavaMail code, closing a Service instance gracefully.", "This is useful for typical blocks in manual JavaMail code.", "This is useful for typical blocks in manual JavaMail code."]}
{"SampleId": 575173, "Origin": "Two objects are considered different if\n{@code value.compareTo(reference) != 0}", "Reference": "Two objects are considered different if\n{@code value.equals(reference) == false}", "LLMCandidates": ["Two objects are considered different if {@code value.equals(reference)} is false.", "Two objects are considered different if {@code value.equals(reference)} is false.", "Two objects are considered different if {@code value.equals(reference)} is false.", "Two objects are considered different if {@code value.equals(reference) != 0", "Two objects are considered different if {@code value.equals(reference) != true"]}
{"SampleId": 2732385, "Origin": "Expands all tree nodes in a single call.", "Reference": "Expands all tree nodes.", "LLMCandidates": ["Expands all tree nodes recursively using expandAllImpl(root, parent, Integer.MAX_VALUE).", "This method recursively expands all tree nodes in a single call.", "Expands all tree nodes in a single call, using the expandAllImpl helper method to perform recursive expansions down the hierarchy.", "Expands all tree nodes in a single call using expandAllImpl method with root node and maximum depth as parameters.", "Expands all tree nodes in a single call using a helper method expandAllImpl with root node and max level parameters."]}
{"SampleId": 235252, "Origin": "Tests for defaults {@link CreateOptions}.", "Reference": "Tests for defaults {@link GetWorkerOptions}.", "LLMCandidates": ["Tests for defaults {@link GetWorkerOptions} with setBlockInfo(new BlockInfo()).", "Tests for defaults {@link GetWorkerOptions}.", "Tests for defaults {@link GetWorkerOptions}.", "Tests for defaults {@link GetWorkerOptions}.", "Tests for defaults {@link GetWorkerOptions}."]}
{"SampleId": 2337171, "Origin": "Modified by user info", "Reference": "Modified by user", "LLMCandidates": ["@ApiModelProperty(value = \"Modified by user\") public UserInfo getNodeUpdatedBy()", "The content of the modified Javadoc comment is: \"Modified by user", "Modified by user", "Modified by user", "Modified by user"]}
{"SampleId": 2913748, "Origin": "Obtains an instance from the specified unique name.", "Reference": "Obtains an instance from the specified name.", "LLMCandidates": ["Obtains an instance from the specified unique name (parameter 'name') using a mapping table.", "Obtains an instance from the specified unique name.", "Obtains an instance from the specified unique name.", "Obtains an instance from the specified name.", "Obtains an instance from the specified name."]}
{"SampleId": 4476805, "Origin": "The {@link EcKeyCreateOptions#getCurve() key curve} can be\noptionally specified.", "Reference": "The {@link CreateEcKeyOptions#getCurveName() key curve} can be\noptionally specified.", "LLMCandidates": ["The {@link CreateEcKeyOptions#getCurve() key curve} can be optionally specified.", "The {link CreateEcKeyOptions#getCurve() key curve} can be optionally specified.", "The {@link CreateEcKeyOptions#getCurve() key curve} can be optionally specified.", "The {@link CreateEcKeyOptions#getCurve() key curve} can be optionally specified.", "The {@link CreateEcKeyOptions#getCurve() key curve} can be optionally specified."]}
{"SampleId": 5841424, "Origin": "Used by track model container (e.g.", "Reference": "Only exposed to track model container (e.g.", "LLMCandidates": ["Used by track model container (Builder of M and R) to set the ID.", "Set the initial value by adding 8 to n.", "Set the initial value by adding 8 to n.", "Set the track model's identifier by providing an integer value.", "Set the track model's identifier by providing an integer value."]}
{"SampleId": 4388477, "Origin": "IMPORTANT: The source DB instance must have backup retention\nenabled.", "Reference": "The source DB instance must have backup retention enabled.", "LLMCandidates": ["The source DB instance must have backup retention enabled.", "The source DB instance must have backup retention enabled and support read replicas.", "The source DB instance must have backup retention enabled.", "The source DB instance must have backup retention enabled.", "The source DB instance must have backup retention enabled for a read replica to be created."]}
{"SampleId": 340614, "Origin": "Requests that the player prefetch the media items for playback.", "Reference": "Requests that the player prepare the media items for playback.", "LLMCandidates": ["Requests that the player prepare the media items for playback.", "Requests that the player prepare the media items for playback.", "Requests that the player prepare the media items for playback.", "Requests that the player prepare the media items for playback.", "Requests that the player prepare the media items for playback."]}
{"SampleId": 4383857, "Origin": "Getting Search Suggestions \nin the Amazon CloudSearch Developer Guide .", "Reference": "CloudSearch Developer Guide.", "LLMCandidates": ["This method is used to delete suggestions from Amazon CloudSearch. It takes a DeleteSuggesterRequest object as input and returns a DeleteSuggesterResult object. The request is marshalled and invoked using an appropriate StaxResponseHandler, then the response's AwsResponse is returned.", "Deletes a suggester for an index using the DeleteSuggester request and receives a DeleteSuggesterResult response.", "This method deletes suggestions from the Amazon CloudSearch system, following a given DeleteSuggesterRequest.", "Deletes a suggestion from the Amazon CloudSearch index, using the DeleteSuggesterRequest object and AWS request metrics for performance tracking.", "Deletes an existing suggester for a search domain using AWS CloudSearch service."]}
{"SampleId": 6017980, "Origin": "Computes the minimum for each pixel across all bands in the {@link Planar} image.", "Reference": "Computes the minimum for each pixel across selected bands in the {@link Planar} image.", "LLMCandidates": ["Computes the minimum for each pixel across all bands in the {@link Planar} image, with the output reshaped to have the same dimensions as the input.", "Computes the minimum for each pixel across all bands in the {@link Planar} image. The output image is initialized with the same width and height as the input image.", "Computes the minimum for each pixel across all bands in the {@link Planar} image, and reshapes the output to match the input dimensions.", "Computes the minimum for each pixel across all bands in the {@link Planar} image, reshaping the output to match the input dimensions before performing the operation.", "Computes the minimum for each pixel across all bands in the {@link Planar} image. After computing, reshapes the output to match the dimensions of the input image."]}
{"SampleId": 2891419, "Origin": "Sets current date as e-mails sent date.", "Reference": "Sets current date as the sent date.", "LLMCandidates": ["Sets the current date as e-mail's sent date by returning a new instance with the updated value.", "Sets current date as e-mails sent date by setting the sentDate to a new Date().", "Sets current date as e-mails sent date using a setter method.", "Sets current date as e-mails sent date, using the internal method setSentDate() to achieve this.", "Sets current date as e-mails sent date, using the internal method setSentDate() to achieve this."]}
{"SampleId": 3242248, "Origin": "Sets the value of the cryptAlgorithmType property.", "Reference": "Sets the value of the algorithmName property.", "LLMCandidates": ["Sets the value of the algorithmName property.", "Sets the value of the algorithmName property.", "Sets the value of the algorithmName property.", "Sets the value of the algorithmName property.", "Sets the value of the algorithmName property."]}
{"SampleId": 4470108, "Origin": "In case of\nfailure the {@link Flux} will error.", "Reference": "In case of\nfailure the {@link CosmosContinuablePagedFlux} will error.", "LLMCandidates": ["The {@link CosmosContinuablePagedFlux} will return a paged flux of all users based on the given options. In case of failure, the {@link Flux} will error.", "In case of failure the {@link CosmosContinuablePagedFlux} will error.", "In case of failure the {@link CosmosContinuablePagedFlux} will error.", "In case of failure the {@link CosmosContinuablePagedFlux} will error.", "In case of failure the {@link CosmosContinuablePagedFlux} will error."]}
{"SampleId": 3038914, "Origin": "Adds a network interface (aka port) into a given bridge of openstack node.", "Reference": "Adds or removes a network interface (aka port) into a given bridge of openstack node.", "LLMCandidates": ["Adds or removes a network interface (aka port) into a given bridge of openstack node based on the addOrRemove flag.", "Adds or removes a network interface (aka port) into a given bridge of openstack node based on the \"addOrRemove\" boolean parameter.", "Adds or removes a network interface (aka port) into a given bridge of openstack node, based on the specified action (addOrRemove).", "Adds or removes a network interface (aka port) into a given bridge of openstack node based on addOrRemove flag.", "Adds or removes a network interface (aka port) into a given bridge of openstack node based on the addOrRemove parameter."]}
{"SampleId": 754537, "Origin": "Sets the amount of time, in milliseconds, to wait between\nadjustments in pool sizes for a given host, to allow\nenough time for the adjustments to take effect.", "Reference": "Sets the amount of time to wait between adjustments in\npool sizes for a given host, to allow enough time for\nthe adjustments to take effect.", "LLMCandidates": ["Sets the amount of time to wait between adjustments in pool sizes for a given host, using a TimeValue object instead of milliseconds, to allow enough time for the adjustments to take effect.", "Sets the amount of time, in milliseconds, to wait between adjustments in pool sizes for a given host, to allow enough time for the adjustments to take effect.", "Sets the amount of time to wait between adjustments in pool sizes for a given host, allowing enough time for the adjustments to take effect using the provided TimeValue object.", "Sets the amount of time, in milliseconds, to wait between adjustments in pool sizes for a given host, to allow enough time for the adjustments to take effect.", "Sets the amount of time, in milliseconds, to wait between adjustments in pool sizes for a given host, to allow enough time for the adjustments to take effect using a TimeValue object."]}
{"SampleId": 1122902, "Origin": "Constuct a trace log event.", "Reference": "Constuct a fatal log event.", "LLMCandidates": ["Construct a fatal log event.", "Constructs a fatal log event if fatal logging is enabled; otherwise, returns the noop builder.", "Construct a fatal log event if the level is enabled, otherwise return the default noop builder.", "Construct a fatal log event if the level is enabled, otherwise return the default noop builder.", "Constructs a fatal log event if the level is enabled, otherwise returns LogBuilder.NOOP."]}
{"SampleId": 2230469, "Origin": "Returns the QuorumConfig for the given name, creating one\nif necessary and adding it to the collection of known configurations.", "Reference": "Returns the {@link SplitBrainProtectionConfig} for the given name, creating one\nif necessary and adding it to the collection of known configurations.", "LLMCandidates": ["Returns the SplitBrainProtectionConfig for the given name, creating one if necessary and adding it to the collection of known configurations.", "Returns the SplitBrainProtectionConfig for the given name, creating one if necessary and adding it to the collection of known configurations.", "Returns the SplitBrainProtectionConfig for the given name, creating one if necessary and adding it to the collection of known configurations.", "Returns the SplitBrainProtectionConfig for the given name, creating one if necessary and adding it to the collection of known configurations.", "Returns the SplitBrainProtectionConfig for the given name, creating one if necessary and adding it to the collection of known configurations."]}
{"SampleId": 5447619, "Origin": "timed invokeAll(,,null) throws NPE", "Reference": "timed invokeAll(,,null) throws NullPointerException", "LLMCandidates": ["Testing the invocation of all tasks with a random timeout and null time unit.", "Test that invokeAll(, randomTimeout(), null) throws NPE.", "Test that invokeAll(, randomTimeout(), null) throws NPE.", "Invoke all tasks with a random timeout and check for a NullPointerException", "Invoke all tasks with a random timeout and check for a NullPointerException"]}
{"SampleId": 2081832, "Origin": "All {@link ForeignKeyIndex} types\n  {@link DomainApplicationIndex}\n  {@link EppResourceIndex}", "Reference": "All {@link ForeignKeyIndex} types\n  {@link EppResourceIndex}", "LLMCandidates": ["All {@link ForeignKeyIndex} types, {@link DomainApplicationIndex}, and {@link EppResourceIndex", "All {@link ForeignKeyIndex} types including {@link EppResourceIndex} and {@link DomainApplicationIndex}.", "All {@link ForeignKeyIndex} types, including {@link DomainApplicationIndex} and {@link EppResourceIndex}.", "All {@link ForeignKeyIndex} types, including {@link DomainApplicationIndex} and {@link EppResourceIndex}.", "@inheritDoc} All {@link ForeignKeyIndex} types\n  {@link DomainApplicationIndex}\n  {@link EppResourceIndex"]}
{"SampleId": 2630413, "Origin": "This method checks if the region of {@code path} starting\nat {@code pathOffset} matches the path segments in {@code segments}.", "Reference": "This method checks if the region of {@code path} starting\nat {@code pathOffset} matches the path pathSegments in {@code pathSegments}.", "LLMCandidates": ["This method checks if the region of {@code path} starting at {@code pathOffset} matches the path segments in {@code pathSegments}.", "This method checks if the region of {@code path} starting at {@code pathOffset} matches the path segments in {@code pathSegments}.", "This method checks if the region of {@code path} starting at {@code pathOffset} matches the path segments in {@code pathSegments}.", "This method checks if the region of {@code path} starting at {@code pathOffset} matches the path segments in {@code pathSegments}.", "This method checks if the region of path starting at pathOffset matches the path segments in pathSegments."]}
{"SampleId": 5243394, "Origin": "Indicates whether this filter needs to use the secondary, non-SQL method getMatchingFiles().", "Reference": "Indicates whether this filter needs to use the secondary, non-SQL method applyAlternateFilter().", "LLMCandidates": ["Indicates whether this filter needs to use the secondary, non-SQL method getAlternateFiles().", "Indicates whether this filter needs to use the secondary, non-SQL method getMatchingFiles().", "Indicates whether this filter needs to use the secondary, non-SQL method getAlternateFiles().", "Indicates whether this filter needs to use the secondary, non-SQL method getMatchingFiles().", "Indicates whether this filter needs to use the secondary, non-SQL method getAlternateFiles()."]}
{"SampleId": 338759, "Origin": "This only functions after we have been attached to a hierarchy.", "Reference": "This only works after this preference has been attached to a hierarchy.", "LLMCandidates": ["This only functions after we have been attached to a hierarchy with a non-empty key.", "This only functions after we have been attached to a hierarchy, and the key is not empty.", "This only functions after we have been attached to a hierarchy, and the key is not empty.", "This only functions after we have been attached to a hierarchy. However, it now includes a nullability check for key and a return statement for the case where mPreferenceManager is not available.", "This only functions after we have been attached to a hierarchy."]}
{"SampleId": 4476777, "Origin": "The {@link RsaKeyCreateOptions#getKeyType() keyType} indicates the type of key to create.", "Reference": "The {@link CreateRsaKeyOptions#getKeyType() keyType} indicates the type of key to create.", "LLMCandidates": ["The {@link CreateRsaKeyOptions#getKeyType() keyType} indicates the type of key to create.", "The {@link CreateRsaKeyOptions#getKeyType() keyType} indicates the type of key to create.", "The {@link CreateRsaKeyOptions#getKeyType() keyType} indicates the type of key to create.", "The {@link CreateRsaKeyOptions#getKeyType() keyType} indicates the type of key to create.", "The {@link CreateRsaKeyOptions#getKeyType() keyType} indicates the type of key to create."]}
{"SampleId": 2544520, "Origin": "Set this {@link AxisAngle4f} to be equivalent to the given\n{@link Quaterniond}.", "Reference": "Set this {@link AxisAngle4f} to be equivalent to the given\n{@link Quaterniondc}.", "LLMCandidates": ["Set this {@link AxisAngle4f} to be equivalent to the given {@link Quaterniondc}.", "Set this {@link AxisAngle4f} to be equivalent to the given {@link Quaterniondc}.", "Set this {@link AxisAngle4f} to be equivalent to the given {@link Quaterniondc}.", "Set this {@link AxisAngle4f} to be equivalent to the given {@link Quaterniondc}.", "Set this {@link AxisAngle4f} to be equivalent to the given {@link Quaterniondc}."]}
{"SampleId": 4132953, "Origin": "Create or obtain a {@link CallableStatement} from the pool.", "Reference": "Creates or obtains a {@link CallableStatement} from the pool.", "LLMCandidates": ["Obtain a {@link CallableStatement} from the pool.", "Create or obtain a {@link CallableStatement} from the pool.", "Create or obtain a {@link CallableStatement} from the pool.", "Obtain or create a {@link CallableStatement} from the pool.", "Obtain or create a {@link CallableStatement} from the pool."]}
{"SampleId": 5454969, "Origin": "If the JAR file has a {@code Main-Class} attribute in its\n    main manifest then its value is the {@link", "Reference": "If the JAR file has a {@code Main-Class} attribute in its\n    main manifest then its value is the module {@link", "LLMCandidates": ["Create a ModuleFinder instance based on given Path entries. If no entries are provided, return an empty ModuleFinder.", "Return a ModuleFinder that finds modules based on a list of Path entries. If there are no entries, return an empty ModuleFinder.", "Creates a ModuleFinder based on a list of Path entries. If there are no entries, an empty ModuleFinder is returned. Otherwise, a ModulePath with the given entries is created and used as the ModuleFinder.", "/** \n * Create a new ModuleFinder from the given paths. If there are no paths provided, an empty ModuleFinder is returned. Otherwise, a new ModulePath instance is created and used as the underlying ModuleFinder implementation. \n */", "Finds a module path using the given Path entries. If there are no entries provided, an empty ModuleFinder is returned. Otherwise, the ModulePath constructor is used to create a new ModuleFinder object based on the given entries."]}
{"SampleId": 3773945, "Origin": "It is used for\nadapting this data provider to a filter type provided by a Component such\nas ComboBox.", "Reference": "This can be used for adapting this data provider to a filter\ntype provided by a Component such as ComboBox.", "LLMCandidates": ["It is used for adapting this data provider to a filter type provided by a Component such as ComboBox with the help of a filter converter.", "It is used for adapting this data provider to a filter type provided by a Component such as ComboBox with the help of a converter.", "Converts this data provider's filter to a new type using the given converter function, adapting it for usage in components such as ComboBox.", "It is used for adapting this data provider to a filter type provided by a Component such as ComboBox. The updated method signature now takes in a converter function that changes the filter type. This allows the data provider to work with different types of filters seamlessly.", "This method is used for adapting this data provider to a filter type provided by a Component such as ComboBox. It takes a SerializableFunction and applies it to the original filter before passing it on to the underlying data provider. The filter converter must not be null."]}
{"SampleId": 2482494, "Origin": "Creates query for the given queryString.", "Reference": "Queries this search source for the given queryString.", "LLMCandidates": ["Creates query for the given queryString with a default value of -1 for pageNumber.", "Queries the contact source for the given queryString and optional page index.", "Creates query for the given queryString.", "Creates query for the given queryString.", "Creates query for the given queryString using the provided limit."]}
{"SampleId": 4132958, "Origin": "Create or obtain a {@link PreparedStatement} from the pool.", "Reference": "Creates or obtains a {@link PreparedStatement} from the pool.", "LLMCandidates": ["Obtain or create a {@link PreparedStatement} from the pool based on the provided sql, resultSetType, resultSetConcurrency, and resultSetHoldability parameters.", "Obtain a {@link PreparedStatement} from the pool based on the given sql, resultSetType, resultSetConcurrency and resultSetHoldability.", "Create or obtain a PreparedStatement from the pool based on the provided SQL statement, result set type, concurrency, and holdability.", "Obtain a {@link PreparedStatement} from the pool, based on the given SQL, resultSetType, resultSetConcurrency, and resultSetHoldability parameters.", "Create or obtain a PreparedStatement from the pool by using the provided key (sql, resultSetType, resultSetConcurrency, resultSetHoldability)."]}
{"SampleId": 437930, "Origin": "Creates a {@link MetadataCoder}.", "Reference": "Returns the singleton {@link MetadataCoder} instance.", "LLMCandidates": ["Creates an instance of {@link MetadataCoder} using a static factory method.", "Creates a {@link MetadataCoder} using the singleton pattern.", "Creates a {@link MetadataCoder} using the singleton pattern.", "Creates an instance of {@link MetadataCoder}.", "Creates a {@link MetadataCoder}."]}
{"SampleId": 84963, "Origin": "Inserts the node at the tail of the frontier.", "Reference": "Primitive operation which inserts the node at the tail of the frontier.", "LLMCandidates": ["Inserts a node at the end of the frontier and updates metrics accordingly.", "Inserts a node into the end of the frontier and updates the metrics accordingly.", "Inserts the node at the front of the frontier.", "Inserts the node at the front of the frontier.", "Inserts a new node at the front of the queue, and updates the metrics accordingly."]}
{"SampleId": 2049500, "Origin": "Returns the codec's supported type for decoding {@code requestedMimeType} on the current\ndevice, or {@code null} if the codec can't be used.", "Reference": "Returns the codec's supported MIME type for media of type {@code mimeType}, or {@code null} if\nthe codec can't be used.", "LLMCandidates": ["Returns the codec's supported MIME type for decoding {@code mimeType} on the current device, or {@code null} if the codec can't be used.", "Returns the codec's supported MIME type for decoding {@code mimeType} on the current device, or {@code null} if the codec can't be used.", "Returns the codec's supported type for decoding {@code mimeType} on the current device, or {@code null} if the codec can't be used.", "Returns the codec's supported type for decoding {@code mimeType} on the current device, or {@code null} if the codec can't be used.", "Returns the codec's supported type for decoding {@code mimeType} on the current device, or {@code null} if the codec can't be used."]}
{"SampleId": 1353937, "Origin": "Remove all free glyphs that are assigned the provided group.", "Reference": "Remove all free glyphs that are only assigned the provided group.", "LLMCandidates": ["Remove all free glyphs that are assigned the provided group.", "Remove all free glyphs that are assigned the provided group by checking if the glyph's groups contain the given group and then removing it from the iterator.", "Removes all free glyphs that are assigned the provided group from the list of free glyphs.", "Remove all free glyphs that are assigned the provided group.", "Remove all free glyphs that are assigned the provided group."]}
{"SampleId": 5219060, "Origin": "Add insert optimize result uint.", "Reference": "Add insert optimize result unit into units.", "LLMCandidates": ["Add an insert optimize result unit to the list.", "Add insert optimize result unit to the collection.", "Add insert optimize result unit to the collection.", "Add insert optimize result unit to the collection.", "Add insert optimize result unit to the collection."]}
{"SampleId": 6050238, "Origin": "Returns the tasks entry with the primary key or throws a {@link com.liferay.tasks.NoSuchTasksEntryException} if it could not be found.", "Reference": "Returns the tasks entry with the primary key or throws a {@link NoSuchTasksEntryException} if it could not be found.", "LLMCandidates": ["Finds the tasks entry with the given primary key or throws a {@link com.liferay.tasks.NoSuchTasksEntryException} if not found.", "Returns the tasks entry with the primary key or throws a {@link com.liferay.tasks.NoSuchTasksEntryException} if it could not be found.", "Finds the tasks entry with the specified primary key or throws a {@link com.liferay.tasks.NoSuchTasksEntryException} if it could not be found.", "Returns the tasks entry with the primary key or throws a {@link com.liferay.tasks.NoSuchTasksEntryException} if it could not be found.", "Returns the tasks entry with the primary key or throws a {@link com.liferay.tasks.NoSuchTasksEntryException} if it could not be found."]}
{"SampleId": 5015241, "Origin": "If no sld file, throws an exception", "Reference": "If no sld file, throws an appropriate exception", "LLMCandidates": ["Checks if an sld file exists, throws an exception if not.", "Returns an sld file from the given directory or throws an exception if no sld file is found", "If no sld file provided, throws an exception", "If no sld file provided, throws an exception", "Throws an exception if no sld file is provided"]}
{"SampleId": 3574224, "Origin": "Use this method if setting this option is not required and to express that it may be .", "Reference": "Builds the option and marks it as not required  Use this method if setting this option is not required and\nto express that it may be .", "LLMCandidates": ["Use this method if setting this option is not required and to express that it may be; it returns a ConfigurationOption with Optional<T> data type.", "Use this method if setting this option is not required and to express that it may be Optional.", "Use this method if setting this option is not required and to express that it may be. Use this method if setting this option is not required and to express that it may be.", "This method should be used if setting this option is not required, or to express that it may be optional. It initializes the ConfigurationOption with an Optional value type and a list of additional parameters, such as change listeners, validators, and tags. The required attribute is set to false by default.", "Use this method if setting this optional option is not required and to express that it may be."]}
{"SampleId": 3239399, "Origin": "Gets the value of the descrption property.", "Reference": "Gets the value of the description property.", "LLMCandidates": ["Gets the value of the description property.", "Gets the value of the description property.", "Gets the value of the description property.", "Gets the value of the description property.", "Gets the value of the description property."]}
{"SampleId": 3814021, "Origin": "Gets the amount of available items in the network of the type passed in, checking NBT or not.", "Reference": "Gets the number of available items in the network satisfying the given matcher.", "LLMCandidates": ["Gets the amount of available items in the network matching the given request matcher, checking NBT or not.", "Gets the amount of available items in the network matching the specified criteria, checking NBT or not.", "Gets the amount of available items in the network matching the specified criteria, checking NBT or not.", "Gets the amount of items in the network that match the given filter in the type passed in.", "Gets the amount of items in the network that match the given CorporeaRequestMatcher, checking all inventories."]}
{"SampleId": 2641058, "Origin": "This makes it\nhard to debug because if task throws an exception, its call stack ends in the execution engine that actually\nstarts a thread that serves the task.", "Reference": "This makes it\nhard to debug because if a task throws an exception, its call stack ends in the execution engine that actually\nstarts a thread that serves the task.", "LLMCandidates": ["This makes it harder to debug because if a task throws an exception, its call stack ends in the execution engine that actually starts a thread that serves the task.", "This makes it hard to debug because if a task throws an exception, its call stack ends in the execution engine that actually starts a thread that serves the task.", "This makes it hard to debug because if a task throws an exception, its call stack ends in the execution engine that actually starts a thread that serves the task.", "This makes it hard to debug because if a task throws an exception, its call stack ends in the execution engine that actually starts a thread that serves the task.", "This makes it hard to debug because if an exception is thrown, its call stack ends in the execution engine that actually starts a thread that serves the task."]}
{"SampleId": 5300344, "Origin": "Creates new {@link DayOfMonth} in UTC.", "Reference": "Creates new {@link DayOfMonth}.", "LLMCandidates": ["Creates new {@link DayOfMonth} with given expression in UTC.", "Creates new {@link DayOfMonth} based on the given expression in UTC.", "Creates new {@link DayOfMonth} in UTC with added validation for a non-null expression.", "Creates new {@link DayOfMonth} from the given {@link AggregationExpression}. This method ensures that the Expression is not null before processing.", "Creates new {@link DayOfMonth} using the given {@link AggregationExpression}. The expression must not be null! The method will utilize the provided expression to generate a new instance of {@link DayOfMonth}."]}
{"SampleId": 5629938, "Origin": "Sets the entities.", "Reference": "Set the entities.", "LLMCandidates": ["Sets the entities list using a builder pattern.", "Sets the entities using a builder pattern.", "Sets the entities using a builder pattern.", "Builds the entities list using the provided RuntimeEntity instances.", "Builds the entities list using the provided RuntimeEntity instances."]}
{"SampleId": 471391, "Origin": "The option is a:\n type.", "Reference": "The option is a:", "LLMCandidates": ["This method is used to set the property \"cxfRsConfigurer\" with the given value and return this object.", "The option is a: type.", "The option is a: type.", "The option is a: type.", "The option is a: AdvancedCxfRsEndpointBuilder.type."]}
{"SampleId": 3105257, "Origin": "Test of from method, of class Statistics.", "Reference": "Test of fromJson method, of class Statistics.", "LLMCandidates": ["Test of fromJson method, of class Statistics, using JSON string and JsonFactory/JsonGenerator to deserialize.", "Test of fromJson method, of class Statistics. The test now reads a JSON string and creates an instance of Statistics by parsing the JSON string.", "Test of from method, of class Statistics with an additional step of parsing JSON string using JsonFactory and JsonGenerator.", "Test of fromJson method, of class Statistics with JSON input.", "Test of fromJson method, of class Statistics with JSON input."]}
{"SampleId": 438097, "Origin": "Infer a {@link Schema} from an AVRO-generated SpecificRecord.", "Reference": "Infer a {@link Schema} from either an AVRO-generated SpecificRecord or a POJO.", "LLMCandidates": ["Infer a {@link Schema} from an AVRO-generated SpecificRecord.", "Infer a {@link Schema} from an AVRO-generated SpecificRecord, with method signature <T> Schema getSchema(Class<T> clazz).", "Infer a {@link Schema} from an AVRO-generated SpecificRecord or general class by getting it from ReflectData.", "Infer a {@link Schema} from an AVRO-generated SpecificRecord using ReflectData.get().getSchema(clazz).", "Infer a {@link Schema} from an AVRO-generated SpecificRecord without using ReflectData or accessing any private fields."]}
{"SampleId": 4617594, "Origin": "Deletes the element at the specified position.", "Reference": "Removes the element at the specified position.", "LLMCandidates": ["Deletes the element at the specified position; updates the size of the array accordingly.", "Removes the element at the specified position and updates the size of the list.", "Removes the element at the specified position and updates the size of the list.", "Deletes the element at the specified position, modifying the list size and returning the removed element.", "Deletes the element at the specified position, maintaining the array's integrity."]}
{"SampleId": 2017357, "Origin": "Creates an empty object literal, `{}`.", "Reference": "Creates an object-literal with zero or more elements, `{}`.", "LLMCandidates": ["Creates an object literal with optional elements, `{}`.", "Creates an object literal with optional elements, `{}`.", "Creates an object literal with elements, `{}`.", "Creates an object literal with elements, `{}`.", "Creates an object literal with optional elements, `{}` (with optional parameters)."]}
{"SampleId": 3195611, "Origin": "Creates an iterable that iterates in parallel over a three iterables.", "Reference": "Creates an iterable that iterates in parallel over three iterables.", "LLMCandidates": ["Creates an iterable that iterates in parallel over three iterables, ensuring that they all have elements and return a Tuple3 when calling next().", "Creates an iterable that iterates in parallel over three iterables, ensuring they all have the same number of elements before proceeding.", "Creates an iterable that iterates in parallel over a three iterables with assertions on size mismatch removed and improved efficiency for the hasNext method and next call.", "Creates an iterable that iterates in parallel over a three iterables without checking for size mismatch.", "Creates an iterable that iterates in parallel over three iterables without checking for size mismatch."]}
{"SampleId": 2939899, "Origin": "Initializes this.audioFormats", "Reference": "Initializes audioFormats", "LLMCandidates": ["Initializes the audioFormats by iterating through the available audio formats provided by voiceRssImpl and adding each to the collection.", "Initializes the audioFormats by adding availableAudioFormats from voiceRssImpl.", "Initializes this.audioFormats by adding formats from voiceRssImpl.getAvailableAudioFormats().", "Initializes the audio formats by iterating through the available formats provided by voiceRssImpl and adding each format to the Set of AudioFormats.", "Initializes a Set of AudioFormats by iterating through available formats and adding them to the Set."]}
{"SampleId": 4396424, "Origin": "Returns a string representation of this object; useful for testing and debugging.", "Reference": "Returns a string representation of this object.", "LLMCandidates": ["Returns a string representation of this object; useful for testing and debugging, where sensitive data is redacted by replacing it with \"***Sensitive Data Redacted***\" in the result.", "Returns a string representation of this object; useful for testing and debugging. This version now hides sensitive data like phone numbers for security.", "Returns a string representation of this object; useful for testing and debugging, with sensitive data redacted.", "Returns a string representation of this object, useful for testing and debugging; sensitive data is redacted by replacing it with \"***Sensitive Data Redacted***\".", "Returns a string representation of this object; useful for testing and debugging. The PhoneNumber is now redacted by printing \"***Sensitive Data Redacted***\" to maintain privacy."]}
{"SampleId": 1328641, "Origin": "Sets the partition storage level.", "Reference": "Sets the storage configuration.", "LLMCandidates": ["Sets the partition storage configuration.", "Sets the partition storage configuration.", "Sets the partition storage configuration.", "Sets the partition storage configuration.", "Sets the partition storage configuration."]}
{"SampleId": 1880371, "Origin": "Testing the isSPD (is symmetric positive definite) method of CholeskyDecomposition class.", "Reference": "Testing the isSPD (is symmetric positive definite) method of", "LLMCandidates": ["Testing the isSPD (is symmetric positive definite) method of CholeskyDecomposition class, and checking for correct classification of SPD and non-SPD matrices.", "Testing the isSPD (is symmetric positive definite) method of CholeskyDecomposition class using various matrices and assertions for correctness.", "Testing the isSPD (is symmetric positive definite) method of CholeskyDecomposition class using various input matrices.", "Testing the isSPD (is symmetric positive definite) method of CholeskyDecomposition class using different input matrices to check if they are symmetric and positive definite.", "Testing the isSPD (is symmetric positive definite) method of CholeskyDecomposition class for various input matrices."]}
{"SampleId": 1388665, "Origin": "showIndex.", "Reference": "showTagArticles.", "LLMCandidates": ["Test a page with the title \"Solo - Solo \".", "This test method verifies that the application displays a page with the specified title when accessing a URL with the /tags/Solo path. It does this by setting up a mock request and response, initializing the MockDispatcherServlet, and checking if the content contains the given title.", "Test a method that checks if the title \"Solo - Solo \" is displayed when GET request is made to \"/tags/Solo\".", "showTagArticles", "showTagArticles"]}
{"SampleId": 440279, "Origin": "Creates an instance of {@link RowFactory} using provided {@link RowTypeFactory}\nand {@link GetterFactory}.", "Reference": "Creates an instance of {@link RowFactory} using provided {@link SchemaFactory}\nand {@link GetterFactory}.", "LLMCandidates": ["Creates an instance of {@link RowFactory} using provided {@link SchemaFactory} and {@link GetterFactory}.", "Creates an instance of {@link RowFactory} using provided {@link SchemaFactory} and {@link GetterFactory}.", "Creates an instance of {@link RowFactory} using provided {@link SchemaFactory} and {@link GetterFactory}.", "Creates an instance of {@link RowFactory} using provided {@link SchemaFactory} and {@link GetterFactory}.", "Creates an instance of {@link RowFactory} using provided {@link SchemaFactory} and {@link GetterFactory}."]}
{"SampleId": 5360344, "Origin": "Create an {@link RSocketOutboundGatewaySpec} builder for request-reply gateway\nbased on provided {@code route}.", "Reference": "Create an {@link RSocketOutboundGatewaySpec} builder for request-reply gateway\nbased on provided {@code route} and optional variables to expand route template.", "LLMCandidates": ["Create an {@link RSocketOutboundGatewaySpec} builder for request-reply gateway based on provided {@code route} and optional {@code routeVariables}.", "Create an {@link RSocketOutboundGatewaySpec} builder for request-reply gateway based on provided {@code route} and {@code routeVariables}.", "Create an {@link RSocketOutboundGatewaySpec} builder for request-reply gateway based on provided {@code route} and optional {@code routeVariables}.", "Create an {@link RSocketOutboundGatewaySpec} builder for request-reply gateway based on provided {@code route}, and optionally with {@code routeVariables}.", "Create an {@link RSocketOutboundGatewaySpec} builder for request-reply gateway based on provided {@code route} and additional {@code routeVariables}."]}
{"SampleId": 2544551, "Origin": "Apply the rotation transformation of the given {@link Quaterniond} to this matrix and store\nthe result in .", "Reference": "Apply the rotation transformation of the given {@link Quaterniondc} to this matrix and store\nthe result in .", "LLMCandidates": ["Apply the rotation transformation of the given {@link Quaterniond} to this matrix and store the result in .", "Apply the rotation transformation of the given {@link Quaterniond} to this matrix and store the result in .", "Apply the rotation transformation of the given {@link Quaterniond} to this matrix and store the result in .", "Apply the rotation transformation of the given {@link Quaterniondc} to this matrix and store the result in .", "Apply the rotation transformation of the given {@link Quaterniond} to this matrix and store the result in ."]}
{"SampleId": 4715990, "Origin": "Constructs a URL to save the data to", "Reference": "Constructs a final path save the data to", "LLMCandidates": ["Constructs a URL for saving data based on the provided input", "Constructs a URL from the given HDFS path to save the data to, considering all necessary transformations and substitutions.", "Constructs a URL with the specified path for saving data, considering file prefix and relation name part of filename if they exist. It then applies substitution using the environment variable (if applicable) and ensures the file has an appropriate extension.", "Constructs a URL from the given hdfsPath, applying necessary substitutions and formatting before appending the file extension.", "Constructs a URL by transforming the input path to the specified format, applying environment substitutions and appending file extensions if necessary."]}
{"SampleId": 613117, "Origin": "Returns the ratio of stack traces indicating back pressure to total\nnumber of sampled stack traces.", "Reference": "Returns the back pressure ratio of the given subtask index.", "LLMCandidates": ["Returns the ratio of stack traces indicating back pressure to total number of sampled stack traces.", "Returns the ratio of stack traces indicating back pressure to total number of sampled stack traces for subTaskBackPressureRatios instead of subTaskBackPressureRatio.", "Returns the ratio of stack traces indicating back pressure to total number of sampled stack traces at a specific index.", "Returns the ratio of stack traces indicating back pressure to total number of sampled stack traces at a specific index.", "Returns the ratio of stack traces indicating back pressure to total number of sampled stack traces, using an array of subTaskBackPressureRatios instead of a single element."]}
{"SampleId": 2913755, "Origin": "Obtains an instance from the specified unique name.", "Reference": "Obtains an instance from the specified name.", "LLMCandidates": ["Obtains an instance from the specified name.", "Obtains an instance from the specified name.", "Obtains an instance from the specified name using the parsing method.", "Obtains an instance from the specified name using the parsing method.", "Obtains an instance from the specified unique name using a custom parser."]}
{"SampleId": 4471188, "Origin": "Prints out the created certificate\nissuer details when a response has been received.", "Reference": "Subscribes to the call and prints out the\nupdated certificate operation details when a response has been received.", "LLMCandidates": ["Creates a new CertificateOperation object based on the provided certificateName and returns it when a response has been received.", "Creates a CertificateOperation object for cancelling a certificate operation and returns it with a response when it has been completed successfully.", "Prints out the canceled certificate operation details when a response has been received.", "Prints out the canceled certificate operation details when a response has been received.", "Cancels a certificate operation and returns the response."]}
{"SampleId": 1730796, "Origin": "Hack to avoid disappearing footer when changing the predefined styles at runtime in Safari", "Reference": "Workaround to avoid disappearing footer when changing the predefined styles at runtime in Safari", "LLMCandidates": ["Hack to avoid disappearing footer when changing the predefined styles at runtime in Safari", "Hack to avoid disappearing footer when changing predefined styles at runtime in Safari", "Hack to avoid disappearing footer when changing predefined styles at runtime in Safari", "Hack to avoid changing footer visibility at runtime in Safari", "Hack to avoid changing footer visibility at runtime in Safari"]}
{"SampleId": 3734023, "Origin": "If the offsets list is empty, then an offset of 0 is used for each array.", "Reference": "If the offsets list is empty, then an offset of 0 is used for each\nsequence.", "LLMCandidates": ["If the offsets list is empty, then an offset of 0 is used for each sequence.", "The offsets list is empty, then an offset of 0 is used for each sequence. If the offsets list is not empty, then the number of sequences must be equal to the number of offsets. For each pair of a sequence and its corresponding offset, an OffsetEquation object is created from the given Java expression. If there's any error in the expression, an UpperBoundUnknownQualifier with UNKNOWN value is returned.", "If the offsets list is empty, then an offset of 0 is used for each sequence.", "If the offsets list is empty, then an offset of 0 is used for each sequence.", "If the offsets list is empty, then an offset of 0 is used for each sequence."]}
{"SampleId": 5179883, "Origin": "Indicates if the way is ready to handle new messages.", "Reference": "Indicates if the way is available to handle new messages.", "LLMCandidates": ["Indicates if the way is available to handle new messages.", "Indicates if the way is available to handle new messages.", "Indicates if the way is available to handle new messages.", "Indicates if the way is available to handle new messages.", "Indicates if the way is available to handle new messages."]}
{"SampleId": 3038653, "Origin": "Handles an iterate commit.", "Reference": "Handles an iterator next commit.", "LLMCandidates": ["Handles a next commit for an iterator. It returns an IteratorBatch object containing the key-value pairs and the current position of the iterator.", "Handles a next commit for an iterator.", "Handles a next commit for an iterator.", "Handles an iterator commit by fetching a batch of entries based on the provided iteratorId and position. The method returns a new IteratorBatch object with the next set of records to process.", "Handles an iterator commit with a specified position. The method returns a batch of entries if the current position is within the specified range, otherwise it returns null."]}
{"SampleId": 4367578, "Origin": "Add a duration (with the same time unit as the current duration)", "Reference": "Add a amount (with the same time unit as the current duration)", "LLMCandidates": ["Add a duration with the same time unit as the current duration.", "Add a duration (with the same time unit as the current duration).", "Add a duration with the same time unit as the current duration", "Add a duration with the same time unit as the current duration", "Add a duration (with the same time unit as the current duration) by using the Plus class and applying it to the current Duration object and the given amount."]}
{"SampleId": 2912048, "Origin": "Gets the additional trade information, defaulted to an empty instance.", "Reference": "Gets the additional information, defaulted to an empty instance.", "LLMCandidates": ["Gets the additional portfolio item information, defaulted to an empty instance.", "Gets the additional portfolio item information, defaulted to an empty instance.", "Gets the additional portfolio item information, defaulted to an empty instance.", "Gets the additional portfolio item information, defaulted to an empty instance.", "Gets the additional portfolio item information, defaulted to an empty instance."]}
{"SampleId": 2891854, "Origin": "Returns  if annotation is present on\ngiven accessible object.", "Reference": "Returns  if annotation is present on\ngiven annotated element.", "LLMCandidates": ["Check if annotation is present on given AnnotatedElement", "Returns if annotation is present on given AnnotatedElement.", "Returns if annotation is present on given AnnotatedElement.", "Returns if annotation is present on given AnnotatedElement.", "Returns if annotation is present on given AnnotatedElement."]}
{"SampleId": 5630008, "Origin": "Gets the nodeType.", "Reference": "Gets the newType.", "LLMCandidates": ["Gets the newType.", "Gets the newType.", "Gets the newType.", "Gets the newType.", "Gets the newType."]}
{"SampleId": 6049437, "Origin": "Returns the favorite site with the primary key or throws a {@link com.liferay.so.NoSuchFavoriteSiteException} if it could not be found.", "Reference": "Returns the favorite site with the primary key or throws a {@link NoSuchFavoriteSiteException} if it could not be found.", "LLMCandidates": ["Finds the favorite site with the primary key or throws a {@link com.liferay.so.NoSuchFavoriteSiteException} if it could not be found.", "Finds the favorite site with the specified primary key or throws a {@link com.liferay.so.NoSuchFavoriteSiteException} if it could not be found.", "Returns the favorite site with the primary key or throws a {@link com.liferay.so.NoSuchFavoriteSiteException} if it could not be found.", "Returns the favorite site with the primary key or throws a {@link com.liferay.so.NoSuchFavoriteSiteException} if it could not be found.", "Returns the favorite site with the primary key or throws a {@link com.liferay.so.NoSuchFavoriteSiteException} if it could not be found."]}
{"SampleId": 2443732, "Origin": "Create an unnamed, parented {@link InstanceManager}.", "Reference": "Create an unnamed, parented {@link InjectionManager}.", "LLMCandidates": ["Create an unnamed, parented InjectionManager.", "Create an unnamed, parented {@link InjectionManager}.", "Create an unnamed, parented {@link InjectionManager}.", "Create an unnamed, parented {@link InjectionManager}.", "Create an unnamed, parented {@link InjectionManager}."]}
{"SampleId": 5077304, "Origin": "Starts continuous task.", "Reference": "Starts local continuous task.", "LLMCandidates": ["Starts a local continuous task.", "Starts a local continuous task.", "Starts a local continuous task.", "Starts a local continuous task.", "Starts local continuous task."]}
{"SampleId": 3425073, "Origin": "Since category uses \"totalPointsPossible\" property instead of\n\"pointsPossible\" property, as in Assignments", "Reference": "Fix for Category NPE reported in SAK-14519 Since category uses \"totalPointsPossible\" property instead of \"pointsPossible\" property,\nas in Assignments", "LLMCandidates": ["Since category uses \"totalPointsPossible\" property instead of \"pointsPossible\" property, as in Assignments", "Since category uses \"totalPointsPossible\" property instead of \"pointsPossible\" property, as in Assignments", "Since category uses \"totalPointsPossible\" property instead of \"pointsPossible\" property, as in Assignments", "This method returns the total points possible for a category, using the \"totalPointsPossible\" property instead of \"pointsPossible\" property, as in Assignments.", "Since category uses \"totalPointsPossible\" property instead of \"pointsPossible\" property, as in Assignments."]}
{"SampleId": 2916155, "Origin": "They must not be of type {@link KnownAmountPaymentPeriod}.", "Reference": "They must not be of type {@link KnownAmountSwapPaymentPeriod}.", "LLMCandidates": ["They must not be of type {@link KnownAmountPaymentPeriod}.", "Build the PointSensitivityBuilder by adding sensitivity data for each SwapPaymentPeriod of the ResolvedSwapLeg, using the provided RatesProvider to evaluate payment period sensitivities.", "Calculate the PointSensitivityBuilder for each SwapPaymentPeriod in ResolvedSwapLeg fixedLeg using RatesProvider provider and return the combined result.", "They must not be of type {@link KnownAmountPaymentPeriod}.", "Calculate PointSensitivityBuilder for a ResolvedSwapLeg and RatesProvider using payment period sensitivity from paymentPeriodPricer."]}
{"SampleId": 6133932, "Origin": "Get the address of the datagram's data field.", "Reference": "Get the datagram's data field.", "LLMCandidates": ["Get the contents of the datagram's data field.", "Get the contents of the datagram's data field.", "Get the contents of the datagram's data field.", "Get the contents of the datagram's data field.", "Retrieve the content of the data field."]}
{"SampleId": 1352180, "Origin": "Temporary method to upgrade from oldStaffBarlines to staffBarlines.", "Reference": "Upgrade from oldStaffBarlines to staffBarlines.", "LLMCandidates": ["Temporary method to upgrade from oldStaffBarlines to staffBarlines.", "Upgrade old staff barline objects to new ones.", "Upgrade old staff bar lines to new ones by iterating over and converting each one. The old staff bar lines list is nulled after the process has completed successfully. The method returns true if successful, otherwise it returns false.", "Upgrades from oldStaffBarlines to staffBarlines by iterating through OldStaffBarline instances and adding them into the new staffBarlines collection. If oldStaffBarlines is not null or empty, it returns true after setting oldStaffBarlines to null. Otherwise, it returns false.", "Upgrades from oldStaffBarlines to staffBarlines."]}
{"SampleId": 3920802, "Origin": "Given a pattern and a string, returns a list with the values of the\ncaptured groups in the pattern.", "Reference": "Given a pattern, which contains one or more capturing groups, and a String,\nreturns a list with the values of the\ncaptured groups in the pattern.", "LLMCandidates": ["Given a pattern and a string, returns a list with the values of the captured groups in the pattern.", "Given a pattern and a string, returns a list with the values of the captured groups in the pattern.", "Given a pattern and a string, returns a list with the values of the captured groups in the pattern.", "Given a pattern and a string, returns a list with the values of the captured groups in the pattern.", "Given a pattern and a string, returns a list with the values of the captured groups in the pattern."]}
{"SampleId": 4476791, "Origin": "The {@link KeyCreateOptions} is required.", "Reference": "The {@link CreateKeyOptions} is required.", "LLMCandidates": ["The {@link CreateKeyOptions} is required.", "The {@link CreateKeyOptions} is required.", "The {@link CreateKeyOptions} is required.", "The {@link CreateKeyOptions} is required.", "The {@link CreateKeyOptions} is required."]}
{"SampleId": 3629294, "Origin": "See Immutable Map Static Factory Methods for details.", "Reference": "See Unmodifiable Maps for details.", "LLMCandidates": ["See Unmodifiable Map Static Factory Methods for details.", "See Unmodifiable Map Static Factory Methods for details.", "See Unmodifiable Map Static Factory Methods for details.", "Constructs an immutable MapN with the specified keys and values.", "Constructs an immutable MapN with the specified keys and values."]}
{"SampleId": 2849528, "Origin": "Make sure we can get the {@link GenieHostInfo} instance even if EC2 metadata fails.", "Reference": "Make sure we can get the {@link GenieHostInfo}.", "LLMCandidates": ["Ensure we can obtain the {@link GenieHostInfo} instance even if EC2 metadata fails or is unavailable.", "Ensure that we can obtain a valid {@link GenieHostInfo} instance even if EC2 metadata is unavailable.", "Check if EC2 is available before getting {@link GenieHostInfo} instance and handle the scenario accordingly.", "Make sure we can get the {@link GenieHostInfo} instance only if EC2 is available.", "Make sure we can get the {@link GenieHostInfo} instance only if EC2 is available."]}
{"SampleId": 4826489, "Origin": "Equivalent to: {@code .weightInit(WeightInit.DISTRIBUTION).dist(distribution)}", "Reference": "Equivalent to: {@code .weightInit(new WeightInitDistribution(distribution))}", "LLMCandidates": ["Builder weightInit(WeightInitDistribution distribution){ return weightInit(distribution); } Equivalent to: {@code .weightInit(new WeightInitDistribution(distribution))", "Equivalent to: {@code .weightInit(WeightInitDistribution(distribution))", "Equivalent to: {@code .weightInit(WeightInitDistribution(distribution))", "Builder weightInit(Distribution distribution){ return weightInit(new WeightInitDistribution(distribution)); } Equivalent to: {@code .weightInit(WeightInit.DISTRIBUTION).dist(distribution)", "Equivalent to: {@code .weightInit(WeightInitDistribution(distribution))"]}
{"SampleId": 6017985, "Origin": "Computes the median for each pixel across all bands in the {@link Planar}\nimage.", "Reference": "Computes the median for each pixel across selected bands in the {@link Planar} image.", "LLMCandidates": ["Computes the median for each pixel across all bands in the {@link Planar} image, and reshapes the output to match the input's width and height.", "Computes the median for each pixel across all bands in the {@link Planar} image and reshapes the output to have the same dimensions as the input.", "Computes the median for each pixel across all bands in the Planar image after reshaping the output image to have the same dimensions as the input image.", "Computes the median for each pixel across all bands in the {@link Planar} image after reshaping the output to have the same width and height as the input.", "Computes the median for each pixel across all bands in the {@link Planar} image, and then reshapes the output to have the same dimensions as the input."]}
{"SampleId": 3982157, "Origin": "Converts Hex encoded string to byte[] if necessary.", "Reference": "Converts a Hex encoded string to a byte array.", "LLMCandidates": ["Converts Hex encoded string to byte[] if necessary.", "Converts Hex encoded string to byte[] if necessary.", "Converts Hex encoded string to byte[] if necessary.", "Converts Hex encoded string to byte[] if necessary.", "Converts Hex encoded string to byte[] if necessary."]}
{"SampleId": 2568424, "Origin": "Sets the value of the 'BloomFilter' field", "Reference": "Sets the value of the 'bloomFilter' field.", "LLMCandidates": ["Sets the value of the 'bloomFilter' field", "Sets the value of the 'bloomFilter' field", "Sets the value of the 'bloomFilter' field", "Sets the value of the 'bloomFilter' field", "Sets the value of the 'bloomFilter' field"]}
{"SampleId": 4390861, "Origin": "Amazon Redshift returns all resources that match any combination of\nthe specified keys and values.", "Reference": "Redshift returns all resources that match any combination of the\nspecified keys and values.", "LLMCandidates": ["Amazon Redshift returns all resources that match any combination of the specified keys and values.", "Amazon Redshift returns all resources that match any combination of the specified keys and values.", "Amazon Redshift returns all resources that match any combination of the specified keys and values.", "Amazon Redshift returns all resources that match any combination of the specified keys and values.", "Amazon Redshift returns all resources that match any combination of the specified keys and values using a StaxResponseHandler and a DescribeTagsResultStaxUnmarshaller."]}
{"SampleId": 5415531, "Origin": "Generate a FormType from a string.", "Reference": "Generate a FormTypes from a string.", "LLMCandidates": ["Generate a FormType from a string.", "Generate a FormTypes from a string.", "Generate a FormType from a string.", "Generate a FormType from a string.", "Generate a FormTypes from a string."]}
{"SampleId": 5922687, "Origin": "Append TLVMsg to the TLVList.", "Reference": "Append TLVMsg to the TLV list.", "LLMCandidates": ["Append a non-null TLVMsg object to the end of the tags list.", "Append TLVMsg to the TLVList, checking for null input using Objects.requireNonNull.", "Append a non-null TLVMsg to the TLVList, with exception handling for NullPointerException.", "Append a non-null TLVMsg to the TLVList, with exception handling for NullPointerException.", "Append TLVMsg to the TLVList, handling a null pointer exception with proper validation."]}
{"SampleId": 2568426, "Origin": "Gets the value of the 'KeepDeletedCells' field", "Reference": "Gets the value of the 'keepDeletedCells' field.", "LLMCandidates": ["Gets the value of the 'keepDeletedCells' field", "Gets the value of the 'keepDeletedCells' field", "Gets the value of the 'keepDeletedCells' field", "Gets the value of the 'keepDeletedCells' field", "Gets the value of the 'keepDeletedCells' field"]}
{"SampleId": 2794191, "Origin": "This method sets the value of the database column m_prj_project.projectType", "Reference": "This method sets the value of the database column m_prj_project.type", "LLMCandidates": ["This method sets the value of the database column m_prj_project.type", "This method sets the value of the database column m_prj_type.type", "This method sets the value of the database column m_prj_project.type", "This method sets the value of the database column m_prj_project.type", "This method sets the value of the database column m_prj_project.type"]}
{"SampleId": 5446622, "Origin": "Return type of method signature as a byte value as defined in Constants", "Reference": "Return type of method signature as a byte value as defined in", "LLMCandidates": ["Return the type of method signature as a byte value, according to the Constants definition.", "Determines the type of a given method signature as a byte value according to the constants.", "Return type of method signature as a byte value as defined in Constants", "Return type of method signature as a byte value as defined in Constants", "The method returns a byte value representing the type of the method signature, based on the input String signature."]}
{"SampleId": 4476800, "Origin": "Loop over the\n{@link KeyProperties key} and call {@link KeyClient#getKey(KeyProperties key properties)}.", "Reference": "Loop over the\n{@link KeyProperties key} and call {@link KeyClient#getKey(String, String)}.", "LLMCandidates": ["Loop over the {@link KeyProperties key} and call {@link KeyClient#getKey(KeyProperties key properties)}.", "Loop over the {@link KeyProperties key} and call {@link KeyClient#getKey(KeyProperties key properties)}.", "Loop over the {@link KeyProperties key} and call {@link KeyClient#getKey(KeyProperties key properties)}.", "Loop over the {@link KeyProperties key} and call {@link KeyClient#getKey(KeyProperties key properties)}.", "Loop over the {@link KeyProperties key} and call {@link KeyClient#getKey(KeyProperties key properties)}."]}
{"SampleId": 2615557, "Origin": "Sets the alignment of the items in the list.", "Reference": "Sets the horizontal alignment of the list items.", "LLMCandidates": ["Sets the alignment of the items in the list.", "Sets the alignment of the items in the list.", "Sets the alignment of the items in the list.", "Sets the alignment for the items in the list.", "Sets the alignment for the items in the list."]}
{"SampleId": 4625121, "Origin": "Atomize Java items.", "Reference": "Return Java items.", "LLMCandidates": ["Atomize Java data types.", "Checking Java ArrayList instantiation.", "Query Java util ArrayList new.", "Query Java util ArrayList new.", "Query Java util ArrayList new."]}
{"SampleId": 1122903, "Origin": "Constuct a trace log event.", "Reference": "Constuct a debug log event.", "LLMCandidates": ["Return a new log builder if debug is enabled or return a NOOP builder otherwise.", "Construct a debug log event.", "Construct a debug log event.", "Construct a debug log event.", "Construct a debug log event."]}
{"SampleId": 5595690, "Origin": "Inspects a given {@link Throwable} as well as its nested causes, in order to look\nfor a specific exception class.", "Reference": "Inspects a given {@link Throwable} as well as its nested causes, in order to look\nfor a specific set of exception classes.", "LLMCandidates": ["Inspects a given {@link Throwable} as well as its nested causes, in order to look for specific exception classes within an array of classes.", "Inspects a given Throwable along with its nested causes to look for specific exception class.", "Inspects a given Throwable along with its nested causes to look for specific exception classes among them. The method takes an array of Class objects to compare against and recursively checks the Throwable's superclass until a match is found or all superclasses have been traversed.", "Inspects a given {@link Throwable} and its nested causes, checking for multiple specific exception classes.", "Inspects a given {@link Throwable} as well as its nested causes, in order to look for specific exception classes within an array of exception classes to search."]}
{"SampleId": 2782536, "Origin": "Returns an iterator on all registered commands.", "Reference": "Returns a sorted collection of all registered commands.", "LLMCandidates": ["Returns a Collection of all registered commands.", "Returns a collection of all registered commands", "Returns a collection of all registered commands", "Returns a collection of all registered commands.", "Returns a collection of all registered commands."]}
{"SampleId": 3116178, "Origin": "Returns the server list for the requested cluster.", "Reference": "Returns the configured server list for the requested cluster.", "LLMCandidates": ["Returns a list of configured servers for the requested cluster.", "Returns the configured server list for the requested cluster.", "Returns the configured server list for the requested cluster.", "Returns the configured server list for the requested cluster.", "Returns the configured server list for the requested cluster."]}
{"SampleId": 5654768, "Origin": "Creates a service name for the deployment unit to define the service.", "Reference": "Creates a service name for the batch environment service.", "LLMCandidates": ["Creates a service name for the deployment unit by defining the environment as \"batch\" and adding \"environment\".", "Creates a service name for the deployment unit by appending \"batch\" and \"environment\".", "Creates a service name for the deployment unit by defining the service with \"batch\" and \"environment\" added to it.", "Creates a service name for the deployment unit to define the service by appending \"batch\" and \"environment\".", "Creates a service name for the deployment unit to define the environment service."]}
{"SampleId": 4232631, "Origin": "Warning: the conditional comments don't work when injected dynamically\nwith JavaScript (i.e.", "Reference": "Warning: the conditional comments don't work when injected dynamically with", "LLMCandidates": ["Warning: the conditional comments don't work when injected dynamically with JavaScript (i.e.", "Warning: Conditional comments with the 'condition' attribute don't work when injected dynamically with JavaScript (i.e.", "Warning: Conditional comments don't work when injected dynamically with JavaScript (i.e.", "Warning: conditional comments don't work when injected dynamically with JavaScript.", "Warning: the conditional comments don't work when injected dynamically with JavaScript."]}
{"SampleId": 4961626, "Origin": "If this node is Object Node and has value for specified property, {@code this} is returned\n to allow chaining; otherwise {@link IllegalArgumentException} is thrown.", "Reference": "If this node is Object Node and has value for specified property, {@code this} is returned\n to allow chaining;\n otherwise exception is thrown.", "LLMCandidates": ["If this node is Object Node and has value for specified property, {@code this} is returned to allow chaining; otherwise an exception is not thrown.", "If the JsonNode is of the required type and does not have a field with the specified name, {@code this} is returned to allow chaining; otherwise an error is raised.", "If this node is Object Node and has value for specified property, {@code this} is returned to allow chaining; otherwise an exception is thrown.", "If this node is of type specified by {@code getClass().getName()}, and has value for specified property {@code fieldName}, {@code this} is returned to allow chaining; otherwise no exception is thrown. The method signature and variable name have been changed from IllegalArgumentException to a simple return of JsonNode.", "If this node is Object Node and has value for specified property, {@code this} is returned to allow chaining; otherwise an IllegalArgumentException is thrown."]}
{"SampleId": 3677389, "Origin": "Returns a copy of this date with the specified field altered.", "Reference": "Returns a copy of this date with the specified field set to a new value.", "LLMCandidates": ["Returns a copy of this OffsetDate with the specified field altered.", "Returns a copy of this date with the specified field altered.", "Returns a copy of this date with the specified field altered.", "Returns a copy of this date with the specified field altered.", "Returns a copy of this date with the specified field altered by providing a new value for that field."]}
{"SampleId": 4478386, "Origin": "Sets the {@link SharedKeyCredential} used to authorize requests sent to the service.", "Reference": "Sets the {@link StorageSharedKeyCredential} used to authorize requests sent to the service.", "LLMCandidates": ["Sets the {@link StorageSharedKeyCredential} used to authorize requests sent to the service.", "Sets the {@link StorageSharedKeyCredential} used to authorize requests sent to the service.", "Sets the {@link StorageSharedKeyCredential} used to authorize requests sent to the service.", "Sets the {@link StorageSharedKeyCredential} used to authorize requests sent to the service.", "Sets the {@link StorageSharedKeyCredential} used to authorize requests sent to the service."]}
{"SampleId": 3828357, "Origin": "The string \"back\" is special-cased\nto provide Referrer support, when Referrer\nis not present `alt` or \"/\" is used.", "Reference": "The string \"back\" is special-cased\nto provide Referrer support, when Referrer\nis not present \"/\" is used.", "LLMCandidates": ["The string \"back\" is special-cased to provide Referrer support, when Referrer is not present `alt` or \"/\" is used.", "The string \"back\" is special-cased to provide Referrer support, when Referrer is not present `alt` or \"/\" is used.", "The string \"back\" is special-cased to provide Referrer support, when Referrer is not present `alt` or \"/\" is used. The method returns a Future of Void, indicating that the HTTP response has been updated with new headers and status code.", "The string \"back\" is special-cased to provide Referrer support when Referrer is not present, `alt` or \"/\" is used.", "The string \"back\" is special-cased to provide Referrer support, when Referrer is not present, either `alt` or \"/\" is used."]}
{"SampleId": 2891644, "Origin": "Creates all folders at once.", "Reference": "Creates all directories at once.", "LLMCandidates": ["Creates all folders at once, checking if it is a directory and throwing an IOException if not. If the folder already exists and is not a directory, it checks that. Otherwise, it creates the folder.", "Creates all folders at once by checking if they exist and are directories.", "Creates all folders at once by checking if they exist and are directories.", "Creates all folders at once if they don't already exist or are not a directory. If the folder exists and is a directory, the method returns immediately; otherwise, it checks if the folder can be created.", "Creates all folders at once if they do not exist yet or checks that existing directories are directories and returns immediately if so. If a directory does not exist, it verifies its creation and throws an IOException if the directory cannot be created."]}
{"SampleId": 4903187, "Origin": "Note that the returned {@link Bits}\ninstance MUST be consumed in order.", "Reference": "NOTE: that the returned {@link Bits} instance MUST be consumed in order.", "LLMCandidates": ["The returned {@link Bits} instance MUST be consumed in order.", "The returned Bits instance MUST be consumed in order, starting from the beginning.", "Note that the returned {@link Bits} instance MUST be consumed in order.", "The returned {@link Bits} instance MUST be consumed in order and can only be accessed through this method.", "The returned Bits instance MUST be consumed in order."]}
{"SampleId": 2887744, "Origin": "This method must only be\nused for type references whose sort is {@link #THROWS THROWS}.", "Reference": "This method must only be used for type references whose sort is {@link\n#THROWS}.", "LLMCandidates": ["This method must only be used for type references whose sort is {@link #THROWS THROWS}.", "This method must only be used for type references whose sort is {@link #THROWS THROWS}.", "This method must only be used for type references whose sort is {@link #THROWS THROWS}.", "This method must only be used for type references whose sort is {@link #THROWS THROWS}.", "This method must only be used for type references whose sort is {@link #THROWS_AND_INFO THROWS_AND_INFO}."]}
{"SampleId": 6006977, "Origin": "Write a Chart series as columns in a CSV file.", "Reference": "Export a Chart series in columns in a CSV file.", "LLMCandidates": ["Write a series of XY data points as columns in a CSV file.", "Write a Chart series as columns in a CSV file with XYSeries type and path2Dir parameter.", "Write a Series Axes Chart series as columns in a CSV file with the given path and directory name.", "Write a XYSeries chart series as columns in a CSV file.", "Write a Chart series as columns in a CSV file with XYSeries object and updated path2Dir parameter."]}
{"SampleId": 2061869, "Origin": "Determines whether a character is lower case according to\n{@linkplain Character#isLowerCase(char) Java's definition}.", "Reference": "Determines whether a BMP character is lower case according to\n{@linkplain Character#isLowerCase(char) Java's definition}.", "LLMCandidates": ["Determines whether a character is lower case according to {@linkplain Character#isLowerCase(char) Java's definition}.", "Determines whether a character is lower case according to {@linkplain Character#isLowerCase(char) Java's definition}, but use this method with caution as it has been deprecated.", "Determines whether a character is lower case according to {@linkplain Character#isLowerCase(char) Java's definition}, but the method is deprecated.", "Determines whether a character is lower case according to {@linkplain Character#isLowerCase(char) Java's definition}.", "Determines whether a character is lower case according to {@linkplain Character#isLowerCase(char) Java's definition}; however, this method is deprecated. Please use alternative methods for case-sensitive operations."]}
{"SampleId": 2142578, "Origin": "Returns the split point number, 1-based.", "Reference": "Returns a unique id for each runAsync, 1-based.", "LLMCandidates": ["Returns the run async ID number, 1-based.", "Returns the run async ID number, 1-based.", "Returns the run async ID number, 1-based.", "Returns the run async ID number, 1-based.", "Returns the run async id, 1-based."]}
{"SampleId": 3652742, "Origin": "Fails silently if no match found.", "Reference": "Fails silently if the student does not exist.", "LLMCandidates": ["Deletes a student record from the course specified by courseId and email", "This method deletes a student from a course with a given courseId and studentEmail. It assumes that both the input parameters are not null. The deletion operation is cascaded through studentsLogic, which handles the actual removal process. If no match is found for the provided student in the specified course, this method fails silently.", "This method fails silently if no match is found while deleting a student with the specified courseId and studentEmail from the system.", "Deletes the student with the specified email from the course with the given course ID, but may fail silently if no match is found.", "Deletes the student from the specified course and its related data cascade without error indication if no match found."]}
{"SampleId": 3238740, "Origin": "Objects of the following type(s) are allowed in the list\n{@link CTAbsSizeAnchor }\n{@link CTRelSizeAnchor }", "Reference": "Objects of the following type(s) are allowed in the list\n{@link CTRelSizeAnchor }\n{@link CTAbsSizeAnchor }", "LLMCandidates": ["Objects of the following type(s) are allowed in the list {@link CTAbsSizeAnchor }, {@link CTRelSizeAnchor", "Objects of the following type(s) are allowed in the list {@link CTAbsSizeAnchor } {@link CTRelSizeAnchor", "Objects of the following type(s) are allowed in the list {@link CTAbsSizeAnchor }, {@link CTRelSizeAnchor", "Objects of the following type(s) are allowed in the list {@link CTAbsSizeAnchor } {@link CTRelSizeAnchor", "Objects of the following type(s) are allowed in the list {@link CTSizeAnchor}}{{@link CTRelSizeAnchor"]}
{"SampleId": 5455337, "Origin": "Sets item to self and waiter to null, to avoid garbage\nretention after matching or cancelling.", "Reference": "Sets item (of a request node) to self and waiter to null,\nto avoid garbage retention after matching or cancelling.", "LLMCandidates": ["Sets item to self if not in data mode and waiter to null, to avoid garbage retention after matching or cancelling.", "Sets item to self if data is not enabled, and waiter to null, to avoid garbage retention after matching or cancelling.", "Sets item to self and waiter to null if not isData flag set, to avoid garbage retention after matching or cancelling.", "Sets item to self and waiter to null if not isData, to avoid garbage retention after matching or cancelling.", "Sets item to self if isData is false, and waiter to null, to avoid garbage retention after matching or cancelling."]}
{"SampleId": 4589585, "Origin": "Create error value with given reason and error details.", "Reference": "Create error value with given type, reason and details.", "LLMCandidates": ["Create error value with given reason and error details (using BErrorType type, BString reason, and Object details).", "Create error value with given type, reason, and error details.", "Create error value with given type, reason, and error details.", "Create error value with given type, reason, and error details.", "Create error value with given type, reason, and error details."]}
{"SampleId": 3566647, "Origin": "{@code protocol} and {@code proxy} will be non-null and {@code throwable} will be null when\nthe connection is successfully established.", "Reference": "{@code protocol} and {@code proxy} will be non-null and {@code ioe} will be null when\nthe connection is successfully established.", "LLMCandidates": ["@code protocol} and {@code proxy} will be non-null and {@code ioe} will be null when the connection is successfully established.", "@code protocol} and {@code proxy} will be non-null when the connection is successfully established.", "@code protocol} and {@code proxy} will be non-null and {@code ioe} will be null when the connection is successfully established.", "@code protocol} and {@code proxy} will be non-null and {@code ioe} will be null when\nthe connection is successfully established.", "@code protocol} and {@code proxy} will be non-null when the connection is successfully established, while {@code ioe} will be null."]}
{"SampleId": 2444066, "Origin": "Get the set of all custom providers registered for the given service provider contract\nin the underlying {@link ServiceLocator HK2 service locator} container.", "Reference": "Get the set of all custom providers registered for the given service provider contract\nin the underlying {@link InstanceManager instance manager} container.", "LLMCandidates": ["Get the set of all custom providers registered for the given service provider contract in the underlying {@link ServiceLocator HK2 service locator} container by using {@code InstanceManager} instead of {@code ServiceLocator}.", "Get the set of all custom providers registered for the given service provider contract in the underlying {@link InstanceManager HK2 instance manager} container.", "Get the set of all custom providers registered for the given service provider contract in the underlying {@link InstanceManager HK2 instance manager} container.", "Get the set of all custom providers registered for the given service provider contract in the underlying {@link ServiceManager} container.", "Get the set of all custom providers registered for the given service provider contract in the underlying {@link ServiceManager} container."]}
{"SampleId": 5452793, "Origin": "Basic test of Layer containing automatic modules", "Reference": "Basic test of layer containing automatic modules", "LLMCandidates": ["Basic test of Layer containing automatically built modules", "Basic test of Layer containing modules defined from ModuleDescriptor with automatic module configuration and dependencies.", "Basic test of ModuleLayer containing automatically loaded modules", "Basic test of ModuleLayer containing automatically loaded modules", "Basic test of Layer containing automatically created modules"]}
{"SampleId": 6044163, "Origin": "Returns the sync d l object with the primary key or throws a {@link com.liferay.sync.NoSuchDLObjectException} if it could not be found.", "Reference": "Returns the sync d l object with the primary key or throws a {@link NoSuchDLObjectException} if it could not be found.", "LLMCandidates": ["Finds the sync DL object with the primary key or throws a {@link com.liferay.sync.NoSuchDLObjectException} if it could not be found.", "Returns the sync d l object with the primary key or throws a {@link com.liferay.sync.NoSuchDLObjectException} if it could not be found.", "Returns the sync d l object with the primary key or throws a {@link com.liferay.sync.NoSuchDLObjectException} if it could not be found.", "Returns the sync d l object with the primary key or throws a {@link com.liferay.sync.NoSuchDLObjectException} if it could not be found.", "Finds the sync DL object with the specified primary key or throws a {@link com.liferay.sync.NoSuchDLObjectException} if it could not be found."]}
{"SampleId": 3678304, "Origin": "This factory creates a {@code ZonedDateTime} from a date-time and time-zone.", "Reference": "Obtains an instance of {@code ZonedDateTime} from a local date-time.", "LLMCandidates": ["This factory creates a {@code ZonedDateTime} from a date-time and time-zone using a specific resolver.", "This factory creates a {@code ZonedDateTime} from a date and time-zone.", "This factory creates a {@code ZonedDateTime} from a LocalDateTime and ZoneId.", "This factory creates a {@code ZonedDateTime} from a LocalDateTime and ZoneId.", "This factory creates a {@code ZonedDateTime} from a LocalDateTime and ZoneId."]}
{"SampleId": 1672719, "Origin": "Checks for internet connection and then initializes the recycler view with 25 categories of the searched query", "Reference": "Checks for internet connection and then initializes the recycler view with all(max 500) categories of the searched query", "LLMCandidates": ["Checks for internet connection and then initializes the recycler view with subcategories of the searched query if isParentCategory is true, otherwise it initializes it with parent categories.", "Initializes recycler view with sub or parent categories based on isParentCategory flag after checking for internet connection.", "Initializes recycler view with sub or parent categories based on isParentCategory flag after checking for internet connection.", "Checks for internet connection and then initializes recycler view based on parent or sub category list depending on isParentCategory flag", "Checks for internet connection and then initializes the recycler view with categories of the searched query based on if it is a parent or sub category."]}
{"SampleId": 2533375, "Origin": "Creates CronDefinition instance matching quartz specification;", "Reference": "Creates CronDefinition instance matching Quartz specification", "LLMCandidates": ["Creates CronDefinition instance matching quartz specification;", "Creates a CronDefinition instance that follows the quartz specification;", "Creates a CronDefinition instance that follows the quartz specification;", "Creates a CronDefinition instance matching quartz specification;", "Creates a CronDefinition instance matching quartz specification;"]}
{"SampleId": 4396556, "Origin": "Returns a string representation of this object; useful for testing and debugging.", "Reference": "Returns a string representation of this object.", "LLMCandidates": ["Returns a string representation of this object; useful for testing and debugging, with sensitive data like passwords being redacted.", "Returns a string representation of this object for testing and debugging purposes; sensitive data like passwords are redacted for security reasons.", "Returns a string representation of this object for testing and debugging purposes.", "Returns a string representation of this object for testing and debugging purposes.", "Returns a string representation of this object; useful for testing and debugging, with sensitive data redacted."]}
{"SampleId": 3710215, "Origin": "Remove the {@link Query} at the given position from this playlist", "Reference": "Remove the {@link PlaylistEntry} at the given position from this playlist", "LLMCandidates": ["Remove the {@link Entry} at the given position from this playlist", "Remove the {@link Entry} at the given position from this playlist", "Remove the {@link Entry} at the given position from this playlist", "Remove the {@link Entry} at the given position from this playlist", "Remove the {@link Entry} at the given position from this playlist"]}
{"SampleId": 5450903, "Origin": "You are running on JDK6 which comes with JAX-WS {0} API, but this tool requires JAX-WS {1} API.", "Reference": "You are running on JDK6 or newer which comes with JAX-WS {0} API, but this tool requires JAX-WS {1} or newer API.", "LLMCandidates": ["This wrapper method is used to localize a specific string related to a task that needs endorsement and requires two arguments. The localizer is responsible for providing the appropriate localized text.", "Wraps a task that needs endorsement with localized text using the provided arguments and the LOCALIZER instance to access localization resources.", "This method takes two arguments and uses them in a localizable string for wrapping a task that needs endorsement. It returns the localized version of the localizable string.", "Wrapper task need endorsed with 2 arguments.", "Wrapper task need endorsed with 2 arguments."]}
{"SampleId": 2825249, "Origin": "Allocate a block of memory of the given size in bytes, and return a pointer to that memory.", "Reference": "Allocate a block of memory of the given size in bytes and update memory allocation tracker accordingly.", "LLMCandidates": ["Allocate a block of memory of the given size in bytes, and return a pointer to that memory, with additional bookkeeping of allocated memory through MemoryAllocationTracker.", "Allocate a block of memory of the given size in bytes using an implementation specific to this system, and return a pointer to that memory. Additionally, the MemoryAllocationTracker is notified about the allocation.", "Allocate a block of memory of the given size in bytes, and return a pointer to that memory using internal allocation functions.", "Allocate a block of memory of the given size in bytes, and return a pointer to that memory. Allocate the memory using the specified MemoryAllocationTracker object, and then notify it of the allocation.", "Allocate a block of memory of the given size in bytes, and return a pointer to that memory. If DIRTY_MEMORY is true, initialize the allocated memory with a specific pattern (byte 0xA5). Add the allocated pointer to a tracking list and update both the MemoryAllocationTracker and GlobalMemoryTracker with the allocated bytes."]}
{"SampleId": 6048529, "Origin": "Returns the app with the primary key or throws a {@link com.liferay.marketplace.NoSuchAppException} if it could not be found.", "Reference": "Returns the app with the primary key or throws a {@link NoSuchAppException} if it could not be found.", "LLMCandidates": ["Finds and returns the app with the primary key or throws a {@link com.liferay.marketplace.NoSuchAppException} if it could not be found.", "Returns the app with the primary key or throws a {@link com.liferay.marketplace.NoSuchAppException} if it could not be found.", "Returns the app with the primary key or throws a {@link com.liferay.marketplace.NoSuchAppException} if it could not be found.", "Returns the app with the primary key or throws a {@link com.liferay.marketplace.NoSuchAppException} if it could not be found.", "Returns the app with the primary key or throws a {@link com.liferay.marketplace.NoSuchAppException} if it could not be found."]}
{"SampleId": 4245569, "Origin": "Convert to primitive types, returning default value if text is null.", "Reference": "Convert to integer, returning default value if text is inconvertible.", "LLMCandidates": ["Convert to primitive types, returning default value if text is empty or not a valid integer.", "Convert to primitive types, returning default value if text is not null.", "Convert to primitive types, returning default value if text is null or an exception occurs during conversion.", "Convert to primitive types, returning default value if text is null or an exception occurs during conversion.", "Convert to primitive types, returning default value if text is empty or invalid."]}
{"SampleId": 2603527, "Origin": "caller should not modify leavingEndpoints", "Reference": "caller should not modify leavingNodes", "LLMCandidates": ["caller should not modify leavingNodes", "caller should not modify leavingNodes", "The caller should not modify leavingNodes.", "The caller should not modify leavingNodes.", "Retrieve a set of leaving nodes, while ensuring that the caller should not modify them."]}
{"SampleId": 6363989, "Origin": "Waits until the given element is either hidden or deleted.", "Reference": "Waits until the given locator corresponds to either a hidden or a deleted element.", "LLMCandidates": ["Waits until the given element is either hidden or deleted using another method with null and locator parameters.", "Waits until the given element is either hidden or deleted.", "Waits until the given element is either hidden or deleted.", "Waits until a given element is either hidden or deleted by using the specified locator", "Waits until a given element is either hidden or deleted by using the specified locator"]}
{"SampleId": 2461871, "Origin": "Check that the default base section paint is not null, and that you\ncan never set it to null.", "Reference": "Check that the default section paint is not null, and that you\ncan never set it to null.", "LLMCandidates": ["Check that the default section paint is not null, and that you cannot set it to null.", "Check that the default section paint is not null, and that you can never set it to null.", "Check that the default section paint is not null, and that you can never set it to null.", "Check that the default section paint is not null, and that you can never set it to null.", "Check that the default section paint is not null, and that you can never set it to null."]}
{"SampleId": 5927567, "Origin": "Returns a new fresh folder with the given path under the temporary\nfolder.", "Reference": "Returns a new fresh folder with the given paths under the temporary\nfolder.", "LLMCandidates": ["Create a new folder with the given path under the temporary folder.", "Creates a new folder at the specified path within the temporary directory, returning the File object representing the newly created folder. If any errors occur during folder creation, an IOException is thrown.", "Creates a new folder with the given path under the root folder. If any folder with the same name already exists, an IOException will be thrown.", "Create a new folder with the given path under the root folder. The path is a sequence of relative paths. If any folder in the path already exists, it will throw an IOException.", "Creates a new folder with the given relative paths under the temporary folder and checks if it has been created successfully. Throws an IOException if there is an error or if a folder with the same name already exists."]}
{"SampleId": 1563458, "Origin": "Setup starts 4 process instances of oneTaskProcess\nand 1 instance of oneTaskProcess2", "Reference": "Setup starts 4 process instances of oneTaskProcess\nand 1 instance of otherOneTaskProcess", "LLMCandidates": ["Setup starts 4 process instances of oneTaskProcess\nand 1 instance of otherOneTaskProcess", "Setup starts 4 process instances of oneTaskProcess and 1 instance of otherOneTaskProcess.", "Setup starts 4 process instances of oneTaskProcess and 1 instance of otherOneTaskProcess.", "Setup starts 4 process instances of oneTaskProcess\nand 1 instance of otherOneTaskProcess", "Setup starts 4 process instances of oneTaskProcess and 1 instance of otherOneTaskProcess"]}
{"SampleId": 3143525, "Origin": "Applies a list ontology changes to a collection of ontologies.", "Reference": "Apply ontology changes.", "LLMCandidates": ["Applies a list of ontology changes to a collection of ontologies by streaming through the changes.", "Applies a list of ontology changes to a collection of ontologies and returns the result.", "Applies a list of ontology changes to a collection of ontologies and returns the result.", "Applies a list of ontology changes to a collection of ontologies and returns a report of the applied changes.", "Applies a list of ontology changes to an ontology collection."]}
{"SampleId": 3933924, "Origin": "The input file must be a list of whitespace-separated verb-lemma-POS triples, one verb\nform per line.", "Reference": "The input file must be a list of tab-separated verb-POS pairs, one verb\nper line.", "LLMCandidates": ["The input file must be a list of whitespace-separated verb-lemma-POS triples, one verb form per line.", "The input file must be a list of whitespace-separated verb-lemma-POS triples, one verb form per line.", "The input file must be a list of whitespace-separated verb lemma-POS triples, one verb form per line.", "The input file must be a list of whitespace-separated verb-lemma-POS triples, one verb form per line.", "The input file must be a list of whitespace-separated verb-lemma-POS triples, one verb form per line."]}
{"SampleId": 1357732, "Origin": "Using the starting mark found for each alteration item, defines all slices.", "Reference": "Using the starting mark found for each alteration item, defines all roi.", "LLMCandidates": ["Define all slices using the starting marks found for each alteration item.", "Using the starting marks found for each alteration item, defines all slices.", "Using the starting marks found for each alteration item, defines all slices.", "Creates slices based on the list of starting marks found for each alteration item.", "Using the starting mark found for each alteration item, defines all slices by creating a Slice object based on the start and stop positions of the range."]}
{"SampleId": 3380827, "Origin": "It determines time duration that you should wait for permission and reserves it for you,\nif you'll be able to wait long enough.", "Reference": "It determines time duration that you should wait for the given number of permits\nand reserves it for you, if you'll be able to wait long enough.", "LLMCandidates": ["This method calculates the next state for a specific active state by determining the time duration needed to wait for permission, based on the number of permits given and the timeout in nanos. It then reserves permissions accordingly if the waiting period is possible.", "This method calculates the next state based on the given permissions, determining the time duration to wait for permission and reserving it if possible.", "This method calculates the next state based on the given number of permits, timeoutInNanos, and the current activeState. It determines time duration that you should wait for permission and reserves it for you, if you'll be able to wait long enough.", "Calculates next state by determining the time duration to wait for permission and reserving it if possible, based on the given permits and activeState configuration.", "This method calculates the next state based on the given number of permits, timeout nanos, and the current activeState. It determines the time duration that you should wait for permission and reserves it for you, if you'll be able to wait long enough."]}
{"SampleId": 3920708, "Origin": "Pieces a List of CoreMaps back together using\nword and setting a white space between each word\nTODO: remove this (listToString does the same thing)", "Reference": "Pieces a List of CoreMaps back together using\nword and setting a white space between each word\nTODO: remove this (SentenceUtils.listToString does the same thing - why 2 separate classes)", "LLMCandidates": ["Pieces a List of CoreMaps back together using word and setting a white space between each word. Note: This method has been replaced by listToString.", "Pieces a List of CoreMaps back together using word and setting a space between each word. TODO: remove this (listToString does the same thing)", "Pieces a List of CoreMaps back together using word and setting a white space between each word\nTODO: remove this (listToString does the same thing)", "Pieces a List of CoreMaps back together using word and setting a white space between each word.", "Pieces a List of CoreMaps back together using word and setting a space between each word. TODO: remove this (listToString does the same thing)"]}
{"SampleId": 6263783, "Origin": "Checks whether memory cache key (image URI) for current ImageView is actual", "Reference": "Checks whether memory cache key (image URI) for current ImageAware is actual", "LLMCandidates": ["Checks whether memory cache key for current ImageView is actual", "Checks whether memory cache key (image URI) for the given image-aware component is actual.", "Checks whether memory cache key (image URI) for current ImageView has been reused.", "Checks whether memory cache key (image URI) for current ImageView is actual.", "Checks whether memory cache key (image URI) for current ImageView is actual."]}
{"SampleId": 113644, "Origin": "Initializes the resource to edit according to the uuid provided via the tag's attribute \"uuid\".", "Reference": "Returns the resource to edit according to the uuid provided via the tag's attribute \"uuid\".", "LLMCandidates": ["Initializes the resource to edit according to the uuid provided via the tag's attribute \"uuid\".", "Initializes the resource to edit according to the uuid provided via the tag's attribute \"uuid\" and returns it.", "Initializes the resource to edit according to the uuid provided via the tag's attribute \"uuid\".", "Initializes the resource to edit according to the uuid provided via the tag's attribute \"uuid\" and returns it.", "Initializes the resource to edit according to the uuid provided via the tag's attribute \"uuid\" and returns it."]}
{"SampleId": 6044910, "Origin": "or throws a {@link com.liferay.calendar.NoSuchNotificationTemplateException} if it could not be found.", "Reference": "or throws a {@link NoSuchNotificationTemplateException} if it could not be found.", "LLMCandidates": ["Finds a CalendarNotificationTemplate with the given UUID and group ID, or throws a {@link com.liferay.calendar.NoSuchNotificationTemplateException} if it could not be found.", "Finds a CalendarNotificationTemplate object by its UUID and group ID, or throws a {@link com.liferay.calendar.NoSuchNotificationTemplateException} if it could not be found.", "This method finds a calendar notification template by its UUID and group ID. If it could not be found, it throws a {@link com.liferay.calendar.NoSuchNotificationTemplateException} exception.", "Find a CalendarNotificationTemplate by UUID and group ID. If it could not be found, throws a {@link com.liferay.calendar.NoSuchNotificationTemplateException}.", "finds a CalendarNotificationTemplate by UUID and groupId, or throws a NoSuchNotificationTemplateException if not found"]}
{"SampleId": 5600464, "Origin": "For {@link Type#ERROR} or\n{@link Type#EXIT} actions this can be provided as part of the factory method.", "Reference": "For\n{@link ActionType#ERROR} or {@link ActionType#EXIT} actions this can be provided as part of the factory method.", "LLMCandidates": ["For {@link Type#ERROR} or\n{@link Type#EXIT} actions this can be provided as part of the factory method.", "For actions derived from {@link Type#ERROR} or {@link Type#EXIT}, this method can be provided as part of the factory method. This overridden method is used to set the status message for actions that inherit from these types.", "For {@link Type#ERROR} or {@link Type#EXIT} actions this can be provided as part of the factory method.", "For {@link Type#ERROR} or {@link Type#EXIT} actions this can be provided as part of the factory method.", "For {@link Type#ERROR} or {@link Type#EXIT} actions this can be provided as part of the factory method. Overrides the default implementation in super class."]}
{"SampleId": 3467788, "Origin": "Appends a declaration of the given label to {@link #buf buf}.", "Reference": "Appends a declaration of the given label to {@link #stringBuilder}.", "LLMCandidates": ["Appends a declaration of the given label to {@link #stringBuilder stringBuilder}.", "Appends a declaration of the given label to {@link #stringBuilder stringBuilder}.", "Appends a declaration of the given label to {@link #stringBuilder stringBuilder}.", "Appends a declaration of the given label to {@link #stringBuilder stringBuilder}.", "Appends a declaration of the given label to {@link #stringBuilder stringBuilder}."]}
{"SampleId": 570063, "Origin": "This method obtains the extension as the textual part of the filename\nafter the last dot.", "Reference": "This method obtains the extension as the textual part of the fileName\nafter the last dot.", "LLMCandidates": ["This method obtains the extension as the textual part of the filename after the last dot, and then checks if it matches any of the extensions provided. If there's a match, the function returns true; otherwise, false.", "This method obtains the extension as the textual part of the filename after the last dot.", "This method obtains the file extension from the filename after the last dot and checks if it is present in a list of allowed extensions. If it matches any of the allowed extensions, it returns true, otherwise false.", "This method obtains the extension as the textual part of the fileName after the last dot.", "This method obtains the extension as the textual part of the fileName after the last dot."]}
{"SampleId": 2478241, "Origin": "Implements {@link PacketListener}.", "Reference": "Implements {@link StanzaListener}.", "LLMCandidates": ["processStanza(Stanza packet)} throws NotConnectedException, InterruptedException\n{Implements {@link PacketListener}.", "Implements {@link PacketListener}. As we do elsewhere, acknowledge the receipt of the Packet first and then go about our business with it. If the packet type is SET, send a result packet to the connection. Now that the acknowledging is out of the way, do go about our business with the Packet.", "Implements {@link StanzaListener}.", "This method implements PacketListener interface, handling packet processing with acknowledging and potential interruptions.", "This method implements PacketListener interface, handling packet processing with acknowledging and potential interruptions."]}
{"SampleId": 5425595, "Origin": "Returns the authenticating user's retweet of this tweet, or null when the tweet was created\nbefore this feature was enabled.", "Reference": "Returns the authenticating user's retweet's id of this tweet, or -1L when the tweet was created\nbefore this feature was enabled.", "LLMCandidates": ["Returns the authenticating user's retweet of this tweet, or null when the tweet was created before this feature was enabled.", "Returns the authenticating user's retweet of this tweet, or null when the tweet was created before this feature was enabled.", "Returns the authenticating user's retweet ID of this tweet, or null when the tweet was created before this feature was enabled.", "Returns the authenticating user's retweet ID of this tweet, or null when the tweet was created before this feature was enabled.", "Returns the authenticating user's retweet ID of this tweet, or null when the tweet was created before this feature was enabled."]}
{"SampleId": 84962, "Origin": "Removes and returns the node at the head of the frontier.", "Reference": "Primitive operation which removes and returns the node at the head of the frontier.", "LLMCandidates": ["Removes and returns the node at the head of the frontier.", "Removes and returns the node at the head of the frontier.", "Removes and returns the node at the head of the frontier.", "Removes and returns the node at the head of the frontier.", "Removes and returns the node at the head of the frontier; updates metrics based on the frontier size."]}
{"SampleId": 2482289, "Origin": "Queries this contact source for the given queryString.", "Reference": "Creates query for the given queryString.", "LLMCandidates": ["Queries this contact source for the given queryString and returns a new ContactQuery object.", "Queries this contact source for the given queryString, then starts a query process with it and specifies the number of contacts to return.", "Queries this contact source for the given queryString. Returns a ContactQuery object to process the query.", "Queries this contact source for the given queryString. Returns a ContactQuery object to process the query.", "Queries this contact source for the given queryString and returns a ContactQuery object."]}
{"SampleId": 4476799, "Origin": "The {@link KeyCreateOptions#getExpires() expires} and {@link", "Reference": "The {@link CreateKeyOptions#getExpiresOn() expires} and {@link", "LLMCandidates": ["Create a new key using the provided {@link CreateKeyOptions#getKeyVaultKey() Key Vault Key} and {@link Context context}.", "The {@link CreateKeyOptions#getExpires() expires} and {@link KeyVaultKey#getKeyIdentifier() key identifier} of the created KeyVaultKey are set.", "Creates a key with response using CreateKeyOptions and Context.", "Creates a key with response using CreateKeyOptions and Context.", "Create a key with response using provided create key options and context"]}
{"SampleId": 4476803, "Origin": "The get key operation is\napplicable to all key types and it requires the {@code keys/get} permission.", "Reference": "This operation requires the {@code\nkeys/delete} permission.", "LLMCandidates": ["The delete key operation is applicable to all key types and it requires the {@code keys/delete} permission.", "The delete key operation is applicable to all key types and it requires the {@code keys/delete} permission.", "The delete key operation is applicable to all key types and it requires the {@code keys/delete} permission.", "The delete key operation is applicable to all key types and it requires the {@code keys/delete} permission.", "The delete key operation is applicable to all key types and it requires the {@code keys/delete} permission."]}
{"SampleId": 2312760, "Origin": "Returns the (unbiased) skew of all the values within a {@link Dataset}", "Reference": "Returns the (unbiased) kurtosis of all the values within a {@link Dataset}", "LLMCandidates": ["Calculates the unbiased kurtosis of all values within a {@link Dataset", "Returns the kurtosis of all the values within a {@link Dataset", "Returns the (unbiased) kurtosis of all the values within a {@link Dataset", "Returns the (unbiased) kurtosis of all the values within a {@link Dataset", "Calculates the sample kurtosis of all the values within a {@link Dataset}."]}
{"SampleId": 18791, "Origin": "Get Payroll movement with concept is paid and is invoiced", "Reference": "Get Payroll movement with concept is invoiced", "LLMCandidates": ["Get Payroll movement with concept is paid and invoiced, where IsActive is true, and HR_Movement has no related InvoiceLine.", "Get Payroll movement with concept is paid and is invoiced, filtering by process ID and partner ID.", "Get Payroll movement with concept is paid, invoiced, and having active attribute", "Get Payroll movement with concept is paid, invoiced, and having active attribute", "Get Payroll movement with concept is paid and invoiced, considering HR_Process_ID and C_BPartner_ID."]}
{"SampleId": 1355443, "Origin": "Prepare the collection of CLI tasks (inputs, books, scripts, samples).", "Reference": "Prepare the collection of CLI tasks (inputs, books, samples).", "LLMCandidates": ["Prepare the collection of CLI tasks (inputs, scripts, samples).", "Prepare the collection of CLI tasks based on input file extension (books, scripts, samples).", "Prepare the collection of CLI tasks (inputs, books, scripts, samples), determining the task type based on the argument extension.", "Prepare the collection of CLI tasks (inputs, books, scripts, samples).", "Prepare the collection of CLI tasks (inputs, books, scripts, samples)."]}
{"SampleId": 3467805, "Origin": "Checks a given class.", "Reference": "Checks the given class.", "LLMCandidates": ["Verifies a given class by reading its source code and reporting potential issues. Usage: CheckClassAdapter <fully qualified class name or class file name>", "Verifies the given class.\\nUsage: CheckClassAdapter <fully qualified class name or class file name>", "Verifies the given class by checking a given class.\nUsage: CheckClassAdapter <fully qualified class name or class file name>", "Verifies the given class by checking a given class.\nUsage: CheckClassAdapter <fully qualified class name or class file name>", "Verifies the given class.\\nUsage: CheckClassAdapter <fully qualified class name or class file name>"]}
{"SampleId": 1241791, "Origin": "Runs the pig script using PigRunner API if version VERSION or above.", "Reference": "Runs the pig script using PigRunner.", "LLMCandidates": ["Runs the pig script using PigRunner API for Pig version 0.8+.", "Runs the pig script using PigRunner API if version 0.8+.", "Runs the pig script using PigRunner API if version 0.8+.", "Runs the Pig script using PigRunner API if version 0.8 or above.", "Runs the pig script using PigRunner API if version 0.8+."]}
{"SampleId": 2388099, "Origin": "Provides a list of all connection wrappers corresponding to a given environment.", "Reference": "Provides a list of all connection configs corresponding to a given environment.", "LLMCandidates": ["Provides a list of all connection configurations corresponding to a given environment.", "Provides a list of all connection configs corresponding to a given environment.", "Provides a list of all connection configs corresponding to a given environment.", "Provides a list of all connection configs corresponding to a given environment.", "Provides a list of all connection configs corresponding to a given environment."]}
{"SampleId": 5434288, "Origin": "If this lookup object has private access, then the caller class is the lookupClass.", "Reference": "If this lookup object has full privilege access, then the caller class is the lookupClass.", "LLMCandidates": ["If this lookup object has private access, then the caller class is the lookupClass and the permission checking mechanism must be applied to access the class.", "This method checks if the current lookup object has private access, and if so, the caller class is the lookupClass.", "If this lookup object has full privileged access, then the caller class is the lookupClass.", "This method checks whether the current lookup object has full privileges or not. If it does not have full privilege access and its class is not the same as the refc, ReflectUtil will check package access. The caller class is the lookupClass.", "Checks whether the caller class has private access and the class to be accessed is a descendant of the calling class's class loader, if not, then ReflectUtil.checkPackageAccess(refc) must be called. Additionally, it checks for member access permissions."]}
{"SampleId": 2911711, "Origin": "The curves themselves are provided in {@link ScenarioMarketData}\nusing {@link CurveId} as the identifier.", "Reference": "The curves themselves are provided in {@link ScenarioMarketData}\nusing {@link RatesCurveId} as the identifier.", "LLMCandidates": ["The curves themselves are provided in {@link ScenarioMarketData} using {@link RatesCurveId} as the identifier.", "The curves themselves are provided in {@link ScenarioMarketData} using {@link RatesCurveId} as the identifier.", "The curves themselves are provided in {@link ScenarioMarketData} using {@link RatesCurveId} as the identifier.", "The curves themselves are provided in {@link ScenarioMarketData} using {@link RatesCurveId} as the identifier.", "The curves themselves are provided in {@link ScenarioMarketData} using {@link RatesCurveId} as the identifier."]}
{"SampleId": 116635, "Origin": "Add a list of documents to the Solr server.", "Reference": "Add a list of documents to the Solr client.", "LLMCandidates": ["Add a list of documents to the Solr client.", "Add a list of documents to the Solr client.", "Add a list of documents to the Solr client.", "Add a list of documents to the Solr server using the provided client object and optionally committing the changes.", "Add a list of documents to the Solr server using the provided client object and optionally committing the changes."]}
{"SampleId": 1358202, "Origin": "Report the pitch position of the nth item, within the given clef.", "Reference": "Report the pitch position of the nth item, within the given clef kind.", "LLMCandidates": ["Calculate the pitch position of the nth item within the given clef kind.", "Report the pitch of the nth item, within the given ClefKind.", "Report the pitch of the nth item, within the given clef kind.", "Report the pitch of the nth item, within the given clef kind.", "Report the pitch position of the nth item, within the given clef kind."]}
{"SampleId": 4470463, "Origin": "Creates a flux of {@link PagedResponse} starting from the first page.", "Reference": "Creates a Flux of {@link PagedResponse} starting from the first page.", "LLMCandidates": ["Creates a flux of {@link PagedResponse} using super.byPage().", "Creates a flux of {@link PagedResponse} starting from the first page.", "Creates a flux of {@link PagedResponse} starting from the first page.", "Creates a flux of {@link PagedResponse} using the super method.", "Creates a flux of {@link PagedResponse} using super method byPage()."]}
{"SampleId": 661691, "Origin": "Kafka Consumer properties are generated as follows:", "Reference": "Kafka Consumer properties are generated as follows:\n1.", "LLMCandidates": ["KafkaConsumerpropertiesaregeneratedasfollows:\n- This method initializes a subscriber based on the topics specified in the configuration. If no topic is specified, an exception is thrown.\n- It sets batchUpperLimit and maxBatchDurationMillis from the configuration.\n- It reads bootstrapServers from the configuration to set up the consumer properties.", "Configure the Kafka Source by setting properties from context, creating a subscriber and setting consumer props based on topic property.", "Kafka Consumer properties are generated using the provided configuration parameters for topics, batch sizes, and durations. The subscriber is created based on the topic specification, either pattern-based or topic list subscription. Bootstrap Servers must be specified.", "This method is used for initializing Kafka consumer properties in a Flume source. It sets up the topics to subscribe to based on input from the configuration context. The method also sets batch size and duration limits, as well as other consumer-specific settings. Finally, it creates an instance of KafkaSourceCounter if it doesn't already exist.", "The Kafka Consumer properties are generated using the given Kafka topics and related configurations."]}
{"SampleId": 5051649, "Origin": "Returns the builder for the settings used for calls to labelAudio.", "Reference": "Returns the builder for the settings used for calls to listEvaluationJobs.", "LLMCandidates": ["The builder for settings used for calls to listEvaluationJobs.", "Returns the builder for the settings used for calls to listEvaluationJobs.", "Returns the builder for the settings used for calls to listEvaluationJobs.", "Returns the builder for the settings used for calls to listEvaluationJobs.", "Returns the builder for the settings used for calls to listEvaluationJobs."]}
